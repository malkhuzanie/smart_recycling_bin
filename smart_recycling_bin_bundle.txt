================================================================================
PROJECT BUNDLE GENERATED BY PROJPACK
================================================================================

Project Root: /home/tomato/pr/ml/expert-systems/smart_recycling_bin
Generated: 2025-09-01 11:30:32
Total Files: 100

STATISTICS:
  Files processed: 100
  Total size: 421.5 KB
  Files ignored: 9
  Binary files skipped: 6
  Large files skipped: 0
  Directories scanned: 41
  Processing time: 0.02s

FILE STRUCTURE:
├── .claudeignore
├── .claudesync
│   └── config.local.json
├── .gitignore
├── .ppignore
├── backend
│   ├── Controllers
│   │   ├── ClassificationController.cs
│   │   ├── DashboardController.cs
│   │   └── SystemController.cs
│   ├── Data
│   │   └── ApplicationDbContext.cs
│   ├── Hubs
│   │   ├── ClassificationHub.cs
│   │   └── DashboardHub.cs
│   ├── Middleware
│   │   ├── ErrorHandlingMiddleware.cs
│   │   └── RequestLoggingMiddleware.cs
│   ├── Models
│   │   ├── ApplicationSettings.cs
│   │   ├── ClassificationModels.cs
│   │   ├── ClassificationSearchCriteria.cs
│   │   ├── CnnStageInfo.cs
│   │   ├── DTOs
│   │   │   ├── ClassificationRequestDto.cs
│   │   │   ├── ClassificationResponseDto.cs
│   │   │   └── DashboardStatsDto.cs
│   │   ├── ErrorResponse.cs
│   │   ├── PagedResult.cs
│   │   └── ValidationResult.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── launchSettings.json
│   ├── Services
│   │   ├── ClassificationService.cs
│   │   ├── IClassificationService.cs
│   │   ├── INotificationService.cs
│   │   ├── IOverrideService.cs
│   │   ├── ISystemHealthService.cs
│   │   ├── NotificationService.cs
│   │   ├── OverrideService.cs
│   │   ├── SystemHealthCheck.cs
│   │   └── SystemHealthService.cs
│   ├── SmartRecyclingBin.csproj
│   ├── SmartRecyclingBin.http
│   ├── appsettings.Development.json
│   └── appsettings.json
├── docker
│   └── dockerfiles
│       ├── Dockerfile.backend
│       ├── Dockerfile.frontend
│       └── Dockerfile.python
├── docker-compose.dev.yml
├── docker-compose.yml
├── frontend
│   ├── .env.development
│   ├── .gitignore
│   ├── .prettierrc
│   ├── Dockerfile.dev
│   ├── README.md
│   ├── nginx.conf
│   ├── package.json
│   ├── public
│   │   ├── index.html
│   │   ├── manifest.json
│   │   └── robots.txt
│   ├── src
│   │   ├── App.css
│   │   ├── App.test.tsx
│   │   ├── App.tsx
│   │   ├── components
│   │   │   ├── Classification
│   │   │   │   └── ClassificationHistory.tsx
│   │   │   ├── Dashboard
│   │   │   │   └── Dashboard.tsx
│   │   │   ├── Layout
│   │   │   │   └── Layout.tsx
│   │   │   └── System
│   │   │       └── SystemHealth.tsx
│   │   ├── hooks
│   │   │   ├── useApi.ts
│   │   │   ├── useSignalR.ts
│   │   │   └── useSystemHealth.ts
│   │   ├── index.css
│   │   ├── index.tsx
│   │   ├── react-app-env.d.ts
│   │   ├── reportWebVitals.ts
│   │   ├── services
│   │   │   ├── api.ts
│   │   │   └── signalr.ts
│   │   ├── setupTests.ts
│   │   └── types
│   │       └── index.ts
│   └── tsconfig.json
├── garbage_classification.py
├── models
│   └── garbage_classification.py
├── python-services
│   ├── connection_test.py
│   ├── main.py
│   ├── orchestrated_main_service.py
│   ├── pytest.ini
│   ├── requirements.txt
│   ├── requirements_integrated.txt
│   ├── services
│   │   ├── arduino_service.py
│   │   ├── cnn_service.py
│   │   └── hub_client.py
│   ├── setup.cfg
│   ├── setup.py
│   └── src
│       └── smart_bin
│           ├── __init__.py
│           ├── core
│           │   ├── __init__.py
│           │   ├── facts.py
│           │   ├── knowledge_engine.py
│           │   └── resolver.py
│           ├── interfaces
│           │   ├── __init__.py
│           │   └── cli.py
│           └── models
│               ├── __init__.py
│               ├── decisions.py
│               ├── sensors.py
│               └── waste_types.py
├── requirements-integrated.txt
├── requirements-test.txt
├── scripts
│   ├── start-mvp.sh
│   └── stop-mvp.sh
└── tree.txt

================================================================================
FILE CONTENTS
================================================================================

FILE: .claudeignore
------------------------------------------------------------
Size: 890 B
Encoding: ascii
------------------------------------------------------------
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Database
*.db
*.sqlite
*.sqlite3

# Models (too large for git)
models/*.keras
models/*.h5
models/*.pb

# Environment variables
.env
.env.local
.env.production

# Node.js (for frontend)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
build/

# .NET (for backend)
bin/
obj/
*.user
*.suo
*.userosscache
*.sln.docstates
.vs/

# Docker
.dockerignore

# Temporary files
*.tmp
*.temp
temp/

# Data files
data/*.db
data/*.sqlite
data/logs/


docs/
Readme.md
frontend/package-lock.json
python-services/tests/



FILE: .claudesync/config.local.json
------------------------------------------------------------
Size: 275 B
Encoding: ascii
------------------------------------------------------------
{
  "active_provider": "claude.ai",
  "local_path": "/home/tomato/pr/ml/expert-systems/projects/bin-mind",
  "active_organization_id": "e9b7908c-f1bf-45c5-8088-219a337d4168",
  "active_project_id": "01982c17-c0b9-7221-9fbd-2983cc43fd32",
  "active_project_name": "bin-mind"
}


FILE: .gitignore
------------------------------------------------------------
Size: 13 B
Encoding: ascii
------------------------------------------------------------
.claudesync/



FILE: .ppignore
------------------------------------------------------------
Size: 890 B
Encoding: ascii
------------------------------------------------------------
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
*.log
logs/

# Database
*.db
*.sqlite
*.sqlite3

# Models (too large for git)
models/*.keras
models/*.h5
models/*.pb

# Environment variables
.env
.env.local
.env.production

# Node.js (for frontend)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
build/

# .NET (for backend)
bin/
obj/
*.user
*.suo
*.userosscache
*.sln.docstates
.vs/

# Docker
.dockerignore

# Temporary files
*.tmp
*.temp
temp/

# Data files
data/*.db
data/*.sqlite
data/logs/


docs/
Readme.md
frontend/package-lock.json
python-services/tests/



FILE: backend/Controllers/ClassificationController.cs
------------------------------------------------------------
Size: 15.0 KB
Encoding: ascii
------------------------------------------------------------
// Controllers/ClassificationController.cs
using Microsoft.AspNetCore.Mvc;
using SmartRecyclingBin.Models;
using SmartRecyclingBin.Models.DTOs;
using SmartRecyclingBin.Services;
using System.ComponentModel.DataAnnotations;
using ValidationResult = SmartRecyclingBin.Models.ValidationResult;

namespace SmartRecyclingBin.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Produces("application/json")]
    public class ClassificationController : ControllerBase
    {
        private readonly IClassificationService _classificationService;
        private readonly IOverrideService _overrideService;
        private readonly ILogger<ClassificationController> _logger;

        public ClassificationController(
            IClassificationService classificationService,
            IOverrideService overrideService,
            ILogger<ClassificationController> logger)
        {
            _classificationService = classificationService;
            _overrideService = overrideService;
            _logger = logger;
        }

        /// <summary>
        /// Process a new classification request
        /// </summary>
        /// <param name="request">Classification data from Python services</param>
        /// <returns>Processed classification result</returns>
        [HttpPost]
        public async Task<ActionResult<ClassificationResult>> ProcessClassification(
            [FromBody] ClassificationRequestDto request)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var result = await _classificationService.ProcessClassificationResultAsync(request);
                
                _logger.LogInformation("Classification processed successfully: {Id}", result.Id);
                
                return CreatedAtAction(
                    nameof(GetClassification), 
                    new { id = result.Id }, 
                    result);
            }
            catch (ArgumentException ex)
            {
                _logger.LogWarning(ex, "Invalid classification request");
                return BadRequest(new { error = ex.Message });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing classification");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Get recent classification results with pagination and filtering
        /// </summary>
        /// <param name="page">Page number (1-based)</param>
        /// <param name="pageSize">Number of items per page</param>
        /// <param name="filterBy">Filter by classification type</param>
        /// <returns>Paginated list of classifications</returns>
        [HttpGet("recent")]
        public async Task<ActionResult<PagedResult<ClassificationResult>>> GetRecentClassifications(
            [FromQuery, Range(1, int.MaxValue)] int page = 1,
            [FromQuery, Range(1, 100)] int pageSize = 50,
            [FromQuery] string? filterBy = null)
        {
            try
            {
                var results = await _classificationService.GetRecentClassificationsAsync(page, pageSize, filterBy);
                return Ok(results);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving recent classifications");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Search classifications with advanced criteria
        /// </summary>
        /// <param name="criteria">Search criteria</param>
        /// <returns>List of matching classifications</returns>
        [HttpPost("search")]
        public async Task<ActionResult<List<ClassificationResult>>> SearchClassifications(
            [FromBody] ClassificationSearchCriteria criteria)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var results = await _classificationService.SearchClassificationsAsync(criteria);
                return Ok(results);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error searching classifications");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Get classification statistics for a date range
        /// </summary>
        /// <param name="fromDate">Start date (optional)</param>
        /// <param name="toDate">End date (optional)</param>
        /// <returns>Classification statistics</returns>
        [HttpGet("statistics")]
        public async Task<ActionResult<ClassificationStatistics>> GetStatistics(
            [FromQuery] DateTime? fromDate = null,
            [FromQuery] DateTime? toDate = null)
        {
            try
            {
                var stats = await _classificationService.GetStatisticsAsync(fromDate, toDate);
                return Ok(stats);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving statistics");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Get a specific classification by ID
        /// </summary>
        /// <param name="id">Classification ID</param>
        /// <returns>Classification result</returns>
        [HttpGet("{id:int}")]
        public async Task<ActionResult<ClassificationResult>> GetClassification(int id)
        {
            if (id <= 0)
            {
                return BadRequest(new { error = "Invalid classification ID" });
            }

            try
            {
                var classification = await _classificationService.GetClassificationAsync(id);
                
                if (classification == null)
                {
                    return NotFound(new { error = $"Classification with ID {id} not found" });
                }
                
                return Ok(classification);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving classification {Id}", id);
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Apply manual override to a classification
        /// </summary>
        /// <param name="request">Override request details</param>
        /// <returns>Success response</returns>
        [HttpPost("override")]
        public async Task<ActionResult> ApplyOverride([FromBody] ManualOverrideRequest request)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var success = await _overrideService.ApplyManualOverrideAsync(request);

                if (success)
                {
                    _logger.LogInformation("Manual override applied successfully for classification {Id} by {User}", 
                        request.ClassificationId, request.UserId);
                    
                    return Ok(new { 
                        message = "Override applied successfully",
                        classificationId = request.ClassificationId,
                        newClassification = request.NewClassification
                    });
                }
                else
                {
                    return NotFound(new { error = "Classification not found" });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error applying manual override for classification {Id}", 
                    request.ClassificationId);
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Get classifications that have been overridden
        /// </summary>
        /// <param name="count">Number of results to return</param>
        /// <returns>List of overridden classifications</returns>
        [HttpGet("overrides")]
        public async Task<ActionResult<List<ClassificationResult>>> GetOverriddenClassifications(
            [FromQuery, Range(1, 100)] int count = 50)
        {
            try
            {
                var results = await _overrideService.GetOverriddenClassificationsAsync(count);
                return Ok(results);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving overridden classifications");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Delete a classification (admin only)
        /// </summary>
        /// <param name="id">Classification ID to delete</param>
        /// <returns>Success response</returns>
        [HttpDelete("{id:int}")]
        public async Task<ActionResult> DeleteClassification(int id)
        {
            if (id <= 0)
            {
                return BadRequest(new { error = "Invalid classification ID" });
            }

            try
            {
                var success = await _classificationService.DeleteClassificationAsync(id);
                
                if (success)
                {
                    _logger.LogInformation("Classification {Id} deleted successfully", id);
                    return Ok(new { 
                        message = "Classification deleted successfully",
                        deletedId = id
                    });
                }
                else
                {
                    return NotFound(new { error = "Classification not found" });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting classification {Id}", id);
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Validate classification data without processing
        /// </summary>
        /// <param name="request">Classification data to validate</param>
        /// <returns>Validation result</returns>
        [HttpPost("validate")]
        public async Task<ActionResult<ValidationResult>> ValidateClassificationData(
            [FromBody] ClassificationRequestDto request)
        {
            try
            {
                var validation = await _classificationService.ValidateClassificationDataAsync(request);
                return Ok(validation);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error validating classification data");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Get classification summary for today
        /// </summary>
        /// <returns>Today's classification summary</returns>
        [HttpGet("today")]
        public async Task<ActionResult<object>> GetTodaysClassifications()
        {
            try
            {
                var today = DateTime.Today;
                var tomorrow = today.AddDays(1);
                
                var results = await _classificationService.SearchClassificationsAsync(new ClassificationSearchCriteria
                {
                    FromDate = today,
                    ToDate = tomorrow,
                    Limit = 1000
                });

                var summary = new
                {
                    Date = today.ToString("yyyy-MM-dd"),
                    TotalItems = results.Count,
                    Classifications = results
                        .GroupBy(r => r.FinalClassification)
                        .ToDictionary(g => g.Key, g => g.Count()),
                    AverageConfidence = results.Count > 0 ? results.Average(r => r.FinalConfidence) : 0,
                    OverrideCount = results.Count(r => r.IsOverridden),
                    OverrideRate = results.Count > 0 ? (double)results.Count(r => r.IsOverridden) / results.Count * 100 : 0
                };

                return Ok(summary);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving today's classifications");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        /// <summary>
        /// Export classifications to CSV format
        /// </summary>
        /// <param name="fromDate">Start date for export</param>
        /// <param name="toDate">End date for export</param>
        /// <returns>CSV file</returns>
        [HttpGet("export")]
        public async Task<IActionResult> ExportClassifications(
            [FromQuery] DateTime? fromDate = null,
            [FromQuery] DateTime? toDate = null)
        {
            try
            {
                fromDate ??= DateTime.UtcNow.AddDays(-30);
                toDate ??= DateTime.UtcNow;

                var criteria = new ClassificationSearchCriteria
                {
                    FromDate = fromDate,
                    ToDate = toDate,
                    Limit = 10000
                };

                var results = await _classificationService.SearchClassificationsAsync(criteria);

                var csvContent = GenerateCsvContent(results);
                var bytes = System.Text.Encoding.UTF8.GetBytes(csvContent);

                var fileName = $"classifications_{fromDate:yyyy-MM-dd}_{toDate:yyyy-MM-dd}.csv";

                return File(bytes, "text/csv", fileName);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error exporting classifications");
                return StatusCode(500, new { error = "Internal server error" });
            }
        }

        private string GenerateCsvContent(List<ClassificationResult> results)
        {
            var csv = new System.Text.StringBuilder();
            
            // Header
            csv.AppendLine("Id,Timestamp,CnnPredictedClass,CnnConfidence,FinalClassification,FinalConfidence,DisposalLocation,WeightGrams,IsMetalDetected,IsOverridden,ProcessingTimeMs");
            
            // Data rows
            foreach (var result in results)
            {
                csv.AppendLine($"{result.Id}," +
                              $"{result.Timestamp:yyyy-MM-dd HH:mm:ss}," +
                              $"\"{result.CnnPredictedClass}\"," +
                              $"{result.CnnConfidence:F3}," +
                              $"\"{result.FinalClassification}\"," +
                              $"{result.FinalConfidence:F3}," +
                              $"\"{result.DisposalLocation}\"," +
                              $"{result.WeightGrams:F1}," +
                              $"{result.IsMetalDetected}," +
                              $"{result.IsOverridden}," +
                              $"{result.ProcessingTimeMs:F1}");
            }
            
            return csv.ToString();
        }
    }
}


FILE: backend/Controllers/DashboardController.cs
------------------------------------------------------------
Size: 6.1 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.AspNetCore.Mvc;
using SmartRecyclingBin.Models.DTOs;
using SmartRecyclingBin.Services;

namespace SmartRecyclingBin.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class DashboardController : ControllerBase
    {
        private readonly IClassificationService _classificationService;
        private readonly ISystemHealthService _healthService;
        private readonly INotificationService _notificationService;
        private readonly ILogger<DashboardController> _logger;

        public DashboardController(
            IClassificationService classificationService,
            ISystemHealthService healthService,
            INotificationService notificationService,
            ILogger<DashboardController> logger)
        {
            _classificationService = classificationService;
            _healthService = healthService;
            _notificationService = notificationService;
            _logger = logger;
        }

        /// <summary>
        /// Get comprehensive dashboard statistics
        /// </summary>
        [HttpGet("stats")]
        public async Task<ActionResult<DashboardStatsDto>> GetDashboardStats()
        {
            try
            {
                var healthMetrics = await _healthService.GetCurrentHealthAsync();
                var statistics = await _classificationService.GetStatisticsAsync(DateTime.Today);
                var recentClassifications = await _classificationService.GetRecentClassificationsAsync(1, 10);
                var activeAlerts = await _healthService.GetActiveAlertsAsync();

                var dashboardStats = new DashboardStatsDto
                {
                    SystemStatus = new SystemStatusDto
                    {
                        CameraConnected = healthMetrics.CameraConnected,
                        ArduinoConnected = healthMetrics.ArduinoConnected,
                        CnnServiceHealthy = healthMetrics.CnnServiceHealthy,
                        ExpertSystemHealthy = healthMetrics.ExpertSystemHealthy,
                        LastHealthCheck = DateTime.UtcNow
                    },
                    ProcessingStats = new ProcessingStatsDto
                    {
                        TotalItemsToday = statistics.ItemsToday,
                        AverageAccuracy = statistics.AccuracyRate,
                        AverageProcessingTime = statistics.AvgProcessingTime,
                        OverrideRate = statistics.OverrideRate,
                        ClassificationBreakdown = statistics.ClassificationBreakdown
                    },
                    RecentActivity = recentClassifications.Items.Select(c => new RecentActivityDto
                    {
                        Timestamp = c.Timestamp,
                        Classification = c.FinalClassification,
                        DisposalLocation = c.DisposalLocation,
                        Confidence = c.FinalConfidence,
                        IsOverridden = c.IsOverridden
                    }).ToList(),
                    Alerts = new AlertSummaryDto
                    {
                        TotalActiveAlerts = activeAlerts.Count,
                        CriticalAlerts = activeAlerts.Count(a => a.Severity == "CRITICAL"),
                        WarningAlerts = activeAlerts.Count(a => a.Severity == "WARNING"),
                        InfoAlerts = activeAlerts.Count(a => a.Severity == "INFO"),
                        RecentAlerts = activeAlerts.Take(5).ToList()
                    }
                };

                return Ok(dashboardStats);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving dashboard statistics");
                return StatusCode(500, "Internal server error");
            }
        }

        /// <summary>
        /// Get real-time system status
        /// </summary>
        [HttpGet("status")]
        public async Task<ActionResult<SystemStatusDto>> GetSystemStatus()
        {
            try
            {
                var healthMetrics = await _healthService.GetCurrentHealthAsync();
                
                var status = new SystemStatusDto
                {
                    CameraConnected = healthMetrics.CameraConnected,
                    ArduinoConnected = healthMetrics.ArduinoConnected,
                    CnnServiceHealthy = healthMetrics.CnnServiceHealthy,
                    ExpertSystemHealthy = healthMetrics.ExpertSystemHealthy,
                    LastHealthCheck = DateTime.UtcNow
                };

                return Ok(status);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving system status");
                return StatusCode(500, "Internal server error");
            }
        }

        /// <summary>
        /// Get processing performance metrics
        /// </summary>
        [HttpGet("performance")]
        public async Task<ActionResult<object>> GetPerformanceMetrics([FromQuery] int hours = 24)
        {
            try
            {
                var fromDate = DateTime.UtcNow.AddHours(-hours);
                var statistics = await _classificationService.GetStatisticsAsync(fromDate);

                var performanceMetrics = new
                {
                    TotalProcessed = statistics.TotalItems,
                    AverageAccuracy = statistics.AccuracyRate,
                    AverageProcessingTime = statistics.AvgProcessingTime,
                    ThroughputPerHour = statistics.TotalItems / (double)hours,
                    OverrideRate = statistics.OverrideRate,
                    HourlyBreakdown = statistics.HourlyBreakdown.Select(h => new
                    {
                        Hour = h.Hour.ToString("yyyy-MM-dd HH:00"),
                        Count = h.Count,
                        Accuracy = h.AvgAccuracy
                    })
                };

                return Ok(performanceMetrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving performance metrics");
                return StatusCode(500, "Internal server error");
            }
        }
    }
}



FILE: backend/Controllers/SystemController.cs
------------------------------------------------------------
Size: 9.1 KB
Encoding: ascii
------------------------------------------------------------
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using Microsoft.AspNetCore.Mvc;
using SmartRecyclingBin.Models;
using SmartRecyclingBin.Services;

namespace SmartRecyclingBin.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class SystemController : ControllerBase
    {
        private readonly ISystemHealthService _healthService;
        private readonly INotificationService _notificationService;
        private readonly ILogger<SystemController> _logger;

        public SystemController(
            ISystemHealthService healthService,
            INotificationService notificationService,
            ILogger<SystemController> logger)
        {
            _healthService = healthService;
            _notificationService = notificationService;
            _logger = logger;
        }

        /// <summary>
        /// Get system health metrics
        /// </summary>
        [HttpGet("health")]
        public async Task<ActionResult<SystemHealthMetrics>> GetSystemHealth()
        {
            try
            {
                var health = await _healthService.GetCurrentHealthAsync();
                return Ok(health);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving system health");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Get active system alerts - FIXED ENDPOINT
        /// </summary>
        [HttpGet("alerts")]
        public async Task<ActionResult<List<SystemAlert>>> GetActiveAlerts()
        {
            try
            {
                var alerts = await _healthService.GetActiveAlertsAsync();
                _logger.LogInformation("Retrieved {AlertCount} active alerts", alerts.Count);
                return Ok(alerts);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving active alerts");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Get recent alerts (including resolved ones)
        /// </summary>
        [HttpGet("alerts/recent")]
        public async Task<ActionResult<List<SystemAlert>>> GetRecentAlerts([FromQuery] int count = 20)
        {
            try
            {
                var alerts = await _notificationService.GetRecentAlerts(count);
                return Ok(alerts);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving recent alerts");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Resolve a system alert
        /// </summary>
        [HttpPost("alerts/{id}/resolve")]
        public async Task<ActionResult> ResolveAlert(int id, [FromBody] ResolveAlertRequest request)
        {
            try
            {
                if (string.IsNullOrEmpty(request.ResolvedBy))
                {
                    return BadRequest(new { error = "ResolvedBy field is required" });
                }

                await _notificationService.ResolveAlert(id, request.ResolvedBy);
                _logger.LogInformation("Alert {AlertId} resolved by {ResolvedBy}", id, request.ResolvedBy);
                return Ok(new { message = "Alert resolved successfully", alertId = id });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error resolving alert {AlertId}", id);
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Create a new system alert (for testing or manual alerts)
        /// </summary>
        [HttpPost("alerts")]
        public async Task<ActionResult> CreateAlert([FromBody] CreateAlertRequest request)
        {
            try
            {
                if (!ModelState.IsValid)
                {
                    return BadRequest(ModelState);
                }

                var alert = new SystemAlert
                {
                    Severity = request.Severity,
                    Component = request.Component,
                    Message = request.Message,
                    Timestamp = DateTime.UtcNow
                };

                await _notificationService.AddAlert(alert);
                _logger.LogInformation("New alert created: {Severity} - {Message}", request.Severity, request.Message);
                
                return CreatedAtAction(nameof(GetActiveAlerts), new { id = alert.Id }, alert);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error creating alert");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Get system metrics over time
        /// </summary>
        [HttpGet("metrics")]
        public async Task<ActionResult<Dictionary<string, object>>> GetMetrics(
            [FromQuery] DateTime? fromDate = null)
        {
            try
            {
                var from = fromDate ?? DateTime.UtcNow.AddHours(-24);
                
                var metrics = new Dictionary<string, object>
                {
                    ["timestamp"] = DateTime.UtcNow,
                    ["period_start"] = from,
                    ["period_end"] = DateTime.UtcNow,
                    ["processing_queue_size"] = 0,
                    ["avg_processing_time_ms"] = 150.0,
                    ["error_rate_percent"] = 0.5,
                    ["classification_accuracy"] = 0.94,
                    ["system_uptime_hours"] = (DateTime.UtcNow - Process.GetCurrentProcess().StartTime).TotalHours,
                    ["memory_usage_mb"] = GC.GetTotalMemory(false) / 1024.0 / 1024.0
                };

                return Ok(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving system metrics");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Get system status summary
        /// </summary>
        [HttpGet("status")]
        public async Task<ActionResult<object>> GetSystemStatus()
        {
            try
            {
                var health = await _healthService.GetCurrentHealthAsync();
                var activeAlerts = await _healthService.GetActiveAlertsAsync();
                
                var status = new
                {
                    timestamp = DateTime.UtcNow,
                    overall_healthy = health.CnnServiceHealthy && health.ExpertSystemHealthy && 
                                    health.CameraConnected && health.ArduinoConnected,
                    components = new
                    {
                        cnn_service = health.CnnServiceHealthy,
                        expert_system = health.ExpertSystemHealthy,
                        camera = health.CameraConnected,
                        arduino = health.ArduinoConnected
                    },
                    metrics = new
                    {
                        avg_processing_time_ms = health.AvgProcessingTimeMs,
                        total_items_processed = health.TotalItemsProcessed,
                        accuracy_rate = health.AccuracyRate,
                        system_uptime_hours = health.SystemUptime,
                        memory_usage_mb = health.MemoryUsageMB
                    },
                    alerts = new
                    {
                        total_active = activeAlerts.Count,
                        critical = activeAlerts.Count(a => a.Severity == "CRITICAL"),
                        warning = activeAlerts.Count(a => a.Severity == "WARNING"),
                        info = activeAlerts.Count(a => a.Severity == "INFO")
                    }
                };

                return Ok(status);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving system status");
                return StatusCode(500, new { error = "Internal server error", details = ex.Message });
            }
        }

        /// <summary>
        /// Test endpoint to verify API connectivity
        /// </summary>
        [HttpGet("ping")]
        public ActionResult<object> Ping()
        {
            return Ok(new 
            { 
                message = "System API is responding", 
                timestamp = DateTime.UtcNow,
                version = "1.0.0"
            });
        }
    }

    public class ResolveAlertRequest
    {
        public string ResolvedBy { get; set; } = string.Empty;
    }

    public class CreateAlertRequest
    {
        [Required]
        public string Severity { get; set; } = string.Empty; // INFO, WARNING, ERROR, CRITICAL
        
        [Required]
        public string Component { get; set; } = string.Empty;
        
        [Required]
        public string Message { get; set; } = string.Empty;
    }
}



FILE: backend/Data/ApplicationDbContext.cs
------------------------------------------------------------
Size: 2.6 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.EntityFrameworkCore;
using SmartRecyclingBin.Models;
using System.Text.Json;

namespace SmartRecyclingBin.Data
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) 
            : base(options) { }

        public DbSet<ClassificationResult> ClassificationResults { get; set; }
        public DbSet<SystemHealthMetrics> HealthMetrics { get; set; }
        public DbSet<SystemAlert> SystemAlerts { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure ClassificationResult
            modelBuilder.Entity<ClassificationResult>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Timestamp).HasDefaultValueSql("datetime('now')");
                entity.HasIndex(e => e.Timestamp);
                entity.HasIndex(e => e.FinalClassification);
                entity.HasIndex(e => e.IsOverridden);
                
                // Add constraints
                entity.Property(e => e.CnnPredictedClass).IsRequired().HasMaxLength(100);
                entity.Property(e => e.FinalClassification).IsRequired().HasMaxLength(100);
                entity.Property(e => e.DisposalLocation).IsRequired().HasMaxLength(200);
                entity.Property(e => e.Reasoning).HasMaxLength(500);
            });

            // Configure SystemHealthMetrics
            modelBuilder.Entity<SystemHealthMetrics>(entity =>
            {
                entity.HasKey(e => e.Timestamp);
                entity.Property(e => e.ClassificationCounts)
                      .HasConversion(
                          v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                          v => JsonSerializer.Deserialize<Dictionary<string, int>>(v, (JsonSerializerOptions?)null) ?? new()
                      );
            });

            // Configure SystemAlert
            modelBuilder.Entity<SystemAlert>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.Property(e => e.Timestamp).HasDefaultValueSql("datetime('now')");
                entity.HasIndex(e => e.Timestamp);
                entity.HasIndex(e => e.Severity);
                entity.HasIndex(e => e.IsResolved);
                
                entity.Property(e => e.Severity).IsRequired().HasMaxLength(20);
                entity.Property(e => e.Component).IsRequired().HasMaxLength(100);
                entity.Property(e => e.Message).IsRequired().HasMaxLength(500);
            });

            base.OnModelCreating(modelBuilder);
        }
    }
}



FILE: backend/Hubs/ClassificationHub.cs
------------------------------------------------------------
Size: 27.4 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.AspNetCore.SignalR;
using System.Text.Json;
using SmartRecyclingBin.Models;
using SmartRecyclingBin.Services;
using SmartRecyclingBin.Models.DTOs;

namespace SmartRecyclingBin.Hubs
{
    /// <summary>
    /// SignalR Hub for real-time waste classification communication
    /// Handles communication between Python services, dashboard, and manual override devices
    /// </summary>
    public class ClassificationHub : Hub
    {
        private readonly IClassificationService _classificationService;
        private readonly IOverrideService _overrideService;
        private readonly INotificationService _notificationService;
        private readonly ILogger<ClassificationHub> _logger;

        public ClassificationHub(
            IClassificationService classificationService,
            IOverrideService overrideService,
            INotificationService notificationService,
            ILogger<ClassificationHub> logger)
        {
            _classificationService = classificationService;
            _overrideService = overrideService;
            _notificationService = notificationService;
            _logger = logger;
        }

        /// <summary>
        /// Handle classification results from Python services
        /// </summary>
        public async Task SendClassificationResult(string jsonData)
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            try
            {
                _logger.LogInformation("Received classification result from {ClientType} client {ConnectionId}", 
                    clientType, connectionId);
                
                var classificationData = JsonSerializer.Deserialize<EnhancedClassificationRequestDto>(jsonData);
                
                if (classificationData == null)
                {
                    _logger.LogWarning("Null classification data received from connection {ConnectionId}", connectionId);
                    await Clients.Caller.SendAsync("Error", "Classification data is null");
                    return;
                }

                // Map enhanced data structure to existing DTO for processing
                var standardRequest = MapEnhancedToStandard(classificationData);
                
                var result = await _classificationService.ProcessClassificationResultAsync(standardRequest);
                
                // Create enhanced response with validation results from sensor data
                var validationResults = CreateValidationResults(classificationData);
                
                var responseDto = new EnhancedClassificationResponseDto
                {
                    Id = result.Id,
                    DetectionId = classificationData.DetectionId ?? $"detection_{result.Id}",
                    Timestamp = result.Timestamp,
                    FinalClassification = result.FinalClassification,
                    FinalConfidence = result.FinalConfidence,
                    DisposalLocation = result.DisposalLocation,
                    Reasoning = result.Reasoning,
                    IsOverridden = result.IsOverridden,
                    ProcessingTimeMs = result.ProcessingTimeMs,
                    
                    // Enhanced fields
                    ProcessingPipeline = classificationData.ProcessingMetadata?.StagesCompleted?.ToArray() ?? new string[0],
                    ValidationResults = validationResults,
                    CnnStages = new CnnStageInfo
                    {
                        Stage1Result = classificationData.CnnPrediction?.Stage1,
                        Stage2Result = classificationData.CnnPrediction?.Stage2,
                        TotalConfidence = classificationData.CnnPrediction?.TotalConfidence ?? 0.0
                    },
                    
                    SensorData = classificationData.SensorData,
                    
                    Metadata = new Dictionary<string, object>
                    {
                        { "ProcessedAt", DateTime.UtcNow },
                        { "ConnectionId", connectionId },
                        { "ClientType", clientType },
                        { "PipelineVersion", classificationData.ProcessingMetadata?.PipelineVersion ?? "unknown" },
                        { "ProcessingNode", classificationData.ProcessingMetadata?.ProcessingNode ?? "unknown" },
                        { "FallbackUsed", classificationData.ProcessingMetadata?.FallbackUsed ?? false }
                    }
                };
                
                // Send to all clients in Classification group
                await Clients.Group("Classification").SendAsync("ClassificationResult", responseDto);
                
                // Send enhanced data to dashboard group
                var dashboardData = new
                {
                    Type = "classification_complete",
                    Classification = responseDto,
                    SystemStatus = "Processing",
                    Timestamp = DateTime.UtcNow,
                    ProcessingStats = new
                    {
                        PipelineStages = responseDto.ProcessingPipeline,
                        ValidationPassed = CountValidationPasses(responseDto.ValidationResults),
                        SensorDataQuality = AssessSensorDataQuality(responseDto.SensorData)
                    }
                };
                
                await Clients.Group("Dashboard").SendAsync("ClassificationUpdate", dashboardData);
                
                // Send alerts for concerning results
                await ProcessClassificationAlerts(responseDto);
                
                _logger.LogInformation("Classification broadcasted: {Classification} (confidence: {Confidence:F2}, ID: {Id}, Detection: {DetectionId})", 
                    result.FinalClassification, result.FinalConfidence, result.Id, responseDto.DetectionId);
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Invalid JSON format in classification result from connection {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Invalid JSON format in classification data");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing classification result from connection {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Error processing classification result");
            }
        }

        /// <summary>
        /// Handle manual override from connected devices/clients
        /// </summary>
        public async Task ApplyManualOverride(string overrideData)
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            try
            {
                _logger.LogInformation("Received manual override request from {ClientType} client {ConnectionId}", 
                    clientType, connectionId);
                
                var overrideRequest = JsonSerializer.Deserialize<ManualOverrideRequestDto>(overrideData);
                
                if (overrideRequest == null)
                {
                    _logger.LogWarning("Null override request received from connection {ConnectionId}", connectionId);
                    await Clients.Caller.SendAsync("OverrideError", "Override request is null");
                    return;
                }

                // Convert to service request format
                var serviceRequest = new ManualOverrideRequest
                {
                    ClassificationId = overrideRequest.ClassificationId,
                    NewClassification = overrideRequest.NewClassification,
                    NewDisposalLocation = overrideRequest.NewDisposalLocation,
                    Reason = overrideRequest.Reason,
                    UserId = overrideRequest.UserId ?? $"device_{clientType}_{connectionId[0..8]}"
                };

                var success = await _overrideService.ApplyManualOverrideAsync(serviceRequest);
                
                if (success)
                {
                    // Broadcast override notification to all connected clients
                    var overrideNotification = new
                    {
                        Type = "manual_override_applied",
                        ClassificationId = serviceRequest.ClassificationId,
                        NewClassification = serviceRequest.NewClassification,
                        NewDisposalLocation = serviceRequest.NewDisposalLocation,
                        Reason = serviceRequest.Reason,
                        OverriddenBy = serviceRequest.UserId,
                        Timestamp = DateTime.UtcNow,
                        ConnectionId = connectionId,
                        ClientType = clientType
                    };

                    // Notify all classification clients
                    await Clients.Group("Classification").SendAsync("ClassificationOverridden", overrideNotification);
                    
                    // Notify dashboard
                    await Clients.Group("Dashboard").SendAsync("OverrideApplied", overrideNotification);
                    
                    // Confirm to the requesting client
                    await Clients.Caller.SendAsync("OverrideSuccess", new
                    {
                        Message = "Manual override applied successfully",
                        ClassificationId = serviceRequest.ClassificationId,
                        Timestamp = DateTime.UtcNow
                    });

                    _logger.LogInformation("Manual override applied successfully by {UserId} for classification {ClassificationId}", 
                        serviceRequest.UserId, serviceRequest.ClassificationId);
                }
                else
                {
                    await Clients.Caller.SendAsync("OverrideError", new
                    {
                        Message = "Failed to apply override - classification not found",
                        ClassificationId = overrideRequest.ClassificationId
                    });
                    
                    _logger.LogWarning("Failed to apply override for classification {ClassificationId} - not found", 
                        overrideRequest.ClassificationId);
                }
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Invalid JSON format in override request from connection {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("OverrideError", "Invalid JSON format in override request");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing manual override from connection {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("OverrideError", "Error processing manual override");
            }
        }

        /// <summary>
        /// Handle item detection notifications from Arduino/sensor services
        /// </summary>
        public async Task NotifyItemDetection(string detectionData)
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            try
            {
                _logger.LogInformation("Received item detection from {ClientType} client {ConnectionId}", 
                    clientType, connectionId);
                
                var detection = JsonSerializer.Deserialize<ItemDetectionDto>(detectionData);
                
                if (detection != null)
                {
                    // Broadcast to all connected clients
                    await Clients.Group("Classification").SendAsync("ItemDetected", new
                    {
                        Type = "item_detected",
                        ItemId = detection.ItemId,
                        Timestamp = detection.Timestamp,
                        DetectionType = detection.Type,
                        SensorData = detection.SensorData,
                        Source = clientType
                    });

                    // Notify dashboard
                    await Clients.Group("Dashboard").SendAsync("ItemDetection", new
                    {
                        Type = "item_detection",
                        Data = detection,
                        Source = clientType,
                        Timestamp = DateTime.UtcNow
                    });

                    _logger.LogInformation("Item detection broadcasted: {ItemId} from {ClientType}", 
                        detection.ItemId, clientType);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing item detection from connection {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Error processing item detection");
            }
        }

        /// <summary>
        /// Handle service heartbeat from Python services
        /// </summary>
        public async Task SendHeartbeat(string heartbeatData)
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            try
            {
                var heartbeat = JsonSerializer.Deserialize<ServiceHeartbeatDto>(heartbeatData);
                
                if (heartbeat != null)
                {
                    // Update service status and notify dashboard
                    await Clients.Group("Dashboard").SendAsync("ServiceHeartbeat", new
                    {
                        Type = "service_heartbeat",
                        Service = heartbeat,
                        ConnectionId = connectionId,
                        ClientType = clientType,
                        ReceivedAt = DateTime.UtcNow
                    });

                    _logger.LogDebug("Heartbeat received from {ServiceName} ({ClientType}): Status={Status}", 
                        heartbeat.ServiceName, clientType, heartbeat.Status);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing heartbeat from connection {ConnectionId}", connectionId);
            }
        }

        /// <summary>
        /// Join classification group for receiving real-time updates
        /// </summary>
        public async Task JoinClassificationGroup()
        {
            var connectionId = Context.ConnectionId;
            var userAgent = Context.GetHttpContext()?.Request.Headers["User-Agent"].ToString() ?? "Unknown";
            
            await Groups.AddToGroupAsync(connectionId, "Classification");
            _logger.LogInformation("Client {ConnectionId} joined Classification group. User-Agent: {UserAgent}", 
                connectionId, userAgent);
            
            await Clients.Caller.SendAsync("JoinedClassificationGroup", new
            {
                ConnectionId = connectionId,
                Message = "Successfully joined classification group",
                Timestamp = DateTime.UtcNow,
                GroupName = "Classification"
            });
        }

        /// <summary>
        /// Join dashboard group for receiving system updates
        /// </summary>
        public async Task JoinDashboardGroup()
        {
            var connectionId = Context.ConnectionId;
            var userAgent = Context.GetHttpContext()?.Request.Headers["User-Agent"].ToString() ?? "Unknown";
            
            await Groups.AddToGroupAsync(connectionId, "Dashboard");
            _logger.LogInformation("Client {ConnectionId} joined Dashboard group. User-Agent: {UserAgent}", 
                connectionId, userAgent);
            
            await Clients.Caller.SendAsync("JoinedDashboardGroup", new
            {
                ConnectionId = connectionId,
                Message = "Successfully joined dashboard group", 
                Timestamp = DateTime.UtcNow,
                GroupName = "Dashboard"
            });
        }

        // Helper Methods

        private Dictionary<string, object> CreateValidationResults(EnhancedClassificationRequestDto classificationData)
        {
            var validationResults = new Dictionary<string, object>();
            
            // Create validation results based on sensor data and expert system results
            if (classificationData.SensorData != null)
            {
                validationResults["weight_validation"] = ValidateWeight(classificationData) ? "pass" : "fail";
                validationResults["metal_validation"] = ValidateMetal(classificationData) ? "pass" : "fail";
                validationResults["humidity_validation"] = ValidateHumidity(classificationData) ? "pass" : "fail";
                validationResults["ir_spectroscopy_validation"] = "pass"; // Assume pass if no IR data
            }

            if (classificationData.ExpertSystemResult != null)
            {
                validationResults["expert_system_confidence"] = classificationData.ExpertSystemResult.Confidence;
                validationResults["candidates_count"] = classificationData.ExpertSystemResult.CandidatesCount;
            }

            return validationResults;
        }

        private bool ValidateWeight(EnhancedClassificationRequestDto data)
        {
            if (data.SensorData == null) return true;
            
            // Basic weight validation logic
            var weight = data.SensorData.WeightGrams;
            var classification = data.ExpertSystemResult?.FinalClassification?.ToLower();
            
            return classification switch
            {
                "metal" => weight > 5.0, // Metal items typically heavier
                "glass" => weight > 10.0, // Glass items typically heavy
                "plastic" => weight < 100.0, // Plastic items typically lighter
                "paper" => weight < 50.0, // Paper items typically light
                "organic" => weight > 0.5, // Organic items vary widely
                _ => true // Unknown classifications pass validation
            };
        }

        private bool ValidateMetal(EnhancedClassificationRequestDto data)
        {
            if (data.SensorData == null) return true;
            
            var isMetalDetected = data.SensorData.IsMetalDetected;
            var classification = data.ExpertSystemResult?.FinalClassification?.ToLower();
            
            return classification switch
            {
                "metal" => isMetalDetected, // Metal classification should detect metal
                _ => true // Non-metal classifications don't require metal detection
            };
        }

        private bool ValidateHumidity(EnhancedClassificationRequestDto data)
        {
            if (data.SensorData == null) return true;
            
            var humidity = data.SensorData.HumidityPercent;
            var classification = data.ExpertSystemResult?.FinalClassification?.ToLower();
            
            return classification switch
            {
                "organic" => humidity > 30.0, // Organic items typically have higher humidity
                "paper" when humidity > 60.0 => false, // Wet paper shouldn't be recycled
                _ => true // Other classifications are less sensitive to humidity
            };
        }

        private ClassificationRequestDto MapEnhancedToStandard(EnhancedClassificationRequestDto enhanced)
        {
            return new ClassificationRequestDto
            {
                CnnPrediction = enhanced.CnnPrediction?.Stage1 ?? enhanced.CnnPrediction?.Stage2,
                SensorData = enhanced.SensorData,
                ExpertSystemResult = enhanced.ExpertSystemResult,
                Timestamp = DateTime.TryParse(enhanced.Timestamp, out var ts) ? ts : DateTime.UtcNow
            };
        }

        private int CountValidationPasses(Dictionary<string, object> validationResults)
        {
            return validationResults.Values
                .Where(v => v?.ToString()?.Equals("pass", StringComparison.OrdinalIgnoreCase) == true)
                .Count();
        }

        private string AssessSensorDataQuality(SensorDataDto? sensorData)
        {
            if (sensorData == null) return "no_data";
            
            var qualityScore = 0;
            if (sensorData.WeightGrams > 0) qualityScore++;
            if (sensorData.HumidityPercent >= 0) qualityScore++;
            if (sensorData.TemperatureCelsius > -40) qualityScore++;
            
            return qualityScore switch
            {
                3 => "excellent",
                2 => "good", 
                1 => "fair",
                _ => "poor"
            };
        }

        private async Task ProcessClassificationAlerts(EnhancedClassificationResponseDto responseDto)
        {
            // Check for low confidence classifications
            if (responseDto.FinalConfidence < 0.7)
            {
                await _notificationService.AddAlert(new SystemAlert
                {
                    Severity = "WARNING",
                    Component = "Classification",
                    Message = $"Low confidence classification: {responseDto.FinalClassification} ({responseDto.FinalConfidence:F2})"
                });
            }

            // Check for validation failures
            var failedValidations = responseDto.ValidationResults
                .Where(kv => kv.Value?.ToString()?.Equals("fail", StringComparison.OrdinalIgnoreCase) == true)
                .Count();

            if (failedValidations > 1)
            {
                await _notificationService.AddAlert(new SystemAlert
                {
                    Severity = "INFO",
                    Component = "Validation",
                    Message = $"Multiple validation failures ({failedValidations}) for detection {responseDto.DetectionId}"
                });
            }
        }

        private string DetermineClientType()
        {
            var userAgent = Context.GetHttpContext()?.Request.Headers["User-Agent"].ToString() ?? "";
            var connectionId = Context.ConnectionId;
            
            return userAgent.ToLower() switch
            {
                var ua when ua.Contains("python") => "python_service",
                var ua when ua.Contains("arduino") => "arduino_service", 
                var ua when ua.Contains("cnn") => "cnn_service",
                var ua when ua.Contains("chrome") => "web_dashboard",
                var ua when ua.Contains("firefox") => "web_dashboard",
                var ua when ua.Contains("safari") => "web_dashboard",
                _ => "unknown"
            };
        }

        // Connection event handlers
        public override async Task OnConnectedAsync()
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            _logger.LogInformation("Client connected to ClassificationHub: {ConnectionId} (Type: {ClientType})", 
                connectionId, clientType);
                
            await Clients.Caller.SendAsync("Connected", new
            {
                ConnectionId = connectionId,
                ClientType = clientType,
                Message = "Connected to ClassificationHub",
                Timestamp = DateTime.UtcNow,
                HubVersion = "v2.0",
                SupportedOperations = new[] { "SendClassificationResult", "ApplyManualOverride", "NotifyItemDetection", "SendHeartbeat" }
            });
            
            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var connectionId = Context.ConnectionId;
            var clientType = DetermineClientType();
            
            if (exception != null)
            {
                _logger.LogError(exception, "Client disconnected from ClassificationHub with error: {ConnectionId} (Type: {ClientType})", 
                    connectionId, clientType);
            }
            else
            {
                _logger.LogInformation("Client disconnected from ClassificationHub: {ConnectionId} (Type: {ClientType})", 
                    connectionId, clientType);
            }
            
            await base.OnDisconnectedAsync(exception);
        }
    }

    // DTOs for enhanced functionality

    public class ManualOverrideRequestDto
    {
        public int ClassificationId { get; set; }
        public string NewClassification { get; set; } = string.Empty;
        public string NewDisposalLocation { get; set; } = string.Empty;
        public string Reason { get; set; } = string.Empty;
        public string? UserId { get; set; }
    }

    public class EnhancedClassificationRequestDto
    {
        public string? DetectionId { get; set; }
        public string? Timestamp { get; set; }
        public double ProcessingTimeMs { get; set; }
        public CnnPredictionEnhancedDto? CnnPrediction { get; set; }
        public SensorDataDto? SensorData { get; set; }
        public ExpertSystemResultDto? ExpertSystemResult { get; set; }
        public ProcessingMetadataDto? ProcessingMetadata { get; set; }
    }

    public class CnnPredictionEnhancedDto
    {
        public CnnPredictionDto? Stage1 { get; set; }
        public CnnPredictionDto? Stage2 { get; set; }
        public double TotalConfidence { get; set; }
    }

    public class ProcessingMetadataDto
    {
        public string? PipelineVersion { get; set; }
        public string? ModelVersion { get; set; }
        public string? ProcessingNode { get; set; }
        public List<string>? StagesCompleted { get; set; }
        public bool FallbackUsed { get; set; }
    }

    public class EnhancedClassificationResponseDto
    {
        public int Id { get; set; }
        public string DetectionId { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public string FinalClassification { get; set; } = string.Empty;
        public double FinalConfidence { get; set; }
        public string DisposalLocation { get; set; } = string.Empty;
        public string Reasoning { get; set; } = string.Empty;
        public bool IsOverridden { get; set; }
        public double ProcessingTimeMs { get; set; }
        
        // Enhanced fields
        public string[] ProcessingPipeline { get; set; } = Array.Empty<string>();
        public Dictionary<string, object> ValidationResults { get; set; } = new();
        public CnnStageInfo CnnStages { get; set; } = new();
        public SensorDataDto? SensorData { get; set; }
        public Dictionary<string, object> Metadata { get; set; } = new();
    }

    public class ItemDetectionDto
    {
        public string ItemId { get; set; } = string.Empty;
        public string Timestamp { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public SensorDataDto? SensorData { get; set; }
    }

    public class ItemRemovalDto
    {
        public string ItemId { get; set; } = string.Empty;
        public string Timestamp { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
    }

    public class ServiceHeartbeatDto
    {
        public string ServiceName { get; set; } = string.Empty;
        public string Timestamp { get; set; } = string.Empty;
        public string Status { get; set; } = string.Empty;
        public bool CameraConnected { get; set; }
        public bool ModelLoaded { get; set; }
        public bool ArduinoConnected { get; set; }
        public bool ExpertSystemAvailable { get; set; }
        public int ItemsInQueue { get; set; }
        public bool IsProcessing { get; set; }
    }
}


FILE: backend/Hubs/DashboardHub.cs
------------------------------------------------------------
Size: 9.7 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.AspNetCore.SignalR;
using SmartRecyclingBin.Services;
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Hubs
{
    public class DashboardHub : Hub
    {
        private readonly ILogger<DashboardHub> _logger;
        private readonly ISystemHealthService _healthService;
        private readonly IClassificationService _classificationService;

        public DashboardHub(
            ILogger<DashboardHub> logger, 
            ISystemHealthService healthService,
            IClassificationService classificationService)
        {
            _logger = logger;
            _healthService = healthService;
            _classificationService = classificationService;
        }

        /// <summary>
        /// Join dashboard group for targeted updates 
        /// </summary>
        public async Task JoinDashboardGroup()
        {
            var connectionId = Context.ConnectionId;
            
            await Groups.AddToGroupAsync(connectionId, "Dashboard");
            _logger.LogInformation("Client {ConnectionId} joined Dashboard group", connectionId);
            
            try
            {
                var healthMetrics = await _healthService.GetCurrentHealthAsync();
                var recentStats = await _classificationService.GetStatisticsAsync(DateTime.Today.AddDays(-1), DateTime.Now);
                
                var dashboardData = new
                {
                    Type = "initial_status",
                    Data = new
                    {
                        HealthMetrics = healthMetrics,
                        Stats = recentStats,
                        ConnectionId = connectionId,
                        ConnectedAt = DateTime.UtcNow
                    },
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Caller.SendAsync("DashboardUpdate", dashboardData);
                
                // Send welcome confirmation
                await Clients.Caller.SendAsync("JoinedDashboardGroup", new
                {
                    ConnectionId = connectionId,
                    Message = "Successfully joined dashboard group",
                    Timestamp = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending initial dashboard data to {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Failed to load initial dashboard data");
            }
        }

        /// <summary>
        /// Leave dashboard group
        /// </summary>
        public async Task LeaveDashboardGroup()
        {
            var connectionId = Context.ConnectionId;
            
            await Groups.RemoveFromGroupAsync(connectionId, "Dashboard");
            _logger.LogInformation("Client {ConnectionId} left Dashboard group", connectionId);
        }

        public async Task RequestSystemStatus()
        {
            var connectionId = Context.ConnectionId;
            
            try
            {
                var healthMetrics = await _healthService.GetCurrentHealthAsync();
                _logger.LogError($"LSTATS = {healthMetrics.CnnServiceHealthy.ToString()}");
                var statusUpdate = new
                {
                    Type = "status",
                    Data = healthMetrics,
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Caller.SendAsync("DashboardUpdate", statusUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting system status for {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Failed to get system status");
            }
        }

        public async Task RequestStats(DateTime? fromDate = null, DateTime? toDate = null)
        {
            var connectionId = Context.ConnectionId;
            
            try
            {
                var from = fromDate ?? DateTime.Today.AddDays(-7);
                var to = toDate ?? DateTime.Now;
                
                var stats = await _classificationService.GetStatisticsAsync(from, to);
                _logger.LogError("LSTATS");
                _logger.LogError(stats.ToString());
                
                var statsUpdate = new
                {
                    Type = "stats",
                    Data = stats,
                    Timestamp = DateTime.UtcNow,
                    DateRange = new { From = from, To = to }
                };
                
                await Clients.Caller.SendAsync("DashboardUpdate", statsUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting stats for {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Failed to get statistics");
            }
        }

        /// <summary>
        /// Get recent classifications 
        /// </summary>
        public async Task RequestRecentClassifications(int page = 1, int pageSize = 10, string? filterBy = null)
        {
            var connectionId = Context.ConnectionId;
            
            try
            {
                var recentClassifications = await _classificationService.GetRecentClassificationsAsync(page, pageSize, filterBy);
                
                var classificationsUpdate = new
                {
                    Type = "recent_classifications",
                    Data = recentClassifications,
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Caller.SendAsync("DashboardUpdate", classificationsUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting recent classifications for {ConnectionId}", connectionId);
                await Clients.Caller.SendAsync("Error", "Failed to get recent classifications");
            }
        }

        /// <summary>
        /// Broadcast system status update to all dashboard clients
        /// </summary>
        public async Task BroadcastSystemStatus(SystemHealthMetrics statusData)
        {
            try
            {
                var statusUpdate = new
                {
                    Type = "status",
                    Data = statusData,
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Group("Dashboard").SendAsync("DashboardUpdate", statusUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error broadcasting system status");
            }
        }

        /// <summary>
        /// Broadcast stats update to all dashboard clients
        /// </summary>
        public async Task BroadcastStatsUpdate(ClassificationStatistics statsData)
        {
            try
            {
                var statsUpdate = new
                {
                    Type = "stats",
                    Data = statsData,
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Group("Dashboard").SendAsync("DashboardUpdate", statsUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error broadcasting stats update");
            }
        }

        /// <summary>
        /// Send alert to dashboard clients 
        /// </summary>
        public async Task SendAlert(SystemAlert alert)
        {
            try
            {
                var alertUpdate = new
                {
                    Type = "alert",
                    Data = alert,
                    Timestamp = DateTime.UtcNow
                };
                
                await Clients.Group("Dashboard").SendAsync("DashboardUpdate", alertUpdate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending alert to dashboard");
            }
        }

        /// <summary>
        /// Send heartbeat to verify connection
        /// </summary>
        public async Task Heartbeat()
        {
            await Clients.Caller.SendAsync("HeartbeatResponse", new
            {
                Timestamp = DateTime.UtcNow,
                ConnectionId = Context.ConnectionId,
                Status = "Connected"
            });
        }

        // Connection event handlers
        public override async Task OnConnectedAsync()
        {
            var connectionId = Context.ConnectionId;
            var userIdentifier = Context.UserIdentifier ?? "Unknown";
            
            _logger.LogInformation("Client connected to DashboardHub: {ConnectionId} (User: {User})", 
                connectionId, userIdentifier);
                
            await Clients.Caller.SendAsync("Connected", new
            {
                ConnectionId = connectionId,
                Message = "Connected to DashboardHub",
                Timestamp = DateTime.UtcNow
            });
            
            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var connectionId = Context.ConnectionId;
            var userIdentifier = Context.UserIdentifier ?? "Unknown";
            
            if (exception != null)
            {
                _logger.LogError(exception, "Client disconnected from DashboardHub with error: {ConnectionId} (User: {User})", 
                    connectionId, userIdentifier);
            }
            else
            {
                _logger.LogInformation("Client disconnected from DashboardHub: {ConnectionId} (User: {User})", 
                    connectionId, userIdentifier);
            }
            
            await base.OnDisconnectedAsync(exception);
        }
    }
}


FILE: backend/Middleware/ErrorHandlingMiddleware.cs
------------------------------------------------------------
Size: 2.4 KB
Encoding: ascii
------------------------------------------------------------
using System.Net;
using System.Text.Json;
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Middleware
{
    public class ErrorHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<ErrorHandlingMiddleware> _logger;

        public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "An unhandled exception occurred");
                await HandleExceptionAsync(context, ex);
            }
        }

        private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
        {
            context.Response.ContentType = "application/json";
            
            var response = new ErrorResponse
            {
                Message = "An error occurred while processing your request.",
                Details = exception.Message
            };

            switch (exception)
            {
                case ArgumentException:
                    context.Response.StatusCode = (int)HttpStatusCode.BadRequest;
                    response.Message = "Invalid request parameters.";
                    break;
                    
                case UnauthorizedAccessException:
                    context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;
                    response.Message = "Unauthorized access.";
                    break;
                    
                case KeyNotFoundException:
                    context.Response.StatusCode = (int)HttpStatusCode.NotFound;
                    response.Message = "Resource not found.";
                    break;
                    
                default:
                    context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
                    break;
            }

            var jsonOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            var result = JsonSerializer.Serialize(response, jsonOptions);
            await context.Response.WriteAsync(result);
        }
    }
}


FILE: backend/Middleware/RequestLoggingMiddleware.cs
------------------------------------------------------------
Size: 1.4 KB
Encoding: ascii
------------------------------------------------------------
using Serilog;

namespace SmartRecyclingBin.Middleware
{
    public class RequestLoggingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly ILogger<RequestLoggingMiddleware> _logger;

        public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
        {
            _next = next;
            _logger = logger;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var start = DateTime.UtcNow;
            
            try
            {
                await _next(context);
            }
            finally
            {
                var elapsed = DateTime.UtcNow - start;
                var statusCode = context.Response?.StatusCode;
                var method = context.Request?.Method;
                var path = context.Request?.Path.Value;

                if (statusCode >= 400)
                {
                    _logger.LogWarning("HTTP {Method} {Path} responded {StatusCode} in {Elapsed:0.0000} ms",
                        method, path, statusCode, elapsed.TotalMilliseconds);
                }
                else
                {
                    _logger.LogInformation("HTTP {Method} {Path} responded {StatusCode} in {Elapsed:0.0000} ms",
                        method, path, statusCode, elapsed.TotalMilliseconds);
                }
            }
        }
    }
}


FILE: backend/Models/ApplicationSettings.cs
------------------------------------------------------------
Size: 1.5 KB
Encoding: ascii
------------------------------------------------------------
using System.ComponentModel.DataAnnotations;

namespace SmartRecyclingBin.Models
{
    public class ApplicationSettings
    {
        [Required]
        public string DatabasePath { get; set; } = "../data/smartbin.db";
        
        public PythonServicesSettings PythonServices { get; set; } = new();
        
        public ProcessingSettings Processing { get; set; } = new();
        
        public NotificationSettings Notifications { get; set; } = new();
    }

    public class PythonServicesSettings
    {
        [Required]
        [Url]
        public string CnnServiceUrl { get; set; } = "http://localhost:8001";
        
        [Required]
        [Url]
        public string ArduinoServiceUrl { get; set; } = "http://localhost:8002";
        
        [Range(1, 60)]
        public int HealthCheckIntervalSeconds { get; set; } = 30;
        
        [Range(1, 30)]
        public int TimeoutSeconds { get; set; } = 10;
    }

    public class ProcessingSettings
    {
        [Range(0.1, 1.0)]
        public double ConfidenceThreshold { get; set; } = 0.85;
        
        [Range(100, 5000)]
        public int MaxProcessingTimeMs { get; set; } = 2000;
        
        [Range(1, 100)]
        public int MaxConcurrentClassifications { get; set; } = 10;
    }

    public class NotificationSettings
    {
        public bool EnableRealTimeUpdates { get; set; } = true;
        
        public bool EnableEmailAlerts { get; set; } = false;
        
        public string? SmtpServer { get; set; }
        
        public string? AlertEmailAddress { get; set; }
    }
}


FILE: backend/Models/ClassificationModels.cs
------------------------------------------------------------
Size: 5.3 KB
Encoding: ascii
------------------------------------------------------------
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace SmartRecyclingBin.Models
{
    public class ClassificationResult
    {
        public int Id { get; set; }
        
        [Required]
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        
        // CNN Prediction Data
        [Required]
        [MaxLength(100)]
        public string CnnPredictedClass { get; set; } = string.Empty;
        
        [Range(0.0, 1.0)]
        public double CnnConfidence { get; set; }
        
        public int CnnStage { get; set; }
        
        [Range(0, double.MaxValue)]
        public double ProcessingTimeMs { get; set; }
        
        // Sensor Data
        [Range(0, double.MaxValue)]
        public double WeightGrams { get; set; }
        
        public bool IsMetalDetected { get; set; }
        
        [Range(0, 100)]
        public double HumidityPercent { get; set; }
        
        public double TemperatureCelsius { get; set; }
        
        public bool IsMoist { get; set; }
        public bool IsTransparent { get; set; }
        public bool IsFlexible { get; set; }
        
        // Expert System Results
        [Required]
        [MaxLength(100)]
        public string FinalClassification { get; set; } = string.Empty;
        
        [Range(0.0, 1.0)]
        public double FinalConfidence { get; set; }
        
        [Required]
        [MaxLength(200)]
        public string DisposalLocation { get; set; } = string.Empty;
        
        [MaxLength(500)]
        public string Reasoning { get; set; } = string.Empty;
        
        public int CandidatesCount { get; set; }
        
        // Override Information
        public bool IsOverridden { get; set; }
        [MaxLength(500)]
        public string? OverrideReason { get; set; }
        [MaxLength(100)]
        public string? OverriddenBy { get; set; }
        [MaxLength(100)]
        public string? OverrideClassification { get; set; }
        public DateTime? OverrideTimestamp { get; set; }
    }

    public class SystemHealthMetrics
    {
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public bool CameraConnected { get; set; }
        public bool ArduinoConnected { get; set; }
        public bool CnnServiceHealthy { get; set; }
        public bool ExpertSystemHealthy { get; set; }
        public double AvgProcessingTimeMs { get; set; }
        public int TotalItemsProcessed { get; set; }
        public double AccuracyRate { get; set; }
        public Dictionary<string, int> ClassificationCounts { get; set; } = new();
        public double SystemUptime { get; set; }
        public double MemoryUsageMB { get; set; }
        public double CpuUsagePercent { get; set; }
    }

    public class ManualOverrideRequest
    {
        [Required]
        public int ClassificationId { get; set; }
        
        [Required]
        [MaxLength(100)]
        public string NewClassification { get; set; } = string.Empty;
        
        [Required]
        [MaxLength(200)]
        public string NewDisposalLocation { get; set; } = string.Empty;
        
        [Required]
        [MaxLength(500)]
        public string Reason { get; set; } = string.Empty;
        
        [Required]
        [MaxLength(100)]
        public string UserId { get; set; } = string.Empty;
    }

    public class ClassificationRequest
    {
        [Required]
        public string ImageData { get; set; } = string.Empty; // Base64 encoded
        
        [Required]
        public SensorData Sensors { get; set; } = new();
        
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    }

    public class SensorData
    {
        public double WeightGrams { get; set; }
        public bool IsMetalDetected { get; set; }
        public double HumidityPercent { get; set; }
        public double TemperatureCelsius { get; set; }
        public bool IsMoist { get; set; }
        public bool IsTransparent { get; set; }
        public bool IsFlexible { get; set; }
        public double IrTransparency { get; set; }
    }

    public class ClassificationStatistics
    {
        public int TotalItems { get; set; }
        public double AccuracyRate { get; set; }
        public double AvgProcessingTime { get; set; }
        public Dictionary<string, int> ClassificationBreakdown { get; set; } = new();
        public double OverrideRate { get; set; }
        public int ItemsToday { get; set; }
        public int ItemsThisWeek { get; set; }
        public int ItemsThisMonth { get; set; }
        public DateTime LastClassification { get; set; }
        public List<HourlyStats> HourlyBreakdown { get; set; } = new();
    }

    public class HourlyStats
    {
        public DateTime Hour { get; set; }
        public int Count { get; set; }
        public double AvgAccuracy { get; set; }
    }

    public class SystemAlert
    {
        public int Id { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string Severity { get; set; } = string.Empty; // INFO, WARNING, ERROR, CRITICAL
        public string Component { get; set; } = string.Empty;
        public string Message { get; set; } = string.Empty;
        public bool IsResolved { get; set; }
        public DateTime? ResolvedTimestamp { get; set; }
        public string? ResolvedBy { get; set; }
    }
}



FILE: backend/Models/ClassificationSearchCriteria.cs
------------------------------------------------------------
Size: 397 B
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models;

public class ClassificationSearchCriteria
{
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public string? Classification { get; set; }
    public double? MinConfidence { get; set; }
    public double? MaxConfidence { get; set; }
    public bool? IsOverridden { get; set; }
    public int? Limit { get; set; } = 100;
}


FILE: backend/Models/CnnStageInfo.cs
------------------------------------------------------------
Size: 264 B
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Models.DTOs;

namespace SmartRecyclingBin.Models;

public class CnnStageInfo
{
    public CnnPredictionDto? Stage1Result { get; set; }
    public CnnPredictionDto? Stage2Result { get; set; }
    public double TotalConfidence { get; set; }
}


FILE: backend/Models/DTOs/ClassificationRequestDto.cs
------------------------------------------------------------
Size: 2.0 KB
Encoding: ascii
------------------------------------------------------------
// Models/DTOs/ClassificationRequestDto.cs
using System.ComponentModel.DataAnnotations;

namespace SmartRecyclingBin.Models.DTOs
{
    public class ClassificationRequestDto
    {
        public CnnPredictionDto? CnnPrediction { get; set; }
        public SensorDataDto? SensorData { get; set; }
        public ExpertSystemResultDto? ExpertSystemResult { get; set; }
        public DateTime? Timestamp { get; set; } = DateTime.UtcNow;
    }

    public class CnnPredictionDto
    {
        [Required]
        public string PredictedClass { get; set; } = string.Empty;
        
        [Range(0.0, 1.0)]
        public double Confidence { get; set; }
        
        [Range(1, 5)]
        public int Stage { get; set; } = 1;
        
        [Range(0, double.MaxValue)]
        public double ProcessingTimeMs { get; set; }
        
        public Dictionary<string, double>? ClassProbabilities { get; set; }
    }

    public class SensorDataDto
    {
        [Range(0, 10000)]
        public double WeightGrams { get; set; }
        
        public bool IsMetalDetected { get; set; }
        
        [Range(0, 100)]
        public double HumidityPercent { get; set; }
        
        [Range(-40, 80)]
        public double TemperatureCelsius { get; set; } = 20.0;
        
        public bool IsMoist { get; set; }
        public bool IsTransparent { get; set; }
        public bool IsFlexible { get; set; }
        
        [Range(0, 1)]
        public double? IrTransparency { get; set; }
    }

    public class ExpertSystemResultDto
    {
        [Required]
        public string FinalClassification { get; set; } = string.Empty;
        
        [Range(0.0, 1.0)]
        public double Confidence { get; set; }
        
        [Required]
        public string DisposalLocation { get; set; } = string.Empty;
        
        public string Reasoning { get; set; } = string.Empty;
        
        [Range(0, 100)]
        public int CandidatesCount { get; set; }
        
        public List<string>? CandidateClasses { get; set; }
    }
}



FILE: backend/Models/DTOs/ClassificationResponseDto.cs
------------------------------------------------------------
Size: 755 B
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models.DTOs;

public class ClassificationResponseDto
{
    public int Id { get; set; }
    public DateTime Timestamp { get; set; }
    public string FinalClassification { get; set; } = string.Empty;
    public double FinalConfidence { get; set; }
    public string DisposalLocation { get; set; } = string.Empty;
    public string Reasoning { get; set; } = string.Empty;
    public bool IsOverridden { get; set; }
    public double ProcessingTimeMs { get; set; }
        
    // CNN Information
    public CnnPredictionDto? CnnPrediction { get; set; }
        
    // Sensor Information  
    public SensorDataDto? SensorData { get; set; }
        
    // Metadata
    public Dictionary<string, object>? Metadata { get; set; }
}


FILE: backend/Models/DTOs/DashboardStatsDto.cs
------------------------------------------------------------
Size: 1.9 KB
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models.DTOs
{
    public class DashboardStatsDto
    {
        public SystemStatusDto SystemStatus { get; set; } = new();
        public ProcessingStatsDto ProcessingStats { get; set; } = new();
        public List<RecentActivityDto> RecentActivity { get; set; } = new();
        public AlertSummaryDto Alerts { get; set; } = new();
    }

    public class SystemStatusDto
    {
        public bool CameraConnected { get; set; }
        public bool ArduinoConnected { get; set; }
        public bool CnnServiceHealthy { get; set; }
        public bool ExpertSystemHealthy { get; set; }
        public DateTime LastHealthCheck { get; set; }
        public string OverallStatus => GetOverallStatus();
        
        private string GetOverallStatus()
        {
            if (!CameraConnected || !ArduinoConnected || !CnnServiceHealthy || !ExpertSystemHealthy)
                return "Warning";
            return "Healthy";
        }
    }

    public class ProcessingStatsDto
    {
        public int TotalItemsToday { get; set; }
        public double AverageAccuracy { get; set; }
        public double AverageProcessingTime { get; set; }
        public double OverrideRate { get; set; }
        public Dictionary<string, int> ClassificationBreakdown { get; set; } = new();
    }

    public class RecentActivityDto
    {
        public DateTime Timestamp { get; set; }
        public string Classification { get; set; } = string.Empty;
        public string DisposalLocation { get; set; } = string.Empty;
        public double Confidence { get; set; }
        public bool IsOverridden { get; set; }
    }

    public class AlertSummaryDto
    {
        public int TotalActiveAlerts { get; set; }
        public int CriticalAlerts { get; set; }
        public int WarningAlerts { get; set; }
        public int InfoAlerts { get; set; }
        public List<SystemAlert> RecentAlerts { get; set; } = new();
    }
}




FILE: backend/Models/ErrorResponse.cs
------------------------------------------------------------
Size: 298 B
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models
{
    public class ErrorResponse
    {
        public string Message { get; set; } = string.Empty;
        public string? Details { get; set; }
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        public string? TraceId { get; set; }
    }
}


FILE: backend/Models/PagedResult.cs
------------------------------------------------------------
Size: 407 B
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models
{
    public class PagedResult<T>
    {
        public List<T> Items { get; set; } = new();
        public int TotalCount { get; set; }
        public int Page { get; set; }
        public int PageSize { get; set; }
        public int TotalPages { get; set; }
        public bool HasPreviousPage => Page > 1;
        public bool HasNextPage => Page < TotalPages;
    }
}




FILE: backend/Models/ValidationResult.cs
------------------------------------------------------------
Size: 489 B
Encoding: ascii
------------------------------------------------------------
namespace SmartRecyclingBin.Models
{
    public class ValidationResult
    {
        public bool IsValid { get; set; }
        public List<string> Errors { get; set; } = new();
        public List<string> Warnings { get; set; } = new();
        
        public void AddError(string error)
        {
            IsValid = false;
            Errors.Add(error);
        }
        
        public void AddWarning(string warning)
        {
            Warnings.Add(warning);
        }
    }
}




FILE: backend/Program.cs
------------------------------------------------------------
Size: 6.9 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using SmartRecyclingBin.Data;
using SmartRecyclingBin.Hubs;
using SmartRecyclingBin.Services;
using System.Text.Json;
using Serilog;
using SmartRecyclingBin.Middleware;
using SmartRecyclingBin.Models;

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog for better logging
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .WriteTo.File("logs/smart-recycling-bin-.txt", rollingInterval: RollingInterval.Day)
    .CreateLogger();

builder.Host.UseSerilog();

// Add services to the container
builder.Services.AddDbContext<ApplicationDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")
                           ?? "Data Source=../data/smartbin.db";
    options.UseSqlite(connectionString);

    // Enable sensitive data logging in development
    if (builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging();
        options.EnableDetailedErrors();
    }
});

// Configure JSON serialization
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
        options.JsonSerializerOptions.WriteIndented = true;
        options.JsonSerializerOptions.DefaultIgnoreCondition =
            System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;
    });

// Configure SignalR with better options
builder.Services.AddSignalR(options =>
    {
        options.EnableDetailedErrors = builder.Environment.IsDevelopment();
        options.KeepAliveInterval = TimeSpan.FromSeconds(15);
        options.ClientTimeoutInterval = TimeSpan.FromSeconds(30);
    })
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
    });

// Add API documentation
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new()
    {
        Title = "Smart Recycling Bin API",
        Version = "v1",
        Description = "API for Smart Recycling Bin system with real-time classification and monitoring",
        Contact = new() { Name = "Smart Recycling Bin Team" }
    });

    // Add SignalR hubs to documentation
    c.EnableAnnotations();
});

// Configure CORS with more specific settings
// builder.Services.AddCors(options =>
// {
//     var allowedOrigins = builder.Configuration.GetSection("AllowedOrigins").Get<string[]>() ??
//     [
//         "http://localhost:3000", "http://localhost:3001", "http://localhost:5173", "https://localhost:3000"
//     ];
// 
//     options.AddDefaultPolicy(policy =>
//     {
//         policy.WithOrigins(allowedOrigins)
//             .AllowAnyHeader()
//             .AllowAnyMethod()
//             .AllowCredentials();
//     });
// });

builder.Services.AddCors(options => options.AddPolicy("CorsPolicy",
    builder =>
    {
        builder.AllowAnyHeader()
            .AllowAnyMethod()
            .SetIsOriginAllowed((host) => true)
            .AllowCredentials();
    }));


// Register custom services with proper DI scoping
builder.Services.AddScoped<IClassificationService, ClassificationService>();
builder.Services.AddScoped<IOverrideService, OverrideService>();
builder.Services.AddScoped<ISystemHealthService, SystemHealthService>();
builder.Services.AddSingleton<INotificationService, NotificationService>();

// Add HTTP client for external service calls
builder.Services.AddHttpClient("PythonServices", client => { client.Timeout = TimeSpan.FromSeconds(10); });

// Add health checks
builder.Services.AddHealthChecks()
    // .AddDbContext<ApplicationDbContext>()
    .AddCheck<SystemHealthCheck>("system-health");

// Add memory cache for performance
builder.Services.AddMemoryCache();

// Add configuration validation
builder.Services.AddOptions<ApplicationSettings>()
    .Bind(builder.Configuration.GetSection("ApplicationSettings"))
    .ValidateDataAnnotations()
    .ValidateOnStart();

// Add logging with more detailed configuration
builder.Services.AddLogging(logging =>
{
    logging.ClearProviders();
    logging.AddSerilog();
    logging.SetMinimumLevel(LogLevel.Information);
});

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Smart Recycling Bin API V1");
        c.RoutePrefix = "swagger";
        c.EnableDeepLinking();
        c.DisplayRequestDuration();
    });
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/error");
    app.UseHsts();
}

// Add custom middleware
app.UseMiddleware<RequestLoggingMiddleware>();
app.UseMiddleware<ErrorHandlingMiddleware>();

// Standard pipeline
app.UseHttpsRedirection();
app.UseRouting();

// Use the appropriate CORS policy
app.UseCors("CorsPolicy");

app.UseAuthentication();
app.UseAuthorization();

// Map controllers and hubs
app.MapControllers();
app.MapHub<ClassificationHub>("/hubs/classification");
app.MapHub<DashboardHub>("/hubs/dashboard");

// Map health checks
app.MapHealthChecks("/health");
app.MapHealthChecks("/health/ready", new()
{
    Predicate = check => check.Tags.Contains("ready")
});
app.MapHealthChecks("/health/live", new()
{
    Predicate = _ => false
});

// Enhanced health check endpoint with detailed information
app.MapGet("/api/health/detailed", async (ISystemHealthService healthService) =>
{
    try
    {
        var health = await healthService.GetCurrentHealthAsync();
        return Results.Ok(new
        {
            status = "healthy",
            timestamp = DateTime.UtcNow,
            service = "Smart Recycling Bin Backend",
            version = "1.0.0",
            environment = app.Environment.EnvironmentName,
            metrics = health
        });
    }
    catch (Exception ex)
    {
        Log.Error(ex, "Health check failed");
        return Results.Problem("Health check failed");
    }
});

// Ensure database is created and seeded
using (var scope = app.Services.CreateScope())
{
    try
    {
        var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<Program>>();

        await context.Database.EnsureCreatedAsync();

        // Seed initial data if needed
        if (!await context.ClassificationResults.AnyAsync())
        {
            // SeedInitialData(context); // This function was empty, ensure it's implemented if needed
        }

        logger.LogInformation("Database initialized successfully");
    }
    catch (Exception ex)
    {
        Log.Fatal(ex, "Database initialization failed");
        throw;
    }
}

Log.Information("Smart Recycling Bin Backend starting up...");

try
{
    app.Run();
}
catch (Exception ex)
{
    Log.Fatal(ex, "Application terminated unexpectedly");
}
finally
{
    Log.CloseAndFlush();
}


FILE: backend/Properties/launchSettings.json
------------------------------------------------------------
Size: 1.1 KB
Encoding: UTF-8-SIG
------------------------------------------------------------
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:12349",
      "sslPort": 44386
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5099",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7234;http://localhost:5099",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}



FILE: backend/Services/ClassificationService.cs
------------------------------------------------------------
Size: 17.6 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using SmartRecyclingBin.Data;
using SmartRecyclingBin.Models;
using SmartRecyclingBin.Models.DTOs;
using System.Text.Json;

namespace SmartRecyclingBin.Services
{
    public class ClassificationService : IClassificationService
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<ClassificationService> _logger;
        private readonly IMemoryCache _cache;
        private readonly INotificationService _notificationService;
        private readonly TimeSpan _cacheExpiry = TimeSpan.FromMinutes(5);

        public ClassificationService(
            ApplicationDbContext context, 
            ILogger<ClassificationService> logger,
            IMemoryCache cache,
            INotificationService notificationService)
        {
            _context = context;
            _logger = logger;
            _cache = cache;
            _notificationService = notificationService;
        }

        public async Task<ClassificationResult> ProcessClassificationResultAsync(ClassificationRequestDto request)
        {
            ArgumentNullException.ThrowIfNull(request);

            var validation = await ValidateClassificationDataAsync(request);
            if (!validation.IsValid)
            {
                throw new ArgumentException($"Invalid classification data: {string.Join(", ", validation.Errors)}");
            }

            try
            {
                var result = new ClassificationResult
                {
                    Timestamp = DateTime.UtcNow,
                    
                    // CNN Prediction data
                    CnnPredictedClass = request.CnnPrediction?.PredictedClass ?? "",
                    CnnConfidence = request.CnnPrediction?.Confidence ?? 0.0,
                    CnnStage = request.CnnPrediction?.Stage ?? 1,
                    ProcessingTimeMs = request.CnnPrediction?.ProcessingTimeMs ?? 0.0,
                    
                    // Sensor data
                    WeightGrams = request.SensorData?.WeightGrams ?? 0.0,
                    IsMetalDetected = request.SensorData?.IsMetalDetected ?? false,
                    HumidityPercent = request.SensorData?.HumidityPercent ?? 0.0,
                    TemperatureCelsius = request.SensorData?.TemperatureCelsius ?? 20.0,
                    IsMoist = request.SensorData?.IsMoist ?? false,
                    IsTransparent = request.SensorData?.IsTransparent ?? false,
                    IsFlexible = request.SensorData?.IsFlexible ?? false,
                    
                    // Expert system results
                    FinalClassification = request.ExpertSystemResult?.FinalClassification ?? "",
                    FinalConfidence = request.ExpertSystemResult?.Confidence ?? 0.0,
                    DisposalLocation = request.ExpertSystemResult?.DisposalLocation ?? "",
                    Reasoning = request.ExpertSystemResult?.Reasoning ?? "",
                    CandidatesCount = request.ExpertSystemResult?.CandidatesCount ?? 0
                };

                _context.ClassificationResults.Add(result);
                await _context.SaveChangesAsync();

                // Clear cache to ensure fresh data
                _cache.Remove("recent_classifications");
                _cache.Remove($"statistics_{DateTime.Today:yyyy-MM-dd}");

                // Send notification for low confidence classifications
                if (result.FinalConfidence < 0.7)
                {
                    await _notificationService.AddAlert(new SystemAlert
                    {
                        Severity = "WARNING",
                        Component = "Classification",
                        Message = $"Low confidence classification: {result.FinalClassification} ({result.FinalConfidence:P1})"
                    });
                }

                _logger.LogInformation("Processed classification result: ID {Id}, Classification: {Classification}, Confidence: {Confidence:F2}", 
                    result.Id, result.FinalClassification, result.FinalConfidence);

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing classification result");
                await _notificationService.AddAlert(new SystemAlert
                {
                    Severity = "ERROR",
                    Component = "Classification",
                    Message = $"Failed to process classification: {ex.Message}"
                });
                throw;
            }
        }

        public async Task<ClassificationResult> ProcessClassificationResultAsync(JsonElement pythonResult)
        {
            try
            {
                var request = MapJsonToDto(pythonResult);
                return await ProcessClassificationResultAsync(request);
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Error parsing JSON classification result");
                throw new ArgumentException("Invalid JSON format for classification result", ex);
            }
        }

        public async Task<PagedResult<ClassificationResult>> GetRecentClassificationsAsync(int page = 1, int pageSize = 50, string? filterBy = null)
        {
            if (page < 1) page = 1;
            if (pageSize < 1 || pageSize > 100) pageSize = 50;

            try
            {
                var cacheKey = $"recent_classifications_p{page}_s{pageSize}_f{filterBy}";
                
                if (_cache.TryGetValue(cacheKey, out PagedResult<ClassificationResult>? cached) && cached != null)
                {
                    return cached;
                }

                var query = _context.ClassificationResults.AsQueryable();

                if (!string.IsNullOrEmpty(filterBy))
                {
                    query = query.Where(c => c.FinalClassification.Contains(filterBy) || 
                                           c.CnnPredictedClass.Contains(filterBy));
                }

                var totalCount = await query.CountAsync();
                var results = await query
                    .OrderByDescending(c => c.Timestamp)
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .ToListAsync();

                var pagedResult = new PagedResult<ClassificationResult>
                {
                    Items = results,
                    TotalCount = totalCount,
                    Page = page,
                    PageSize = pageSize,
                    TotalPages = (int)Math.Ceiling((double)totalCount / pageSize)
                };

                _cache.Set(cacheKey, pagedResult, _cacheExpiry);
                return pagedResult;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving recent classifications");
                throw;
            }
        }

        public async Task<ClassificationStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null)
        {
            try
            {
                fromDate ??= DateTime.UtcNow.AddDays(-7);
                toDate ??= DateTime.UtcNow;

                var cacheKey = $"statistics_{fromDate:yyyy-MM-dd}_{toDate:yyyy-MM-dd}";
                
                if (_cache.TryGetValue(cacheKey, out ClassificationStatistics? cached) && cached != null)
                {
                    return cached;
                }

                var results = await _context.ClassificationResults
                    .Where(c => c.Timestamp >= fromDate && c.Timestamp <= toDate)
                    .ToListAsync();

                var stats = new ClassificationStatistics
                {
                    TotalItems = results.Count,
                    AccuracyRate = results.Count > 0 ? results.Average(r => r.FinalConfidence) : 0,
                    AvgProcessingTime = results.Count > 0 ? results.Average(r => r.ProcessingTimeMs) : 0,
                    ClassificationBreakdown = results
                        .GroupBy(r => r.FinalClassification)
                        .ToDictionary(g => g.Key, g => g.Count()),
                    OverrideRate = results.Count > 0 ? 
                        (double)results.Count(r => r.IsOverridden) / results.Count * 100 : 0,
                    ItemsToday = results.Count(r => r.Timestamp.Date == DateTime.Today),
                    ItemsThisWeek = results.Count(r => r.Timestamp >= DateTime.Today.AddDays(-7)),
                    ItemsThisMonth = results.Count(r => r.Timestamp >= DateTime.Today.AddMonths(-1)),
                    LastClassification = results.OrderByDescending(r => r.Timestamp).FirstOrDefault()?.Timestamp ?? DateTime.MinValue,
                    HourlyBreakdown = GenerateHourlyBreakdown(results, fromDate.Value, toDate.Value)
                };

                _cache.Set(cacheKey, stats, _cacheExpiry);
                return stats;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating classification statistics");
                throw;
            }
        }

        public async Task<ClassificationResult?> GetClassificationAsync(int id)
        {
            try
            {
                return await _context.ClassificationResults.FindAsync(id);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving classification with ID {Id}", id);
                throw;
            }
        }

        public async Task<bool> DeleteClassificationAsync(int id)
        {
            try
            {
                var classification = await _context.ClassificationResults.FindAsync(id);
                if (classification == null) 
                    return false;

                _context.ClassificationResults.Remove(classification);
                await _context.SaveChangesAsync();

                // Clear relevant caches
                _cache.Remove("recent_classifications");
                
                _logger.LogInformation("Deleted classification with ID {Id}", id);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting classification with ID {Id}", id);
                throw;
            }
        }

        public async Task<ValidationResult> ValidateClassificationDataAsync(ClassificationRequestDto request)
        {
            var result = new ValidationResult { IsValid = true };

            if (request == null)
            {
                result.IsValid = false;
                result.Errors.Add("Classification request cannot be null");
                return result;
            }

            // Validate CNN prediction
            if (request.CnnPrediction != null)
            {
                if (request.CnnPrediction.Confidence is < 0 or > 1)
                {
                    result.IsValid = false;
                    result.Errors.Add("CNN confidence must be between 0 and 1");
                }

                if (string.IsNullOrEmpty(request.CnnPrediction.PredictedClass))
                {
                    result.IsValid = false;
                    result.Errors.Add("CNN predicted class cannot be empty");
                }
            }

            // Validate sensor data ranges
            if (request.SensorData != null)
            {
                if (request.SensorData.WeightGrams is < 0 or > 10000) // 10kg max
                {
                    result.IsValid = false;
                    result.Errors.Add("Weight must be between 0 and 10000 grams");
                }

                if (request.SensorData.HumidityPercent is < 0 or > 100)
                {
                    result.IsValid = false;
                    result.Errors.Add("Humidity must be between 0 and 100 percent");
                }

                if (request.SensorData.TemperatureCelsius is < -40 or > 80)
                {
                    result.IsValid = false;
                    result.Errors.Add("Temperature must be between -40 and 80 degrees Celsius");
                }
            }

            // Validate expert system result
            if (request.ExpertSystemResult != null)
            {
                if (request.ExpertSystemResult.Confidence < 0 || request.ExpertSystemResult.Confidence > 1)
                {
                    result.IsValid = false;
                    result.Errors.Add("Expert system confidence must be between 0 and 1");
                }
            }

            return await Task.FromResult(result);
        }

        public async Task<List<ClassificationResult>> SearchClassificationsAsync(ClassificationSearchCriteria criteria)
        {
            try
            {
                var query = _context.ClassificationResults.AsQueryable();

                if (criteria.FromDate.HasValue)
                    query = query.Where(c => c.Timestamp >= criteria.FromDate.Value);

                if (criteria.ToDate.HasValue)
                    query = query.Where(c => c.Timestamp <= criteria.ToDate.Value);

                if (!string.IsNullOrEmpty(criteria.Classification))
                    query = query.Where(c => c.FinalClassification.Contains(criteria.Classification));

                if (criteria.MinConfidence.HasValue)
                    query = query.Where(c => c.FinalConfidence >= criteria.MinConfidence.Value);

                if (criteria.MaxConfidence.HasValue)
                    query = query.Where(c => c.FinalConfidence <= criteria.MaxConfidence.Value);

                if (criteria.IsOverridden.HasValue)
                    query = query.Where(c => c.IsOverridden == criteria.IsOverridden.Value);

                return await query
                    .OrderByDescending(c => c.Timestamp)
                    .Take(criteria.Limit ?? 100)
                    .ToListAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error searching classifications");
                throw;
            }
        }

        private ClassificationRequestDto MapJsonToDto(JsonElement pythonResult)
        {
            var request = new ClassificationRequestDto();

            // Map CNN prediction
            if (pythonResult.TryGetProperty("cnn_prediction", out var cnnPrediction))
            {
                request.CnnPrediction = new CnnPredictionDto
                {
                    PredictedClass = GetStringProperty(cnnPrediction, "predicted_class"),
                    Confidence = GetDoubleProperty(cnnPrediction, "confidence"),
                    Stage = GetIntProperty(cnnPrediction, "stage"),
                    ProcessingTimeMs = GetDoubleProperty(cnnPrediction, "processing_time_ms")
                };
            }

            // Map sensor data
            if (pythonResult.TryGetProperty("sensor_data", out var sensorData))
            {
                request.SensorData = new SensorDataDto
                {
                    WeightGrams = GetDoubleProperty(sensorData, "weight_grams"),
                    IsMetalDetected = GetBoolProperty(sensorData, "is_metal"),
                    HumidityPercent = GetDoubleProperty(sensorData, "humidity_percent"),
                    TemperatureCelsius = GetDoubleProperty(sensorData, "temperature_celsius"),
                    IsMoist = GetBoolProperty(sensorData, "is_moist"),
                    IsTransparent = GetBoolProperty(sensorData, "is_transparent"),
                    IsFlexible = GetBoolProperty(sensorData, "is_flexible")
                };
            }

            // Map expert system result
            if (pythonResult.TryGetProperty("expert_system_result", out var expertResult))
            {
                request.ExpertSystemResult = new ExpertSystemResultDto
                {
                    FinalClassification = GetStringProperty(expertResult, "final_classification"),
                    Confidence = GetDoubleProperty(expertResult, "confidence"),
                    DisposalLocation = GetStringProperty(expertResult, "disposal_location"),
                    Reasoning = GetStringProperty(expertResult, "reasoning"),
                    CandidatesCount = GetIntProperty(expertResult, "candidates_count")
                };
            }

            return request;
        }

        private List<HourlyStats> GenerateHourlyBreakdown(List<ClassificationResult> results, DateTime fromDate, DateTime toDate)
        {
            var hours = new List<HourlyStats>();
            
            for (var hour = fromDate.Date; hour <= toDate; hour = hour.AddHours(1))
            {
                var hourResults = results.Where(r => r.Timestamp >= hour && r.Timestamp < hour.AddHours(1)).ToList();
                
                hours.Add(new HourlyStats
                {
                    Hour = hour,
                    Count = hourResults.Count,
                    AvgAccuracy = hourResults.Count > 0 ? hourResults.Average(r => r.FinalConfidence) : 0
                });
            }

            return hours.Where(h => h.Count > 0).ToList();
        }

        // Helper methods for safe property extraction
        private string GetStringProperty(JsonElement element, string propertyName) =>
            element.TryGetProperty(propertyName, out var prop) ? prop.GetString() ?? "" : "";

        private double GetDoubleProperty(JsonElement element, string propertyName) =>
            element.TryGetProperty(propertyName, out var prop) ? prop.GetDouble() : 0.0;

        private bool GetBoolProperty(JsonElement element, string propertyName) =>
            element.TryGetProperty(propertyName, out var prop) && prop.GetBoolean();

        private int GetIntProperty(JsonElement element, string propertyName) =>
            element.TryGetProperty(propertyName, out var prop) ? prop.GetInt32() : 0;
    }
}


FILE: backend/Services/IClassificationService.cs
------------------------------------------------------------
Size: 964 B
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Models;
using SmartRecyclingBin.Models.DTOs;
using System.Text.Json;

namespace SmartRecyclingBin.Services
{
    public interface IClassificationService
    {
        Task<ClassificationResult> ProcessClassificationResultAsync(ClassificationRequestDto request);
        Task<ClassificationResult> ProcessClassificationResultAsync(JsonElement pythonResult);
        Task<PagedResult<ClassificationResult>> GetRecentClassificationsAsync(int page = 1, int pageSize = 50, string? filterBy = null);
        Task<ClassificationStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null);
        Task<ClassificationResult?> GetClassificationAsync(int id);
        Task<bool> DeleteClassificationAsync(int id);
        Task<ValidationResult> ValidateClassificationDataAsync(ClassificationRequestDto request);
        Task<List<ClassificationResult>> SearchClassificationsAsync(ClassificationSearchCriteria criteria);
    }
}


FILE: backend/Services/INotificationService.cs
------------------------------------------------------------
Size: 293 B
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Services
{
    public interface INotificationService
    {
        Task AddAlert(SystemAlert alert);
        Task<List<SystemAlert>> GetRecentAlerts(int count = 20);
        Task ResolveAlert(int alertId, string resolvedBy);
    }
}


FILE: backend/Services/IOverrideService.cs
------------------------------------------------------------
Size: 353 B
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Services
{
    public interface IOverrideService
    {
        Task<bool> ApplyManualOverrideAsync(ManualOverrideRequest request);
        Task<List<ClassificationResult>> GetOverriddenClassificationsAsync(int count = 50);
        Task<double> GetOverrideRateAsync(DateTime fromDate);
    }
}


FILE: backend/Services/ISystemHealthService.cs
------------------------------------------------------------
Size: 370 B
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Services
{
    public interface ISystemHealthService
    {
        Task<SystemHealthMetrics> GetCurrentHealthAsync();
        Task<bool> CheckServiceHealthAsync(string serviceUrl);
        Task LogHealthMetricsAsync(SystemHealthMetrics metrics);
        Task<List<SystemAlert>> GetActiveAlertsAsync();
    }
}


FILE: backend/Services/NotificationService.cs
------------------------------------------------------------
Size: 2.7 KB
Encoding: ascii
------------------------------------------------------------
using SmartRecyclingBin.Data;
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Services
{
    public class NotificationService : INotificationService
    {
        private readonly IServiceScopeFactory _serviceScopeFactory;
        private readonly ILogger<NotificationService> _logger;
        private readonly List<SystemAlert> _recentAlerts = new();

        // Use IServiceScopeFactory instead of direct ApplicationDbContext
        public NotificationService(IServiceScopeFactory serviceScopeFactory, ILogger<NotificationService> logger)
        {
            _serviceScopeFactory = serviceScopeFactory;
            _logger = logger;
        }

        public async Task AddAlert(SystemAlert alert)
        {
            try
            {
                // Create a scope to get a scoped ApplicationDbContext
                using var scope = _serviceScopeFactory.CreateScope();
                var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

                context.SystemAlerts.Add(alert);
                await context.SaveChangesAsync();

                _recentAlerts.Add(alert);
                
                // Keep only recent 50 alerts in memory
                while (_recentAlerts.Count > 50)
                {
                    _recentAlerts.RemoveAt(0);
                }

                _logger.LogInformation($"Added system alert: {alert.Severity} - {alert.Message}");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error adding system alert");
            }
        }

        public Task<List<SystemAlert>> GetRecentAlerts(int count = 20)
        {
            return Task.FromResult(_recentAlerts.TakeLast(count).ToList());
        }

        public async Task ResolveAlert(int alertId, string resolvedBy)
        {
            try
            {
                // Create a scope to get a scoped ApplicationDbContext
                using var scope = _serviceScopeFactory.CreateScope();
                var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();

                var alert = await context.SystemAlerts.FindAsync(alertId);
                if (alert != null)
                {
                    alert.IsResolved = true;
                    alert.ResolvedTimestamp = DateTime.UtcNow;
                    alert.ResolvedBy = resolvedBy;
                    
                    await context.SaveChangesAsync();
                    _logger.LogInformation($"Resolved alert {alertId} by {resolvedBy}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error resolving alert {alertId}");
            }
        }
    }
}


FILE: backend/Services/OverrideService.cs
------------------------------------------------------------
Size: 4.3 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.AspNetCore.SignalR;
using Microsoft.EntityFrameworkCore;
using SmartRecyclingBin.Data;
using SmartRecyclingBin.Hubs;
using SmartRecyclingBin.Models;

namespace SmartRecyclingBin.Services
{
    public class OverrideService : IOverrideService
    {
        private readonly ApplicationDbContext _context;
        private readonly IHubContext<ClassificationHub> _classificationHub;
        private readonly IHubContext<DashboardHub> _dashboardHub;
        private readonly ILogger<OverrideService> _logger;

        public OverrideService(
            ApplicationDbContext context,
            IHubContext<ClassificationHub> classificationHub,
            IHubContext<DashboardHub> dashboardHub,
            ILogger<OverrideService> logger)
        {
            _context = context;
            _classificationHub = classificationHub;
            _dashboardHub = dashboardHub;
            _logger = logger;
        }

        public async Task<bool> ApplyManualOverrideAsync(ManualOverrideRequest request)
        {
            try
            {
                var classification = await _context.ClassificationResults
                    .FindAsync(request.ClassificationId);

                if (classification == null)
                {
                    _logger.LogWarning($"Classification with ID {request.ClassificationId} not found for override");
                    return false;
                }

                // Update classification with override information
                classification.IsOverridden = true;
                classification.OverrideReason = request.Reason;
                classification.OverriddenBy = request.UserId;
                classification.OverrideClassification = request.NewClassification;
                classification.DisposalLocation = request.NewDisposalLocation;
                classification.OverrideTimestamp = DateTime.UtcNow;

                await _context.SaveChangesAsync();

                // Notify connected clients about the override
                var overrideNotification = new
                {
                    ClassificationId = request.ClassificationId,
                    NewClassification = request.NewClassification,
                    NewDisposalLocation = request.NewDisposalLocation,
                    Reason = request.Reason,
                    OverriddenBy = request.UserId,
                    Timestamp = DateTime.UtcNow
                };

                await _classificationHub.Clients.All.SendAsync("ClassificationOverridden", overrideNotification);
                await _dashboardHub.Clients.Group("Dashboard").SendAsync("OverrideApplied", overrideNotification);

                _logger.LogInformation($"Manual override applied to classification {request.ClassificationId} by {request.UserId}");

                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Error applying manual override for classification {request.ClassificationId}");
                throw;
            }
        }

        public async Task<List<ClassificationResult>> GetOverriddenClassificationsAsync(int count = 50)
        {
            try
            {
                return await _context.ClassificationResults
                    .Where(c => c.IsOverridden)
                    .OrderByDescending(c => c.OverrideTimestamp)
                    .Take(count)
                    .ToListAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving overridden classifications");
                throw;
            }
        }

        public async Task<double> GetOverrideRateAsync(DateTime fromDate)
        {
            try
            {
                var totalClassifications = await _context.ClassificationResults
                    .Where(c => c.Timestamp >= fromDate)
                    .CountAsync();

                if (totalClassifications == 0) return 0.0;

                var overriddenCount = await _context.ClassificationResults
                    .Where(c => c.Timestamp >= fromDate && c.IsOverridden)
                    .CountAsync();

                return (double)overriddenCount / totalClassifications * 100;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error calculating override rate");
                throw;
            }
        }
    }
}


FILE: backend/Services/SystemHealthCheck.cs
------------------------------------------------------------
Size: 1.7 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace SmartRecyclingBin.Services
{
    public class SystemHealthCheck : IHealthCheck
    {
        private readonly ISystemHealthService _healthService;
        private readonly ILogger<SystemHealthCheck> _logger;

        public SystemHealthCheck(ISystemHealthService healthService, ILogger<SystemHealthCheck> logger)
        {
            _healthService = healthService;
            _logger = logger;
        }

        public async Task<HealthCheckResult> CheckHealthAsync(
            HealthCheckContext context, 
            CancellationToken cancellationToken = default)
        {
            try
            {
                var health = await _healthService.GetCurrentHealthAsync();
                
                var unhealthyComponents = new List<string>();
                
                if (!health.CameraConnected) unhealthyComponents.Add("Camera");
                if (!health.ArduinoConnected) unhealthyComponents.Add("Arduino");
                if (!health.CnnServiceHealthy) unhealthyComponents.Add("CNN Service");
                if (!health.ExpertSystemHealthy) unhealthyComponents.Add("Expert System");

                if (unhealthyComponents.Count != 0)
                {
                    string description = $"Unhealthy components: {string.Join(", ", unhealthyComponents)}";
                    return HealthCheckResult.Degraded(description);
                }

                return HealthCheckResult.Healthy("All systems operational");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Health check failed");
                return HealthCheckResult.Unhealthy("Health check failed", ex);
            }
        }
    }
}


FILE: backend/Services/SystemHealthService.cs
------------------------------------------------------------
Size: 5.0 KB
Encoding: ascii
------------------------------------------------------------
using Microsoft.EntityFrameworkCore;
using SmartRecyclingBin.Data;
using SmartRecyclingBin.Models;
using System.Diagnostics;

namespace SmartRecyclingBin.Services
{
    public class SystemHealthService : ISystemHealthService
    {
        private readonly ApplicationDbContext _context;
        private readonly ILogger<SystemHealthService> _logger;
        private readonly HttpClient _httpClient;
        private readonly IConfiguration _configuration;

        public SystemHealthService(
            ApplicationDbContext context,
            ILogger<SystemHealthService> logger,
            IHttpClientFactory httpClientFactory,
            IConfiguration configuration)
        {
            _context = context;
            _logger = logger;
            _httpClient = httpClientFactory.CreateClient();
            _configuration = configuration;
        }

        public async Task<SystemHealthMetrics> GetCurrentHealthAsync()
        {
            try
            {
                var metrics = new SystemHealthMetrics
                {
                    Timestamp = DateTime.UtcNow
                };

                // Check Python services health
                var cnnServiceUrl = _configuration["PythonServices:CnnServiceUrl"] ?? "http://localhost:8001";
                var arduinoServiceUrl = _configuration["PythonServices:ArduinoServiceUrl"] ?? "http://localhost:8002";

                metrics.CnnServiceHealthy = await CheckServiceHealthAsync($"{cnnServiceUrl}/health");
                metrics.ArduinoConnected = await CheckServiceHealthAsync($"{arduinoServiceUrl}/health");
                metrics.ExpertSystemHealthy = metrics.CnnServiceHealthy; // Assuming they run together

                // Camera status (would need actual check)
                metrics.CameraConnected = metrics.CnnServiceHealthy;

                // Calculate processing statistics
                var recentClassifications = await _context.ClassificationResults
                    .Where(c => c.Timestamp >= DateTime.UtcNow.AddHours(-1))
                    .ToListAsync();

                metrics.TotalItemsProcessed = await _context.ClassificationResults.CountAsync();
                metrics.AvgProcessingTimeMs = recentClassifications.Count > 0 ? 
                    recentClassifications.Average(c => c.ProcessingTimeMs) : 0;
                metrics.AccuracyRate = recentClassifications.Count > 0 ?
                    recentClassifications.Average(c => c.FinalConfidence) : 0;

                // Classification counts
                metrics.ClassificationCounts = await _context.ClassificationResults
                    .Where(c => c.Timestamp >= DateTime.UtcNow.AddDays(-1))
                    .GroupBy(c => c.FinalClassification)
                    .ToDictionaryAsync(g => g.Key, g => g.Count());

                // System metrics
                var process = Process.GetCurrentProcess();
                metrics.MemoryUsageMB = process.WorkingSet64 / 1024.0 / 1024.0;
                metrics.SystemUptime = (DateTime.UtcNow - process.StartTime).TotalHours;

                // Log the metrics
                await LogHealthMetricsAsync(metrics);

                return metrics;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting current health metrics");
                throw;
            }
        }

        public async Task<bool> CheckServiceHealthAsync(string serviceUrl)
        {
            try
            {
                _httpClient.Timeout = TimeSpan.FromSeconds(5);
                var response = await _httpClient.GetAsync(serviceUrl);
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, $"Health check failed for service: {serviceUrl}");
                return false;
            }
        }

        public async Task LogHealthMetricsAsync(SystemHealthMetrics metrics)
        {
            try
            {
                _context.HealthMetrics.Add(metrics);
                
                // Keep only last 24 hours of health metrics to prevent database bloat
                var cutoffTime = DateTime.UtcNow.AddHours(-24);
                var oldMetrics = _context.HealthMetrics.Where(m => m.Timestamp < cutoffTime);
                _context.HealthMetrics.RemoveRange(oldMetrics);

                await _context.SaveChangesAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error logging health metrics");
            }
        }

        public async Task<List<SystemAlert>> GetActiveAlertsAsync()
        {
            try
            {
                return await _context.SystemAlerts
                    .Where(a => !a.IsResolved)
                    .OrderByDescending(a => a.Timestamp)
                    .Take(50)
                    .ToListAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error retrieving active alerts");
                throw;
            }
        }
    }
}



FILE: backend/SmartRecyclingBin.csproj
------------------------------------------------------------
Size: 2.2 KB
Encoding: ascii
------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Cors" Version="2.3.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.8" />
    <PackageReference Include="Microsoft.AspNetCore.SignalR" Version="1.2.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Serilog.AspNetCore" Version="9.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore.Annotations" Version="6.5.0" />
    <PackageReference Include="System.Text.Json" Version="9.0.0" />
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Logs\" />
    <Folder Include="Data\" />
  </ItemGroup>

  <ItemGroup>
    <_ContentIncludedByDefault Remove="SmartRecyclingBin\appsettings.Development.json" />
    <_ContentIncludedByDefault Remove="SmartRecyclingBin\appsettings.json" />
    <_ContentIncludedByDefault Remove="SmartRecyclingBin\obj\project.assets.json" />
    <_ContentIncludedByDefault Remove="SmartRecyclingBin\obj\SmartRecyclingBin.csproj.nuget.dgspec.json" />
    <_ContentIncludedByDefault Remove="SmartRecyclingBin\Properties\launchSettings.json" />
  </ItemGroup>

</Project>


FILE: backend/SmartRecyclingBin.http
------------------------------------------------------------
Size: 147 B
Encoding: ascii
------------------------------------------------------------
@SmartRecyclingBin_HostAddress = http://localhost:5099

GET {{SmartRecyclingBin_HostAddress}}/weatherforecast/
Accept: application/json

###



FILE: backend/appsettings.Development.json
------------------------------------------------------------
Size: 127 B
Encoding: ascii
------------------------------------------------------------
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}



FILE: backend/appsettings.json
------------------------------------------------------------
Size: 1.5 KB
Encoding: ascii
------------------------------------------------------------
{
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=../data/smartbin.db"
  },
  "ApplicationSettings": {
    "DatabasePath": "../data/smartbin.db",
    "PythonServices": {
      "CnnServiceUrl": "http://localhost:8001",
      "ArduinoServiceUrl": "http://localhost:8002",
      "HealthCheckIntervalSeconds": 30,
      "TimeoutSeconds": 10
    },
    "Processing": {
      "ConfidenceThreshold": 0.85,
      "MaxProcessingTimeMs": 2000,
      "MaxConcurrentClassifications": 10
    },
    "Notifications": {
      "EnableRealTimeUpdates": true,
      "EnableEmailAlerts": false
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.AspNetCore.SignalR": "Information",
      "Microsoft.EntityFrameworkCore": "Warning",
      "SmartRecyclingBin": "Information"
    }
  },
  "AllowedHosts": "*",
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.File"],
    "MinimumLevel": "Information",
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/smart-recycling-bin-.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7,
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss} [{Level:u3}] {SourceContext} {Message:lj}{NewLine}{Exception}"
        }
      }
    ],
    "Enrich": ["FromLogContext"]
  }
}


FILE: docker/dockerfiles/Dockerfile.backend
------------------------------------------------------------
Size: 656 B
Encoding: ascii
------------------------------------------------------------
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 5000

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["*.csproj", "./"]
RUN dotnet restore

COPY . .
RUN dotnet build -c Release -o /app/build

FROM build AS publish
RUN dotnet publish -c Release -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .

# Create directories for data and logs
RUN mkdir -p /app/data /app/logs

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/api/health || exit 1

ENTRYPOINT ["dotnet", "SmartRecyclingBin.dll"]



FILE: docker/dockerfiles/Dockerfile.frontend
------------------------------------------------------------
Size: 496 B
Encoding: ascii
------------------------------------------------------------
# Build stage
FROM node:18-alpine AS build

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine

# Copy built app
COPY --from=build /app/build /usr/share/nginx/html

# Copy nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost || exit 1

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]



FILE: docker/dockerfiles/Dockerfile.python
------------------------------------------------------------
Size: 724 B
Encoding: ascii
------------------------------------------------------------
FROM python:3.9-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    libglib2.0-0 \
    libsm6 \
    libxext6 \
    libxrender-dev \
    libgomp1 \
    libgtk-3-0 \
    libavcodec-dev \
    libavformat-dev \
    libswscale-dev \
    libv4l-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy source code
COPY . .

# Set environment variables
ENV PYTHONPATH=/app

# Create non-root user
RUN useradd -m -u 1001 appuser && chown -R appuser:appuser /app
USER appuser

# Expose ports
EXPOSE 8001 8002

# Start the services
CMD ["python", "main_integrated.py"]



FILE: docker-compose.dev.yml
------------------------------------------------------------
Size: 1.2 KB
Encoding: ascii
------------------------------------------------------------
version: '3.8'

services:
  # C# Backend API (Development)
  backend-api-dev:
    build:
      context: ./backend
      dockerfile: ../docker/dockerfiles/Dockerfile.backend
      target: build  # Stop at build stage for development
    ports:
      - "5000:5000"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:5000
      - ConnectionStrings__DefaultConnection=Data Source=/app/data/smartbin.db
    volumes:
      - ./backend:/app/src
      - ./data:/app/data
      - ./logs:/app/logs
    networks:
      - smartbin-network
    restart: unless-stopped
    command: ["dotnet", "watch", "run", "--no-restore", "--urls", "http://0.0.0.0:5000"]

  # React Frontend (Development)
  frontend-dev:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:5000
      - REACT_APP_WS_URL=ws://localhost:5000
      - CHOKIDAR_USEPOLLING=true
    volumes:
      - ./frontend/src:/app/src
      - ./frontend/public:/app/public
      - /app/node_modules
    networks:
      - smartbin-network
    depends_on:
      - backend-api-dev
    stdin_open: true
    tty: true

networks:
  smartbin-network:
    driver: bridge



FILE: docker-compose.yml
------------------------------------------------------------
Size: 1.6 KB
Encoding: ascii
------------------------------------------------------------
version: '3.8'

services:
  # C# Backend API
  backend-api:
    build:
      context: ./backend
      dockerfile: ../docker/dockerfiles/Dockerfile.backend
    ports:
      - "5000:5000"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ASPNETCORE_URLS=http://+:5000
      - ConnectionStrings__DefaultConnection=Data Source=/app/data/smartbin.db
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    networks:
      - smartbin-network
    restart: unless-stopped

  # Python services
  python-services:
    build:
      context: ./python-services
      dockerfile: ../docker/dockerfiles/Dockerfile.python
    ports:
      - "8001:8001"
      - "8002:8002"
    environment:
      - MODEL_PATH=/app/models/trash_classifier_v3_93_accuracy_4mp.keras
      - CAMERA_INDEX=0
      - ARDUINO_PORT=/dev/ttyUSB0
      - BACKEND_URL=http://backend-api:5000/classification-hub
    volumes:
      - ./models:/app/models
      - ./logs:/app/logs
      - /dev/video0:/dev/video0
      - /dev/ttyUSB0:/dev/ttyUSB0
    devices:
      - /dev/video0:/dev/video0
      - /dev/ttyUSB0:/dev/ttyUSB0
    networks:
      - smartbin-network
    restart: unless-stopped
    depends_on:
      - backend-api

  # React Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: ../docker/dockerfiles/Dockerfile.frontend
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://localhost:5000
      - REACT_APP_WS_URL=ws://localhost:5000
    depends_on:
      - backend-api
    networks:
      - smartbin-network
    restart: unless-stopped

networks:
  smartbin-network:
    driver: bridge



FILE: frontend/.env.development
------------------------------------------------------------
Size: 124 B
Encoding: ascii
------------------------------------------------------------
REACT_APP_API_URL=http://localhost:5099
REACT_APP_WS_URL=http://localhost:5099
REACT_APP_DEBUG=true
GENERATE_SOURCEMAP=true



FILE: frontend/.gitignore
------------------------------------------------------------
Size: 310 B
Encoding: ascii
------------------------------------------------------------
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*



FILE: frontend/.prettierrc
------------------------------------------------------------
Size: 125 B
Encoding: ascii
------------------------------------------------------------
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}



FILE: frontend/Dockerfile.dev
------------------------------------------------------------
Size: 201 B
Encoding: ascii
------------------------------------------------------------
FROM node:18-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm install

# Copy source code
COPY . .

# Expose port
EXPOSE 3000

# Start development server
CMD ["npm", "start"]



FILE: frontend/README.md
------------------------------------------------------------
Size: 2.1 KB
Encoding: utf-8
------------------------------------------------------------
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).



FILE: frontend/nginx.conf
------------------------------------------------------------
Size: 568 B
Encoding: ascii
------------------------------------------------------------
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Handle client-side routing
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}



FILE: frontend/package.json
------------------------------------------------------------
Size: 1.6 KB
Encoding: ascii
------------------------------------------------------------
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@microsoft/signalr": "^9.0.6",
    "@mui/icons-material": "^7.3.1",
    "@mui/lab": "^7.0.0-beta.16",
    "@mui/material": "^7.3.1",
    "@mui/system": "^7.3.1",
    "@mui/utils": "^7.3.1",
    "@mui/x-date-pickers": "^8.11.0",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.8.0",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "axios": "^1.11.0",
    "date-fns": "^4.1.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "react-router-dom": "^7.8.2",
    "react-scripts": "5.0.1",
    "recharts": "^3.1.2",
    "typescript": "^4.9.5",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "analyze": "npm run build && npx source-map-explorer build/static/js/*.js",
    "format": "prettier --write src/**/*.{ts,tsx,js,jsx,json,css,md}"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@types/node": "^24.3.0",
    "@types/react": "^19.1.12",
    "@types/react-dom": "^19.1.9",
    "eslint-config-prettier": "^10.1.8",
    "prettier": "^3.6.2"
  }
}



FILE: frontend/public/index.html
------------------------------------------------------------
Size: 1.7 KB
Encoding: ascii
------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>



FILE: frontend/public/manifest.json
------------------------------------------------------------
Size: 492 B
Encoding: ascii
------------------------------------------------------------
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}



FILE: frontend/public/robots.txt
------------------------------------------------------------
Size: 67 B
Encoding: ascii
------------------------------------------------------------
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:



FILE: frontend/src/App.css
------------------------------------------------------------
Size: 564 B
Encoding: ascii
------------------------------------------------------------
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}



FILE: frontend/src/App.test.tsx
------------------------------------------------------------
Size: 273 B
Encoding: ascii
------------------------------------------------------------
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});



FILE: frontend/src/App.tsx
------------------------------------------------------------
Size: 1.8 KB
Encoding: ascii
------------------------------------------------------------
import React from 'react';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Layout from './components/Layout/Layout';
import Dashboard from './components/Dashboard/Dashboard';
import ClassificationHistory from './components/Classification/ClassificationHistory';
import SystemHealth from './components/System/SystemHealth';

// Create Material-UI theme
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#388e3c',
      light: '#66bb6a',
      dark: '#2e7d32',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 600,
    },
    h5: {
      fontWeight: 600,
    },
    h6: {
      fontWeight: 600,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 600,
        },
      },
    },
  },
});

const App: React.FC = () => {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Router>
        <Layout>
          <Routes>
            <Route path="/" element={<Dashboard />} />
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/classifications" element={<ClassificationHistory />} />
            <Route path="/system" element={<SystemHealth />} />
          </Routes>
        </Layout>
      </Router>
    </ThemeProvider>
  );
};

export default App;



FILE: frontend/src/components/Classification/ClassificationHistory.tsx
------------------------------------------------------------
Size: 19.7 KB
Encoding: ascii
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import {
  Typography,
  Card,
  CardContent,
  Box,
  Grid,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  TextField,
  MenuItem,
  Pagination,
  LinearProgress,
  Button,
  Alert,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  SelectChangeEvent, // <-- FIXED: Import SelectChangeEvent
} from '@mui/material';
import {
  History,
  FilterList,
  Download,
  Search,
  CheckCircle,
  Warning,
  Error as ErrorIcon,
  Visibility,
  Refresh,
} from '@mui/icons-material';
import { api } from '../../services/api';
import { useSignalR } from '../../hooks/useSignalR';
import { ClassificationResult } from '../../types';

const ClassificationHistory: React.FC = () => {
  const [classifications, setClassifications] = useState<ClassificationResult[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [totalCount, setTotalCount] = useState(0);
  const [pageSize] = useState(20);
  const [filterBy, setFilterBy] = useState<string>('');
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedClassification, setSelectedClassification] = useState<ClassificationResult | null>(null);
  const [detailsOpen, setDetailsOpen] = useState(false);

  // Use SignalR for real-time updates
  const { latestClassification } = useSignalR();

  // Fetch classifications data
  const fetchClassifications = async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await api.getRecentClassifications(
        page, 
        pageSize, 
        filterBy || undefined
      );
      
      setClassifications(response.items);
      setTotalPages(response.totalPages);
      setTotalCount(response.totalCount);
    } catch (err) {
      console.error('Error fetching classifications:', err);
      setError(err instanceof Error ? err.message : 'Failed to load classifications');
    } finally {
      setLoading(false);
    }
  };

  // Initial data fetch and refresh on filter changes
  useEffect(() => {
    fetchClassifications();
  }, [page, filterBy]);

  // Add new classification from SignalR to the top of the list
  useEffect(() => {
    if (latestClassification && page === 1) {
      setClassifications(prev => {
        // Check if this classification already exists
        if (prev.some(c => c.id === latestClassification.id)) {
          return prev;
        }
        
        // Add to the beginning and maintain page size
        const updated = [latestClassification, ...prev];
        return updated.slice(0, pageSize);
      });
      
      setTotalCount(prev => prev + 1);
    }
  }, [latestClassification, page, pageSize]);

  const handlePageChange = (event: React.ChangeEvent<unknown>, newPage: number) => {
    setPage(newPage);
  };

  // FIXED: Changed the event type to SelectChangeEvent
  const handleFilterChange = (event: SelectChangeEvent) => {
    setFilterBy(event.target.value);
    setPage(1); // Reset to first page when filter changes
  };

  const handleExportData = async () => {
    try {
      const blob = await api.exportClassifications();
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `classifications_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Export failed:', err);
    }
  };

  const handleViewDetails = (classification: ClassificationResult) => {
    setSelectedClassification(classification);
    setDetailsOpen(true);
  };

  const getValidationIcon = (status: 'pass' | 'fail') => {
    return status === 'pass' ? (
      <CheckCircle color="success" fontSize="small" />
    ) : (
      <ErrorIcon color="error" fontSize="small" />
    );
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 95) return 'success';
    if (confidence >= 85) return 'warning';
    return 'error';
  };

  // Get unique classification types for filter dropdown
  const uniqueClassifications = Array.from(
    new Set(classifications.map(c => c.finalClassification))
  ).sort();

  if (loading && classifications.length === 0) {
    return (
      <Box sx={{ p: 3, backgroundColor: '#f5f5f5', minHeight: '100vh' }}>
        <Typography variant="h4" gutterBottom>
          Classification History
        </Typography>
        <LinearProgress />
        <Typography sx={{ mt: 2 }} color="text.secondary">
          Loading classification data...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3, backgroundColor: '#f5f5f5', minHeight: '100vh' }}>
      {/* Header */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box display="flex" alignItems="center">
            <History sx={{ mr: 2, fontSize: '2rem', color: 'primary.main' }} />
            <Box>
              <Typography variant="h4" sx={{ fontWeight: 600 }}>
                Classification History
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                Complete record of all processed items
              </Typography>
            </Box>
          </Box>
          
          <Box display="flex" gap={2}>
            <Button
              variant="outlined"
              startIcon={<Refresh />}
              onClick={fetchClassifications}
              disabled={loading}
            >
              Refresh
            </Button>
            <Button
              variant="contained"
              startIcon={<Download />}
              onClick={handleExportData}
            >
              Export Data
            </Button>
          </Box>
        </Box>
      </Paper>

      {/* Error Alert */}
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          <Typography variant="subtitle2">Error Loading Data</Typography>
          {error}
        </Alert>
      )}

      {/* Filters and Controls */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
          Search & Filter
        </Typography>
        <Grid container spacing={3} alignItems="center">
          <Grid size={{ xs: 12, md: 4 }}>
            <TextField
              fullWidth
              label="Search"
              variant="outlined"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: <Search sx={{ mr: 1, color: 'text.secondary' }} />,
              }}
            />
          </Grid>
          
          <Grid size={{ xs: 12, md: 4 }}>
            <FormControl fullWidth>
              <InputLabel>Filter by Classification</InputLabel>
              <Select
                value={filterBy}
                label="Filter by Classification"
                onChange={handleFilterChange}
              >
                <MenuItem value="">All Classifications</MenuItem>
                {uniqueClassifications.map((classification) => (
                  <MenuItem key={classification} value={classification}>
                    {classification}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
          
          <Grid size={{ xs: 12, md: 4 }}>
            <Box display="flex" alignItems="center" gap={1}>
              <FilterList color="primary" />
              <Typography variant="body2" color="text.secondary">
                {totalCount.toLocaleString()} total records
              </Typography>
            </Box>
          </Grid>
        </Grid>
      </Paper>

      {/* Classifications Table */}
      <Paper sx={{ backgroundColor: 'white' }} elevation={1}>
        <Box sx={{ p: 3 }}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            Classification Records
          </Typography>
          
          {loading && <LinearProgress sx={{ mb: 2 }} />}
          
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600 }}>Date & Time</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Item ID</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Classification</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Confidence</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Processing Time</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Status</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Actions</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {classifications.map((classification) => (
                  <TableRow key={classification.id} hover>
                    <TableCell>
                      <Typography variant="body2">
                        {new Date(classification.timestamp).toLocaleString()}
                      </Typography>
                    </TableCell>
                    
                    <TableCell>
                      <Typography variant="body2" sx={{ fontWeight: 500 }}>
                        #{classification.id}
                      </Typography>
                    </TableCell>
                    
                    <TableCell>
                      <Box>
                        <Typography variant="body2" sx={{ fontWeight: 500 }}>
                          {classification.finalClassification}
                        </Typography>
                        {classification.isOverridden && (
                          <Chip 
                            label="Override Applied"
                            size="small"
                            color="warning"
                            variant="outlined"
                            sx={{ mt: 0.5 }}
                          />
                        )}
                      </Box>
                    </TableCell>
                    
                    <TableCell>
                      <Chip
                        label={`${(classification.finalConfidence * 100).toFixed(1)}%`}
                        size="small"
                        color={getConfidenceColor(classification.finalConfidence * 100)}
                        variant="outlined"
                      />
                    </TableCell>
                    
                    <TableCell>
                      <Typography variant="body2">
                        {classification.processingTime?.toFixed(0) || 0}ms
                      </Typography>
                    </TableCell>
                    
                    <TableCell>
                      <Box display="flex" gap={0.5}>
                        {classification.sensorValidation ? (
                          <>
                            <Box title="Weight Sensor">
                              {getValidationIcon(classification.sensorValidation.weight)}
                            </Box>
                            <Box title="Metal Detector">
                              {getValidationIcon(classification.sensorValidation.metal)}
                            </Box>
                            <Box title="Humidity Sensor">
                              {getValidationIcon(classification.sensorValidation.humidity)}
                            </Box>
                            <Box title="IR Spectroscopy">
                              {getValidationIcon(classification.sensorValidation.ir_spectroscopy)}
                            </Box>
                          </>
                        ) : (
                          <Typography variant="caption" color="text.secondary">
                            No validation data
                          </Typography>
                        )}
                      </Box>
                    </TableCell>
                    
                    <TableCell>
                      <IconButton
                        size="small"
                        onClick={() => handleViewDetails(classification)}
                        title="View Details"
                      >
                        <Visibility />
                      </IconButton>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>

          {/* Pagination */}
          <Box display="flex" justifyContent="center" sx={{ mt: 3 }}>
            <Pagination
              count={totalPages}
              page={page}
              onChange={handlePageChange}
              color="primary"
              size="large"
              showFirstButton
              showLastButton
            />
          </Box>
        </Box>
      </Paper>

      {/* Details Dialog */}
      <Dialog
        open={detailsOpen}
        onClose={() => setDetailsOpen(false)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>
          <Typography variant="h6" sx={{ fontWeight: 600 }}>
            Classification Details - ID #{selectedClassification?.id}
          </Typography>
        </DialogTitle>
        <DialogContent>
          {selectedClassification && (
            <Box sx={{ pt: 2 }}>
              <Grid container spacing={3}>
                <Grid size={{ xs: 12, md: 6 }}>
                  <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
                    Classification Results
                  </Typography>
                  <Table size="small">
                    <TableBody>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Final Classification</TableCell>
                        <TableCell>{selectedClassification.finalClassification}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Confidence</TableCell>
                        <TableCell>{(selectedClassification.finalConfidence * 100).toFixed(1)}%</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>CNN Stage 1</TableCell>
                        <TableCell>
                          {selectedClassification.cnnStage1Class} 
                          ({((selectedClassification.cnnStage1Confidence || 0) * 100).toFixed(1)}%)
                        </TableCell>
                      </TableRow>
                      {selectedClassification.cnnStage2Class && (
                        <TableRow>
                          <TableCell sx={{ fontWeight: 600 }}>CNN Stage 2</TableCell>
                          <TableCell>
                            {selectedClassification.cnnStage2Class} 
                            ({((selectedClassification.cnnStage2Confidence || 0) * 100).toFixed(1)}%)
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </Grid>
                
                <Grid size={{ xs: 12, md: 6 }}>
                  <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
                    System Information
                  </Typography>
                  <Table size="small">
                    <TableBody>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Processing Time</TableCell>
                        <TableCell>{selectedClassification.processingTime?.toFixed(0) || 0}ms</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Timestamp</TableCell>
                        <TableCell>{new Date(selectedClassification.timestamp).toLocaleString()}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Disposal Location</TableCell>
                        <TableCell>{selectedClassification.disposalLocation}</TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600 }}>Decision Path</TableCell>
                        <TableCell>
                          {(selectedClassification.decisionPath || 'standard_classification').replace(/_/g, ' ��� ')}
                        </TableCell>
                      </TableRow>
                    </TableBody>
                  </Table>
                </Grid>
                
                {selectedClassification.sensorValidation && (
                  <Grid size={{ xs: 12 }}>
                    <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
                      Sensor Validation Results
                    </Typography>
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell sx={{ fontWeight: 600 }}>Sensor</TableCell>
                          <TableCell sx={{ fontWeight: 600 }}>Status</TableCell>
                          <TableCell sx={{ fontWeight: 600 }}>Result</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {Object.entries(selectedClassification.sensorValidation).map(([sensor, status]) => (
                          <TableRow key={sensor}>
                            <TableCell>{sensor.replace('_', ' ').toUpperCase()}</TableCell>
                            <TableCell>
                              {getValidationIcon(status as 'pass' | 'fail')}
                            </TableCell>
                            <TableCell>
                              <Chip
                                label={status.toUpperCase()}
                                size="small"
                                color={status === 'pass' ? 'success' : 'error'}
                                variant="outlined"
                              />
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </Grid>
                )}
                
                {selectedClassification.overrideInfo?.isOverridden && (
                  <Grid size={{ xs: 12 }}>
                    <Alert severity="info" sx={{ mt: 2 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                        Manual Override Applied
                      </Typography>
                      <Typography variant="body2">
                        Original: {selectedClassification.overrideInfo.originalClassification}
                      </Typography>
                      <Typography variant="body2">
                        Reason: {selectedClassification.overrideInfo.reason}
                      </Typography>
                      <Typography variant="body2">
                        By: {selectedClassification.overrideInfo.overriddenBy} on{' '}
                        {selectedClassification.overrideInfo.overrideTimestamp && 
                          new Date(selectedClassification.overrideInfo.overrideTimestamp).toLocaleString()}
                      </Typography>
                    </Alert>
                  </Grid>
                )}
              </Grid>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDetailsOpen(false)} variant="outlined">
            Close
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default ClassificationHistory;



FILE: frontend/src/components/Dashboard/Dashboard.tsx
------------------------------------------------------------
Size: 16.1 KB
Encoding: ascii
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import {
  Box,
  Grid,
  Paper,
  Typography,
  Card,
  CardContent,
  Chip,
  LinearProgress,
  Alert,
  IconButton,
  Tooltip,
  Divider,
  Stack,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
} from '@mui/material';
import {
  Refresh as RefreshIcon,
  CheckCircle as CheckCircleIcon,
  Error as ErrorIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  TrendingUp,
  Assessment,
  Speed,
  Security,
} from '@mui/icons-material';
import { useSignalR } from '../../hooks/useSignalR';

const Dashboard: React.FC = () => {
  const [refreshing, setRefreshing] = useState(false);

  const {
    connected,
    isConnected,
    isLoading,
    error,
    stats,
    health,
    latestClassification,
    latestAlert,
    reconnect,
    requestSystemStatus,
    requestStats,
  } = useSignalR();

  // Handle manual refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await Promise.all([requestSystemStatus(), requestStats()]);
    } catch (error) {
      console.error('Failed to refresh data:', error);
    } finally {
      setRefreshing(false);
    }
  };

  // Handle reconnect
  const handleReconnect = async () => {
    setRefreshing(true);
    try {
      await reconnect();
    } catch (error) {
      console.error('Failed to reconnect:', error);
    } finally {
      setRefreshing(false);
    }
  };

  // Utility functions
  const formatPercentage = (value: number | undefined) => {
    return `${((value || 0) * 100).toFixed(1)}%`;
  };

  const formatNumber = (value: number | undefined) => {
    return (value || 0).toLocaleString();
  };

  const formatDate = (value: Date | string | undefined) => {
    if (!value) return 'Never';
    const date = typeof value === 'string' ? new Date(value) : value;
    return date.toLocaleString();
  };

  const getStatusColor = (isConnected: boolean) => {
    return isConnected ? 'success' : 'error';
  };

  if (isLoading) {
    return (
      <Box sx={{ width: '100%', p: 3 }}>
        <Typography variant="h4" gutterBottom>
          Smart Recycling Bin Dashboard
        </Typography>
        <LinearProgress />
        <Typography sx={{ mt: 2 }} color="text.secondary">
          Connecting to system...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3, backgroundColor: '#f5f5f5', minHeight: '100vh' }}>
      {/* Header */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Box>
            <Typography variant="h4" component="h1" sx={{ fontWeight: 600, mb: 1 }}>
              Smart Recycling Control Center
            </Typography>
            <Typography variant="subtitle1" color="text.secondary">
              Real-time Monitoring & Classification System
            </Typography>
          </Box>
          <Box display="flex" alignItems="center" gap={2}>
            <Chip
              label={isConnected ? 'System Online' : 'System Offline'}
              color={getStatusColor(isConnected)}
              variant="outlined"
            />
            <Tooltip title="Refresh Data">
              <IconButton onClick={handleRefresh} disabled={refreshing}>
                <RefreshIcon />
              </IconButton>
            </Tooltip>
            {!isConnected && (
              <Button 
                variant="outlined" 
                color="error" 
                onClick={handleReconnect}
                disabled={refreshing}
              >
                Reconnect
              </Button>
            )}
          </Box>
        </Box>
      </Paper>

      {/* Error Alert */}
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      {/* System Status */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
          System Components Status
        </Typography>
        <Grid container spacing={3}>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent sx={{ textAlign: 'center' }}>
                <Typography color="text.secondary" gutterBottom>
                  Classification Hub
                </Typography>
                <Chip
                  label={connected.classification ? 'Connected' : 'Disconnected'}
                  color={getStatusColor(connected.classification)}
                  icon={connected.classification ? <CheckCircleIcon /> : <ErrorIcon />}
                  variant="outlined"
                />
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent sx={{ textAlign: 'center' }}>
                <Typography color="text.secondary" gutterBottom>
                  Dashboard Hub
                </Typography>
                <Chip
                  label={connected.dashboard ? 'Connected' : 'Disconnected'}
                  color={getStatusColor(connected.dashboard)}
                  icon={connected.dashboard ? <CheckCircleIcon /> : <ErrorIcon />}
                  variant="outlined"
                />
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent sx={{ textAlign: 'center' }}>
                <Typography color="text.secondary" gutterBottom>
                  CNN Service
                </Typography>
                <Chip
                  label={health.CnnServiceHealthy ? 'Healthy' : 'Issues Detected'}
                  color={getStatusColor(health.CnnServiceHealthy)}
                  icon={health.CnnServiceHealthy ? <CheckCircleIcon /> : <WarningIcon />}
                  variant="outlined"
                />
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent sx={{ textAlign: 'center' }}>
                <Typography color="text.secondary" gutterBottom>
                  Sensor Array
                </Typography>
                <Chip
                  label={health.ArduinoConnected ? 'Connected' : 'Disconnected'}
                  color={getStatusColor(health.ArduinoConnected)}
                  icon={health.ArduinoConnected ? <CheckCircleIcon /> : <ErrorIcon />}
                  variant="outlined"
                />
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Paper>

      {/* Key Performance Metrics */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
          Performance Metrics
        </Typography>
        <Grid container spacing={3}>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent>
                <Box display="flex" alignItems="center" justifyContent="space-between">
                  <Box>
                    <Typography color="text.secondary" variant="body2">
                      Items Today
                    </Typography>
                    <Typography variant="h4" sx={{ fontWeight: 600 }}>
                      {formatNumber(stats.ItemsToday)}
                    </Typography>
                  </Box>
                  <TrendingUp color="primary" sx={{ fontSize: 40 }} />
                </Box>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent>
                <Box display="flex" alignItems="center" justifyContent="space-between">
                  <Box>
                    <Typography color="text.secondary" variant="body2">
                      Accuracy Rate
                    </Typography>
                    <Typography variant="h4" sx={{ fontWeight: 600 }}>
                      {formatPercentage(stats.AccuracyRate)}
                    </Typography>
                  </Box>
                  <Assessment color="success" sx={{ fontSize: 40 }} />
                </Box>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent>
                <Box display="flex" alignItems="center" justifyContent="space-between">
                  <Box>
                    <Typography color="text.secondary" variant="body2">
                      Processing Time
                    </Typography>
                    <Typography variant="h4" sx={{ fontWeight: 600 }}>
                      {health.AvgProcessingTimeMs}ms
                    </Typography>
                  </Box>
                  <Speed color="warning" sx={{ fontSize: 40 }} />
                </Box>
              </CardContent>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, sm: 6, md: 3 }}>
            <Card variant="outlined">
              <CardContent>
                <Box display="flex" alignItems="center" justifyContent="space-between">
                  <Box>
                    <Typography color="text.secondary" variant="body2">
                      Override Rate
                    </Typography>
                    <Typography variant="h4" sx={{ fontWeight: 600 }}>
                      {stats.OverrideRate.toFixed(1)}%
                    </Typography>
                  </Box>
                  <Security color="info" sx={{ fontSize: 40 }} />
                </Box>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Paper>

      <Grid container spacing={3}>
        {/* Latest Classification */}
        <Grid size={{ xs: 12, lg: 8 }}>
          <Paper sx={{ p: 3, backgroundColor: 'white' }} elevation={1}>
            <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
              Latest Classification Result
            </Typography>
            {latestClassification ? (
              <TableContainer>
                <Table size="small">
                  <TableBody>
                    <TableRow>
                      <TableCell sx={{ fontWeight: 600 }}>Classification</TableCell>
                      <TableCell>{latestClassification.finalClassification}</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell sx={{ fontWeight: 600 }}>Confidence</TableCell>
                      <TableCell>{formatPercentage(latestClassification.finalConfidence)}</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell sx={{ fontWeight: 600 }}>Processing Time</TableCell>
                      <TableCell>{latestClassification.processingTime}ms</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell sx={{ fontWeight: 600 }}>Disposal Location</TableCell>
                      <TableCell>{latestClassification.disposalLocation}</TableCell>
                    </TableRow>
                    <TableRow>
                      <TableCell sx={{ fontWeight: 600 }}>Item ID</TableCell>
                      <TableCell>#{latestClassification.id}</TableCell>
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            ) : (
              <Box sx={{ textAlign: 'center', py: 4, color: 'text.secondary' }}>
                <Typography variant="body1">
                  Waiting for classification data...
                </Typography>
                <Typography variant="body2" sx={{ mt: 1 }}>
                  The system is ready to process incoming items
                </Typography>
              </Box>
            )}
          </Paper>
        </Grid>

        {/* System Summary */}
        <Grid size={{ xs: 12, lg: 4 }}>
          <Paper sx={{ p: 3, backgroundColor: 'white' }} elevation={1}>
            <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
              System Summary
            </Typography>
            <Stack spacing={3}>
              <Box>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  Total Items Processed
                </Typography>
                <Typography variant="h5" sx={{ fontWeight: 600 }}>
                  {formatNumber(stats.TotalItems)}
                </Typography>
              </Box>
              
              <Divider />
              
              <Box>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  Weekly Progress
                </Typography>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  {formatNumber(stats.ItemsThisWeek)} items
                </Typography>
                <LinearProgress 
                  variant="determinate" 
                  value={85} 
                  sx={{ 
                    mt: 1,
                    height: 8
                  }}
                />
                <Typography variant="caption" color="text.secondary" sx={{ mt: 1, display: 'block' }}>
                  85% of weekly target
                </Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  System Uptime
                </Typography>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  {health.SystemUptime.toFixed(1)} hours
                </Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary" gutterBottom>
                  Memory Usage
                </Typography>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  {(health.MemoryUsageMB / 1024).toFixed(1)} GB
                </Typography>
              </Box>
            </Stack>
          </Paper>
        </Grid>
      </Grid>

      {/* Classification Breakdown */}
      <Paper sx={{ p: 3, mt: 3, backgroundColor: 'white' }} elevation={1}>
        <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
          Today's Classification Breakdown
        </Typography>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell sx={{ fontWeight: 600 }}>Material Type</TableCell>
                <TableCell align="right" sx={{ fontWeight: 600 }}>Count</TableCell>
                <TableCell align="right" sx={{ fontWeight: 600 }}>Percentage</TableCell>
                <TableCell sx={{ fontWeight: 600 }}>Progress</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {Object.entries(stats.ClassificationBreakdown || {}).map(([category, count]) => {
                const percentage = (count / stats.ItemsToday) * 100;
                return (
                  <TableRow key={category}>
                    <TableCell>{category}</TableCell>
                    <TableCell align="right">{formatNumber(count)}</TableCell>
                    <TableCell align="right">{percentage.toFixed(1)}%</TableCell>
                    <TableCell>
                      <Box sx={{ width: '100%', maxWidth: 200 }}>
                        <LinearProgress 
                          variant="determinate" 
                          value={Math.min(percentage, 100)} 
                          sx={{ height: 6 }}
                        />
                      </Box>
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>

      {/* Alert Display */}
      {latestAlert && (
        <Alert
          severity={latestAlert.level as 'error' | 'warning' | 'info'}
          sx={{ mt: 3 }}
        >
          <Typography variant="subtitle2">
            {latestAlert.source} - {formatDate(latestAlert.timestamp)}
          </Typography>
          <Typography variant="body2">{latestAlert.message}</Typography>
        </Alert>
      )}
    </Box>
  );
};

export default Dashboard;



FILE: frontend/src/components/Layout/Layout.tsx
------------------------------------------------------------
Size: 14.6 KB
Encoding: ascii
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import {
  AppBar,
  Toolbar,
  Typography,
  Drawer,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Box,
  IconButton,
  Avatar,
  Badge,
  Tooltip,
  useTheme,
  useMediaQuery,
  Fade,
  Grow,
  Chip,
} from '@mui/material';
import {
  Dashboard,
  History,
  HealthAndSafety,
  Menu as MenuIcon,
  RecyclingOutlined,
  NotificationsOutlined,
  Settings,
  Close as CloseIcon,
  Analytics,
  Refresh,
} from '@mui/icons-material';
import { useNavigate, useLocation } from 'react-router-dom';

const drawerWidth = 280;

interface LayoutProps {
  children: React.ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const [mounted, setMounted] = useState(false);
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));

  useEffect(() => {
    setMounted(true);
  }, []);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const menuItems = [
    {
      text: 'Dashboard',
      icon: <Dashboard />,
      path: '/dashboard',
      color: '#1976d2',
    },
    {
      text: 'Classification History',
      icon: <History />,
      path: '/classifications',
      color: '#388e3c',
    },
    {
      text: 'System Health',
      icon: <HealthAndSafety />,
      path: '/system',
      color: '#f57c00',
    },
    {
      text: 'Analytics',
      icon: <Analytics />,
      path: '/analytics',
      color: '#7b1fa2',
    },
    {
      text: 'Settings',
      icon: <Settings />,
      path: '/settings',
      color: '#455a64',
    },
  ];

  const drawer = (
    <Box sx={{ 
      height: '100%', 
      display: 'flex', 
      flexDirection: 'column',
      background: 'linear-gradient(145deg, #f8fafc 0%, #e2e8f0 100%)',
      position: 'relative',
      '&::before': {
        content: '""',
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.1) 100%)',
        backdropFilter: 'blur(10px)',
        borderRight: '1px solid rgba(255,255,255,0.2)',
      }
    }}>
      {/* Header Section */}
      <Box
        sx={{
          position: 'relative',
          zIndex: 1,
          p: 3,
          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          color: 'white',
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box
              sx={{
                width: 48,
                height: 48,
                borderRadius: '12px',
                background: 'rgba(255,255,255,0.2)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                mr: 2,
                backdropFilter: 'blur(10px)',
                animation: 'pulse 2s ease-in-out infinite',
                '@keyframes pulse': {
                  '0%, 100%': { transform: 'scale(1)' },
                  '50%': { transform: 'scale(1.05)' },
                },
              }}
            >
              <RecyclingOutlined sx={{ fontSize: 28, color: 'white' }} />
            </Box>
            <Box>
              <Typography variant="h6" sx={{ fontWeight: 700, mb: 0.5 }}>
                Smart Recycling
              </Typography>
              <Typography variant="caption" sx={{ opacity: 0.9, fontSize: 12 }}>
                AI-Powered Sorting System
              </Typography>
            </Box>
          </Box>
          {isMobile && (
            <IconButton color="inherit" onClick={handleDrawerToggle}>
              <CloseIcon />
            </IconButton>
          )}
        </Box>
      </Box>

      {/* Status Indicators */}
      <Box sx={{ position: 'relative', zIndex: 1, p: 2 }}>
        <Box sx={{ mb: 2 }}>
          <Chip
            label="Expert System Active"
            sx={{
              background: 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)',
              color: 'white',
              fontWeight: 600,
              width: '100%',
              height: 40,
              fontSize: '0.875rem',
              '& .MuiChip-label': { px: 2 },
            }}
          />
        </Box>
        
        <Box
          sx={{
            background: 'rgba(255,255,255,0.9)',
            borderRadius: 2,
            p: 2,
            boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(255,255,255,0.2)',
          }}
        >
          <Typography variant="caption" color="text.secondary" gutterBottom display="block">
            CNN Model v3.93 Performance
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 700, color: 'primary.main', mb: 1 }}>
            94.2%
          </Typography>
          <Box
            sx={{
              height: 8,
              borderRadius: 4,
              background: 'linear-gradient(90deg, #667eea 0%, #764ba2 100%)',
              position: 'relative',
              overflow: 'hidden',
              '&::after': {
                content: '""',
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: 'linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%)',
                animation: 'shimmer 2s infinite',
              },
              '@keyframes shimmer': {
                '0%': { transform: 'translateX(-100%)' },
                '100%': { transform: 'translateX(100%)' },
              },
            }}
          />
        </Box>
      </Box>

      {/* Navigation Menu */}
      <Box sx={{ position: 'relative', zIndex: 1, flex: 1, px: 2 }}>
        <List sx={{ pt: 1 }}>
          {menuItems.map((item, index) => (
            <Grow
              in={mounted}
              timeout={300 + index * 100}
              key={item.text}
            >
              <ListItem disablePadding sx={{ mb: 1 }}>
                <ListItemButton
                  selected={location.pathname === item.path}
                  onClick={() => {
                    navigate(item.path);
                    setMobileOpen(false);
                  }}
                  sx={{
                    borderRadius: 3,
                    py: 1.5,
                    px: 2,
                    position: 'relative',
                    overflow: 'hidden',
                    transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
                    '&.Mui-selected': {
                      background: `linear-gradient(135deg, ${item.color}15 0%, ${item.color}05 100%)`,
                      backdropFilter: 'blur(10px)',
                      border: `1px solid ${item.color}30`,
                      '&::before': {
                        content: '""',
                        position: 'absolute',
                        left: 0,
                        top: 0,
                        bottom: 0,
                        width: 4,
                        background: `linear-gradient(180deg, ${item.color} 0%, ${item.color}80 100%)`,
                        borderRadius: '0 4px 4px 0',
                      },
                      '& .MuiListItemIcon-root': {
                        color: item.color,
                        transform: 'scale(1.1)',
                      },
                      '& .MuiListItemText-primary': {
                        color: item.color,
                        fontWeight: 600,
                      },
                    },
                    '&:hover': {
                      background: `${item.color}08`,
                      transform: 'translateX(4px)',
                      '& .MuiListItemIcon-root': {
                        transform: 'scale(1.05)',
                      },
                    },
                  }}
                >
                  <ListItemIcon
                    sx={{
                      minWidth: 48,
                      transition: 'all 0.3s ease',
                    }}
                  >
                    {item.icon}
                  </ListItemIcon>
                  <ListItemText
                    primary={item.text}
                    primaryTypographyProps={{
                      sx: {
                        fontSize: 14,
                        fontWeight: location.pathname === item.path ? 600 : 500,
                        transition: 'all 0.3s ease',
                      }
                    }}
                  />
                  {location.pathname === item.path && (
                    <Box
                      sx={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        background: item.color,
                        ml: 1,
                        boxShadow: `0 0 12px ${item.color}60`,
                      }}
                    />
                  )}
                </ListItemButton>
              </ListItem>
            </Grow>
          ))}
        </List>
      </Box>

      {/* Footer */}
      <Box sx={{ position: 'relative', zIndex: 1, p: 2, textAlign: 'center' }}>
        <Box
          sx={{
            background: 'rgba(255,255,255,0.9)',
            borderRadius: 2,
            p: 2,
            backdropFilter: 'blur(10px)',
            border: '1px solid rgba(255,255,255,0.2)',
          }}
        >
          <Typography variant="caption" color="text.secondary">
            Version 1.0.0 | Expert System
          </Typography>
          <Typography variant="caption" display="block" color="text.secondary" sx={{ mt: 0.5 }}>
            Real-time Classification
          </Typography>
        </Box>
      </Box>
    </Box>
  );

  return (
    <Box sx={{ display: 'flex', minHeight: '100vh' }}>
      {/* App Bar */}
      <AppBar
        position="fixed"
        elevation={0}
        sx={{
          width: { md: `calc(100% - ${drawerWidth}px)` },
          ml: { md: `${drawerWidth}px` },
          background: 'rgba(255,255,255,0.95)',
          backdropFilter: 'blur(20px)',
          borderBottom: '1px solid rgba(0,0,0,0.05)',
          color: 'text.primary',
        }}
      >
        <Toolbar sx={{ justifyContent: 'space-between' }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <IconButton
              color="inherit"
              edge="start"
              onClick={handleDrawerToggle}
              sx={{ mr: 2, display: { md: 'none' } }}
            >
              <MenuIcon />
            </IconButton>
            <Box>
              <Typography variant="h5" sx={{ fontWeight: 700, color: 'text.primary' }}>
                Smart Recycling Control Center
              </Typography>
              <Typography variant="caption" sx={{ color: 'text.secondary' }}>
                Real-time monitoring and classification system
              </Typography>
            </Box>
          </Box>

          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
            <Tooltip title="Refresh System">
              <IconButton>
                <Refresh />
              </IconButton>
            </Tooltip>
            
            <Tooltip title="Notifications">
              <IconButton>
                <Badge badgeContent={3} color="error">
                  <NotificationsOutlined />
                </Badge>
              </IconButton>
            </Tooltip>
            
            <Chip
              label="SYSTEM ONLINE"
              sx={{
                background: 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)',
                color: 'white',
                fontWeight: 600,
                px: 2,
                animation: 'statusPulse 3s ease-in-out infinite',
                '@keyframes statusPulse': {
                  '0%, 100%': { boxShadow: '0 2px 8px rgba(76, 175, 80, 0.3)' },
                  '50%': { boxShadow: '0 4px 16px rgba(76, 175, 80, 0.5)' },
                },
              }}
            />

            <Avatar
              sx={{
                width: 40,
                height: 40,
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                cursor: 'pointer',
                boxShadow: '0 4px 12px rgba(102, 126, 234, 0.3)',
                transition: 'all 0.3s ease',
                '&:hover': {
                  transform: 'translateY(-2px)',
                  boxShadow: '0 6px 20px rgba(102, 126, 234, 0.4)',
                },
              }}
            >
              BN
            </Avatar>
          </Box>
        </Toolbar>
      </AppBar>

      {/* Navigation Drawer */}
      <Box
        component="nav"
        sx={{ width: { md: drawerWidth }, flexShrink: { md: 0 } }}
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{ keepMounted: true }}
          sx={{
            display: { xs: 'block', md: 'none' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
              border: 'none',
            },
          }}
        >
          {drawer}
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', md: 'block' },
            '& .MuiDrawer-paper': {
              boxSizing: 'border-box',
              width: drawerWidth,
              border: 'none',
            },
          }}
          open
        >
          {drawer}
        </Drawer>
      </Box>

      {/* Main Content - FIXED MARGINS */}
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          width: { md: `calc(100% - ${drawerWidth}px)` },
          minHeight: '100vh',
          background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
          position: 'relative',
          '&::before': {
            content: '""',
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'radial-gradient(circle at 20% 20%, rgba(102, 126, 234, 0.1) 0%, transparent 50%), radial-gradient(circle at 80% 80%, rgba(118, 75, 162, 0.1) 0%, transparent 50%)',
            pointerEvents: 'none',
          },
        }}
      >
        <Toolbar />
        {/* REMOVED CONTAINER AND PADDING - FULL WIDTH */}
        <Box
          sx={{
            position: 'relative',
            zIndex: 1,
            width: '100%',
            margin: 0,
            padding: 0,
          }}
        >
          {children}
        </Box>
      </Box>
    </Box>
  );
};

export default Layout;



FILE: frontend/src/components/System/SystemHealth.tsx
------------------------------------------------------------
Size: 17.3 KB
Encoding: ascii
------------------------------------------------------------
import React, { useState } from 'react';
import {
  Typography,
  Card,
  CardContent,
  Box,
  Grid,
  LinearProgress,
  Chip,
  Alert,
  AlertTitle,
  Button,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  Stack,
} from '@mui/material';
import {
  MonitorHeart,
  Camera,
  Memory,
  NetworkCheck,
  Sensors,
  SmartToy,
  CheckCircle,
  Warning,
  Error,
  Info,
  Refresh,
  Computer,
  Speed,
  Storage,
} from '@mui/icons-material';
import { useSystemHealth } from '../../hooks/useSystemHealth';

const SystemHealth: React.FC = () => {
  const [refreshing, setRefreshing] = useState(false);

  const {
    metrics,
    alerts,
    loading,
    error,
    isConnected,
    healthSummary,
    refresh,
    resolveAlert,
  } = useSystemHealth();

  // Handle manual refresh
  const handleRefresh = async () => {
    setRefreshing(true);
    try {
      await refresh();
    } catch (err) {
      console.error('Refresh failed:', err);
    } finally {
      setRefreshing(false);
    }
  };

  // Handle alert resolution
  const handleResolveAlert = async (alertId: number) => {
    await resolveAlert(alertId);
  };

  const getStatusColor = (isHealthy: boolean) => {
    return isHealthy ? 'success' : 'error';
  };

  const getStatusIcon = (isHealthy: boolean) => {
    return isHealthy ? <CheckCircle /> : <Error />;
  };

  const getAlertSeverityColor = (severity: string) => {
    switch (severity.toLowerCase()) {
      case 'critical':
      case 'error': return 'error';
      case 'warning': return 'warning';
      case 'info': return 'info';
      default: return 'info';
    }
  };

  if (loading && !metrics) {
    return (
      <Box sx={{ p: 3, backgroundColor: '#f5f5f5', minHeight: '100vh' }}>
        <Typography variant="h4" gutterBottom>
          System Health Monitor
        </Typography>
        <LinearProgress />
        <Typography sx={{ mt: 2 }} color="text.secondary">
          Loading system health data...
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3, backgroundColor: '#f5f5f5', minHeight: '100vh' }}>
      {/* Header */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box display="flex" alignItems="center">
            <MonitorHeart sx={{ mr: 2, fontSize: '2rem', color: 'primary.main' }} />
            <Box>
              <Typography variant="h4" sx={{ fontWeight: 600 }}>
                System Health Monitor
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                Real-time component status and system diagnostics
              </Typography>
            </Box>
          </Box>
          <Button
            variant="outlined"
            startIcon={<Refresh />}
            onClick={handleRefresh}
            disabled={refreshing}
          >
            {refreshing ? 'Refreshing...' : 'Refresh'}
          </Button>
        </Box>
      </Paper>

      {/* Connection Status Alert */}
      {!isConnected && (
        <Alert severity="warning" sx={{ mb: 3 }}>
          <AlertTitle>Connection Issues</AlertTitle>
          Real-time updates may be limited. Check network connectivity.
        </Alert>
      )}

      {/* Error Alert */}
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          <AlertTitle>Error</AlertTitle>
          {error}
        </Alert>
      )}

      {/* System Overview */}
      <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
        <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
          System Overview
        </Typography>
        <Grid container spacing={3}>
          <Grid size={{ xs: 12, md: 4 }}>
            <Card variant="outlined" sx={{ textAlign: 'center', p: 2 }}>
              <Typography variant="h3" color="success.main" sx={{ fontWeight: 600 }}>
                {healthSummary.healthyComponents}
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Healthy Components
              </Typography>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, md: 4 }}>
            <Card variant="outlined" sx={{ textAlign: 'center', p: 2 }}>
              <Typography variant="h3" color="warning.main" sx={{ fontWeight: 600 }}>
                {healthSummary.warningComponents}
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Warnings
              </Typography>
            </Card>
          </Grid>
          <Grid size={{ xs: 12, md: 4 }}>
            <Card variant="outlined" sx={{ textAlign: 'center', p: 2 }}>
              <Typography variant="h3" color="error.main" sx={{ fontWeight: 600 }}>
                {healthSummary.errorComponents}
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Critical Issues
              </Typography>
            </Card>
          </Grid>
        </Grid>
      </Paper>

      {/* Active Alerts */}
      {alerts.length > 0 && (
        <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            Active System Alerts ({alerts.length})
          </Typography>
          <Stack spacing={2}>
            {alerts.slice(0, 5).map((alert) => (
              <Alert
                key={alert.id}
                severity={getAlertSeverityColor(alert.severity) as any}
                action={
                  <Button
                    size="small"
                    variant="outlined"
                    onClick={() => handleResolveAlert(alert.id)}
                  >
                    Resolve
                  </Button>
                }
              >
                <Typography variant="subtitle2" sx={{ fontWeight: 600 }}>
                  {alert.component} - {new Date(alert.timestamp).toLocaleString()}
                </Typography>
                <Typography variant="body2">{alert.message}</Typography>
              </Alert>
            ))}
          </Stack>
        </Paper>
      )}

      {/* Component Health Status */}
      {metrics && (
        <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            Component Health Status
          </Typography>
          <Grid container spacing={3}>
            {[
              {
                name: 'CNN Service',
                healthy: metrics.cnnServiceHealthy,
                icon: <SmartToy />,
                details: {
                  'Service Status': metrics.cnnServiceHealthy ? 'Running' : 'Offline',
                  'Processing Speed': `${metrics.avgProcessingTimeMs.toFixed(0)}ms`,
                  'Items Processed': metrics.totalItemsProcessed.toString(),
                  'Accuracy Rate': `${(metrics.accuracyRate * 100).toFixed(1)}%`,
                }
              },
              {
                name: 'Expert System',
                healthy: metrics.expertSystemHealthy,
                icon: <SmartToy />,
                details: {
                  'System Status': metrics.expertSystemHealthy ? 'Active' : 'Inactive',
                  'Integration': metrics.expertSystemHealthy ? 'Connected' : 'Disconnected',
                  'Last Update': new Date(metrics.timestamp).toLocaleString(),
                }
              },
              {
                name: 'Camera System',
                healthy: metrics.cameraConnected,
                icon: <Camera />,
                details: {
                  'Connection': metrics.cameraConnected ? 'Connected' : 'Disconnected',
                  'Status': metrics.cameraConnected ? 'Operational' : 'No Signal',
                }
              },
              {
                name: 'Sensor Array',
                healthy: metrics.arduinoConnected,
                icon: <Sensors />,
                details: {
                  'Connection': metrics.arduinoConnected ? 'Connected' : 'Disconnected',
                  'Status': metrics.arduinoConnected ? 'All sensors active' : 'No data',
                }
              },
            ].map((component, index) => (
              <Grid size={{ xs: 12, md: 6 }} key={index}>
                <Card variant="outlined">
                  <CardContent>
                    <Box display="flex" alignItems="center" justifyContent="space-between" mb={2}>
                      <Box display="flex" alignItems="center">
                        <Box sx={{ mr: 2, color: 'primary.main' }}>
                          {component.icon}
                        </Box>
                        <Typography variant="h6" sx={{ fontWeight: 600 }}>
                          {component.name}
                        </Typography>
                      </Box>
                      <Chip
                        label={component.healthy ? 'Healthy' : 'Issues'}
                        color={getStatusColor(component.healthy)}
                        icon={getStatusIcon(component.healthy)}
                        variant="outlined"
                      />
                    </Box>
                    
                    <Table size="small">
                      <TableBody>
                        {Object.entries(component.details).map(([key, value]) => (
                          <TableRow key={key}>
                            <TableCell sx={{ fontWeight: 600, border: 'none', py: 0.5 }}>
                              {key}
                            </TableCell>
                            <TableCell sx={{ border: 'none', py: 0.5 }}>
                              {value}
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </CardContent>
                </Card>
              </Grid>
            ))}
          </Grid>
        </Paper>
      )}

      {/* Performance Summary */}
      {metrics && (
        <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            Performance Summary
          </Typography>
          <Grid container spacing={3}>
            <Grid size={{ xs: 12, md: 3 }}>
              <Card variant="outlined">
                <CardContent sx={{ textAlign: 'center' }}>
                  <Box display="flex" alignItems="center" justifyContent="center" mb={1}>
                    <Computer color="primary" sx={{ mr: 1 }} />
                    <Typography variant="h5" sx={{ fontWeight: 600 }}>
                      {metrics.systemUptime.toFixed(1)}h
                    </Typography>
                  </Box>
                  <Typography variant="body2" color="text.secondary">
                    System Uptime
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 12, md: 3 }}>
              <Card variant="outlined">
                <CardContent sx={{ textAlign: 'center' }}>
                  <Box display="flex" alignItems="center" justifyContent="center" mb={1}>
                    <Speed color="primary" sx={{ mr: 1 }} />
                    <Typography variant="h5" sx={{ fontWeight: 600 }}>
                      {metrics.avgProcessingTimeMs.toFixed(0)}ms
                    </Typography>
                  </Box>
                  <Typography variant="body2" color="text.secondary">
                    Avg Response Time
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 12, md: 3 }}>
              <Card variant="outlined">
                <CardContent sx={{ textAlign: 'center' }}>
                  <Box display="flex" alignItems="center" justifyContent="center" mb={1}>
                    <CheckCircle color="success" sx={{ mr: 1 }} />
                    <Typography variant="h5" sx={{ fontWeight: 600 }}>
                      {(metrics.accuracyRate * 100).toFixed(1)}%
                    </Typography>
                  </Box>
                  <Typography variant="body2" color="text.secondary">
                    Classification Accuracy
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 12, md: 3 }}>
              <Card variant="outlined">
                <CardContent sx={{ textAlign: 'center' }}>
                  <Box display="flex" alignItems="center" justifyContent="center" mb={1}>
                    <Info color="info" sx={{ mr: 1 }} />
                    <Typography variant="h5" sx={{ fontWeight: 600 }}>
                      {metrics.totalItemsProcessed.toLocaleString()}
                    </Typography>
                  </Box>
                  <Typography variant="body2" color="text.secondary">
                    Total Items Processed
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </Paper>
      )}

      {/* System Resource Usage */}
      {metrics && (
        <Paper sx={{ p: 3, mb: 3, backgroundColor: 'white' }} elevation={1}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            System Resource Usage
          </Typography>
          <Grid container spacing={3}>
            <Grid size={{ xs: 12, md: 6 }}>
              <Card variant="outlined">
                <CardContent>
                  <Box display="flex" alignItems="center" mb={2}>
                    <Memory sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="h6" sx={{ fontWeight: 600 }}>
                      Memory Usage
                    </Typography>
                  </Box>
                  <Typography variant="h4" sx={{ fontWeight: 600, mb: 1 }}>
                    {(metrics.memoryUsageMB / 1024).toFixed(1)} GB
                  </Typography>
                  <LinearProgress 
                    variant="determinate" 
                    value={Math.min((metrics.memoryUsageMB / 16384) * 100, 100)} // Assuming 16GB max
                    sx={{ mb: 1, height: 8 }}
                  />
                  <Typography variant="body2" color="text.secondary">
                    {metrics.memoryUsageMB.toFixed(0)} MB used of available memory
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
            <Grid size={{ xs: 12, md: 6 }}>
              <Card variant="outlined">
                <CardContent>
                  <Box display="flex" alignItems="center" mb={2}>
                    <Storage sx={{ mr: 1, color: 'primary.main' }} />
                    <Typography variant="h6" sx={{ fontWeight: 600 }}>
                      CPU Usage
                    </Typography>
                  </Box>
                  <Typography variant="h4" sx={{ fontWeight: 600, mb: 1 }}>
                    {metrics.cpuUsagePercent.toFixed(1)}%
                  </Typography>
                  <LinearProgress 
                    variant="determinate" 
                    value={Math.min(metrics.cpuUsagePercent, 100)}
                    sx={{ mb: 1, height: 8 }}
                    color={metrics.cpuUsagePercent > 80 ? 'error' : 'primary'}
                  />
                  <Typography variant="body2" color="text.secondary">
                    Current CPU utilization
                  </Typography>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </Paper>
      )}

      {/* Classification Counts */}
      {metrics && Object.keys(metrics.classificationCounts).length > 0 && (
        <Paper sx={{ p: 3, backgroundColor: 'white' }} elevation={1}>
          <Typography variant="h6" gutterBottom sx={{ fontWeight: 600 }}>
            Recent Classification Activity
          </Typography>
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600 }}>Material Type</TableCell>
                  <TableCell align="right" sx={{ fontWeight: 600 }}>Count</TableCell>
                  <TableCell sx={{ fontWeight: 600 }}>Activity</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {Object.entries(metrics.classificationCounts).map(([category, count]) => {
                  const total = Object.values(metrics.classificationCounts).reduce((a, b) => a + b, 0);
                  const percentage = total > 0 ? (count / total) * 100 : 0;
                  
                  return (
                    <TableRow key={category}>
                      <TableCell>{category}</TableCell>
                      <TableCell align="right">{count.toLocaleString()}</TableCell>
                      <TableCell>
                        <Box sx={{ width: '100%', maxWidth: 200 }}>
                          <LinearProgress 
                            variant="determinate" 
                            value={percentage} 
                            sx={{ height: 6 }}
                          />
                        </Box>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
        </Paper>
      )}
    </Box>
  );
};

export default SystemHealth;



FILE: frontend/src/hooks/useApi.ts
------------------------------------------------------------
Size: 1.3 KB
Encoding: ascii
------------------------------------------------------------
import { useState, useEffect, useCallback } from 'react';
import { api } from '../services/api';

interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export const useApi = <T>(
  apiCall: () => Promise<T>,
  dependencies: React.DependencyList = []
) => {
  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  const fetchData = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const data = await apiCall();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'An error occurred',
      });
    }
  }, dependencies);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    ...state,
    refetch: fetchData,
  };
};

export const useDashboardStats = (refreshInterval = 30000) => {
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  const result = useApi(
    () => api.getDashboardStats(),
    [refreshTrigger]
  );

  useEffect(() => {
    const interval = setInterval(() => {
      setRefreshTrigger(prev => prev + 1);
    }, refreshInterval);

    return () => clearInterval(interval);
  }, [refreshInterval]);

  return result;
};



FILE: frontend/src/hooks/useSignalR.ts
------------------------------------------------------------
Size: 15.6 KB
Encoding: ascii
------------------------------------------------------------
import { useState, useEffect, useCallback, useRef } from 'react';
import signalRService from '../services/signalr';
import { 
  ClassificationResult, 
  ClassificationTriggeredMessage,
  SystemAlert,
  DashboardUpdate,
  SystemStats,
  SystemHealth 
} from '../types';

interface SignalRState {
  connected: {
    classification: boolean;
    dashboard: boolean;
  };
  connectionAttempts: number;
  lastConnectionTime: Date | null;
  latestClassification: ClassificationResult | null;
  latestTrigger: ClassificationTriggeredMessage | null;
  latestAlert: SystemAlert | null;
  latestDashboardUpdate: DashboardUpdate | null;
  stats: SystemStats;
  health: SystemHealth;
  isLoading: boolean;
  error: string | null;
}

// Default values using ACTUAL backend model property names
const defaultStats: SystemStats = {
  TotalItems: 0,
  AccuracyRate: 0,
  AvgProcessingTime: 0,
  ClassificationBreakdown: {},
  OverrideRate: 0,
  ItemsToday: 0,
  ItemsThisWeek: 0,
  ItemsThisMonth: 0,
  LastClassification: new Date(),
  HourlyBreakdown: []
};

const defaultHealth: SystemHealth = {
  Timestamp: new Date(),
  CameraConnected: false,
  ArduinoConnected: false,
  CnnServiceHealthy: false,
  ExpertSystemHealthy: false,
  AvgProcessingTimeMs: 0,
  TotalItemsProcessed: 0,
  AccuracyRate: 0,
  ClassificationCounts: {},
  SystemUptime: 0,
  MemoryUsageMB: 0,
  CpuUsagePercent: 0,
  isHealthy: false
};

export const useSignalR = () => {
  const [state, setState] = useState<SignalRState>({
    connected: {
      classification: false,
      dashboard: false,
    },
    connectionAttempts: 0,
    lastConnectionTime: null,
    latestClassification: null,
    latestTrigger: null,
    latestAlert: null,
    latestDashboardUpdate: null,
    stats: defaultStats,
    health: defaultHealth,
    isLoading: true,
    error: null,
  });

  const initializationRef = useRef<{
    initialized: boolean;
    initPromise: Promise<void> | null;
    cleanup: (() => Promise<void>) | null;
  }>({
    initialized: false,
    initPromise: null,
    cleanup: null
  });

  const reconnectTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const connectionCheckInterval = useRef<NodeJS.Timeout | undefined>(undefined);

  // Connection state change handler with improved error handling
  const handleConnectionStateChange = useCallback((connected: boolean, hubName: string) => {
    console.log(`useSignalR: ${hubName} hub connection state changed:`, connected);
    
    setState(prev => {
      const newConnectedState = {
        ...prev.connected,
        [hubName]: connected,
      };
      
      const isFullyConnected = newConnectedState.classification && newConnectedState.dashboard;
      
      return {
        ...prev,
        connected: newConnectedState,
        lastConnectionTime: connected ? new Date() : prev.lastConnectionTime,
        error: !isFullyConnected && !prev.isLoading ? 
          `Connection issue: ${hubName} hub ${connected ? 'connected' : 'disconnected'}` : 
          null,
        isLoading: false,
      };
    });

    if (connected) {
      console.log(`useSignalR: ${hubName} hub connected successfully`);
    } else {
      console.log(`useSignalR: ${hubName} hub disconnected`);
    }
  }, []);

  // Classification result handler with better data processing
  const handleClassificationResult = useCallback((result: any) => {
    try {
      // Handle both ClassificationResult and ClassificationResponseDto formats
      const classification: ClassificationResult = {
        id: result.Id || result.id || 0,
        timestamp: result.Timestamp || result.timestamp || new Date(),
        finalClassification: result.FinalClassification || result.finalClassification || 'unknown',
        finalConfidence: result.FinalConfidence || result.finalConfidence || 0,
        disposalLocation: result.DisposalLocation || result.disposalLocation || 'unknown',
        processingTime: result.ProcessingTimeMs || result.processingTime || 0,
        isOverridden: result.IsOverridden || result.isOverridden || false,
        validationResults: result.ValidationResults || result.validationResults,
        // Add additional properties with safe defaults
        cnnPredictedClass: result.CnnPredictedClass || result.cnnPredictedClass,
        cnnConfidence: result.CnnConfidence || result.cnnConfidence,
        weightGrams: result.WeightGrams || result.weightGrams || 0,
        reasoning: result.Reasoning || result.reasoning
      };

      setState(prev => ({
        ...prev,
        latestClassification: classification,
      }));
    } catch (error) {
      console.error('Error processing classification result:', error);
    }
  }, []);

  // Dashboard update handler with improved data processing
  const handleDashboardUpdate = useCallback((update: DashboardUpdate) => {
    try {
      setState(prev => {
        const newState = {
          ...prev,
          latestDashboardUpdate: update,
        };

        // Handle different types of dashboard updates
        switch (update.type) {
          case 'stats':
            newState.stats = {
              ...defaultStats,
              ...update.data,
            };
            break;
        
          case 'status':
          case 'initial_status':
            if (update.data?.HealthMetrics) {
              const healthData = update.data.HealthMetrics;
              newState.health = {
                ...defaultHealth,
                ...healthData,
                isHealthy: healthData.CnnServiceHealthy && 
                          healthData.ExpertSystemHealthy && 
                          healthData.CameraConnected && 
                          healthData.ArduinoConnected
              };
            }
            if (update.data?.Stats) {
              newState.stats = {
                ...defaultStats,
                ...update.data.Stats,
              };
            }
            break;
        
          case 'alert':
            newState.latestAlert = update.data;
            break;

          case 'classification':
            if (update.data) {
              newState.latestClassification = update.data;
            }
            break;
        }

        console.error(update);
        console.error("new state", newState);
        return newState;
      });
    } catch (error) {
      console.error('Error processing dashboard update:', error);
    }
  }, []);

  // System alert handler
  const handleSystemAlert = useCallback((alert: SystemAlert) => {
    setState(prev => ({
      ...prev,
      latestAlert: alert,
    }));
  }, []);

  // Classification triggered handler  
  const handleClassificationTriggered = useCallback((data: ClassificationTriggeredMessage) => {
    setState(prev => ({
      ...prev,
      latestTrigger: data,
    }));
  }, []);

  // Initialize connections with better state management
  const initializeConnections = useCallback(async (): Promise<void> => {
    // Prevent multiple initializations
    if (initializationRef.current.initialized) {
      console.log('useSignalR: Already initialized, skipping...');
      return;
    }

    // Return existing promise if initialization is in progress
    if (initializationRef.current.initPromise) {
      console.log('useSignalR: Initialization in progress, waiting...');
      return initializationRef.current.initPromise;
    }

    // Create initialization promise
    initializationRef.current.initPromise = (async () => {
      try {
        setState(prev => ({
          ...prev,
          connectionAttempts: prev.connectionAttempts + 1,
          isLoading: true,
          error: null,
        }));

        console.log('useSignalR: Setting up event handlers...');
        
        // Set up event handlers before connecting
        signalRService.onConnectionStateChange(handleConnectionStateChange);
        signalRService.onClassificationResultReceived(handleClassificationResult);
        signalRService.onClassificationTriggeredReceived(handleClassificationTriggered);
        signalRService.onSystemAlertReceived(handleSystemAlert);
        signalRService.onDashboardUpdateReceived(handleDashboardUpdate);

        console.log('useSignalR: Starting connection process...');

        // Start connections with improved error handling
        const connectionResults = await Promise.allSettled([
          signalRService.startClassificationHub(),
          signalRService.startDashboardHub()
        ]);

        // Check if at least one connection succeeded
        const hasConnection = connectionResults.some(result => result.status === 'fulfilled');
        
        if (!hasConnection) {
          throw new Error('Failed to establish any SignalR connections');
        }

        // Check connection health
        const healthCheck = await signalRService.checkConnectionHealth();
        console.log('useSignalR: Connection health check:', healthCheck);

        initializationRef.current.initialized = true;

        // Request initial data after connections are stable
        setTimeout(async () => {
          try {
            if (signalRService.dashboardConnected) {
              console.log('useSignalR: Requesting initial data...');
              await requestSystemStatus();
              await requestStats();
              console.log('useSignalR: Initial data requests completed');
            } else {
              console.warn('useSignalR: Dashboard hub not ready for initial data requests');
            }
          } catch (error) {
            console.error('useSignalR: Failed to request initial data:', error);
            setState(prev => ({
              ...prev,
              error: 'Failed to load initial data'
            }));
          }
        }, 2000); // Reduced delay

      } catch (error) {
        console.error('useSignalR: Failed to initialize connections:', error);
        setState(prev => ({
          ...prev,
          error: error instanceof Error ? error.message : 'Connection initialization failed',
          isLoading: false,
        }));

        // Schedule reconnect attempt with exponential backoff
        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
        }
        
        const backoffDelay = Math.min(1000 * Math.pow(2, state.connectionAttempts), 30000);
        reconnectTimeoutRef.current = setTimeout(() => {
          console.log('useSignalR: Attempting reconnect...');
          reconnect();
        }, backoffDelay);
      } finally {
        // Clear the promise reference
        initializationRef.current.initPromise = null;
      }
    })();

    return initializationRef.current.initPromise;
  }, [handleConnectionStateChange, handleClassificationResult, handleClassificationTriggered, handleSystemAlert, handleDashboardUpdate, state.connectionAttempts]);

  // Connection health monitoring
  const startConnectionMonitoring = useCallback(() => {
    if (connectionCheckInterval.current) {
      clearInterval(connectionCheckInterval.current);
    }

    connectionCheckInterval.current = setInterval(async () => {
      try {
        const health = await signalRService.checkConnectionHealth();
        
        // Update connection state if there's a mismatch
        setState(prev => {
          const currentState = prev.connected;
          if (currentState.classification !== health.classification || 
              currentState.dashboard !== health.dashboard) {
            console.log('useSignalR: Connection state mismatch detected, updating...');
            return {
              ...prev,
              connected: {
                classification: health.classification,
                dashboard: health.dashboard
              }
            };
          }
          return prev;
        });
      } catch (error) {
        console.error('useSignalR: Connection health check failed:', error);
      }
    }, 15000); // Check every 15 seconds
  }, []);

  // Cleanup function
  const cleanup = useCallback(async () => {
    console.log('useSignalR: Cleaning up...');
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = undefined;
    }

    if (connectionCheckInterval.current) {
      clearInterval(connectionCheckInterval.current);
      connectionCheckInterval.current = undefined;
    }
    
    try {
      await signalRService.stopConnections();
    } catch (error) {
      console.error('useSignalR: Error stopping connections:', error);
    }
    
    // Reset initialization state
    initializationRef.current = {
      initialized: false,
      initPromise: null,
      cleanup: null
    };
  }, []);

  // Effect to initialize connections with proper cleanup
  useEffect(() => {
    console.log('useSignalR: Effect triggered - initializing...');
    
    const init = async () => {
      await initializeConnections();
      startConnectionMonitoring();
    };

    init().catch(console.error);

    // Store cleanup function
    initializationRef.current.cleanup = cleanup;

    // Cleanup on unmount or deps change
    return () => {
      if (initializationRef.current.cleanup) {
        initializationRef.current.cleanup();
      }
    };
  }, []); // Empty dependency array - only run once

  // Manual reconnect function
  const reconnect = useCallback(async () => {
    console.log('useSignalR: Manual reconnect requested...');
    
    // Reset initialization state
    initializationRef.current.initialized = false;
    initializationRef.current.initPromise = null;
    
    await cleanup();
    await initializeConnections();
    startConnectionMonitoring();
  }, [cleanup, initializeConnections, startConnectionMonitoring]);

  const requestSystemStatus = useCallback(async () => {
    try {
      console.log('useSignalR: Requesting system status...');
      await signalRService.requestSystemStatus();
      console.log('useSignalR: System status request completed');
    } catch (error) {
      console.error('useSignalR: Failed to request system status:', error);
      setState(prev => ({
        ...prev,
        error: `Failed to request system status: ${error instanceof Error ? error.message : 'Unknown error'}`,
      }));
      throw error;
    }
  }, []);

  const requestStats = useCallback(async (fromDate?: Date, toDate?: Date) => {
    try {
      console.log('useSignalR: Requesting stats...');
      await signalRService.requestStats(fromDate, toDate);
      console.log('useSignalR: Stats request completed');
    } catch (error) {
      console.error('useSignalR: Failed to request stats:', error);
      setState(prev => ({
        ...prev,
        error: `Failed to request stats: ${error instanceof Error ? error.message : 'Unknown error'}`,
      }));
      throw error;
    }
  }, []);

  // Send manual override
  const sendManualOverride = useCallback(async (
    classificationId: number,
    newClassification: string,
    newDisposalLocation: string,
    reason: string,
    userId: string = 'Dashboard'
  ) => {
    try {
      await signalRService.sendManualOverride(classificationId, newClassification, reason);
    } catch (error) {
      console.error('useSignalR: Failed to send manual override:', error);
      throw error;
    }
  }, []);

  // Connection status getters
  const isFullyConnected = state.connected.classification && state.connected.dashboard;

  return {
    // Connection status
    connected: state.connected,
    isConnected: isFullyConnected,
    connectionAttempts: state.connectionAttempts,
    lastConnectionTime: state.lastConnectionTime,
    isLoading: state.isLoading,
    error: state.error,

    // Data
    latestClassification: state.latestClassification,
    latestTrigger: state.latestTrigger,
    latestAlert: state.latestAlert,
    latestDashboardUpdate: state.latestDashboardUpdate,
    stats: state.stats,
    health: state.health,

    // Actions
    reconnect,
    requestSystemStatus,
    requestStats,
    sendManualOverride,
  };
};



FILE: frontend/src/hooks/useSystemHealth.ts
------------------------------------------------------------
Size: 6.3 KB
Encoding: ascii
------------------------------------------------------------
// frontend/src/hooks/useSystemHealth.ts
import { useState, useEffect, useCallback } from 'react';
import { api } from '../services/api';
import { useSignalR } from './useSignalR';
import { SystemAlert, SystemHealth } from '../types';

interface SystemAlertExtended extends SystemAlert {
  id: number;
  severity: string;
  component: string;
  isResolved: boolean;
}

interface SystemHealthMetrics {
  timestamp: string;
  cameraConnected: boolean;
  arduinoConnected: boolean;
  cnnServiceHealthy: boolean;
  expertSystemHealthy: boolean;
  avgProcessingTimeMs: number;
  totalItemsProcessed: number;
  accuracyRate: number;
  classificationCounts: { [key: string]: number };
  systemUptime: number;
  memoryUsageMB: number;
  cpuUsagePercent: number;
}

interface SystemHealthState {
  metrics: SystemHealthMetrics | null;
  alerts: SystemAlertExtended[];
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
}

export const useSystemHealth = () => {
  const [state, setState] = useState<SystemHealthState>({
    metrics: null,
    alerts: [],
    loading: true,
    error: null,
    lastUpdated: null,
  });

  const {
    health,
    isConnected,
    latestAlert,
    requestSystemStatus,
    error: signalRError
  } = useSignalR();

  // Load initial system health data
  const loadSystemHealth = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }));

      // Try to request real-time status update (with retry built into signalr service)
      try {
        console.log('Requesting system status...');
        await requestSystemStatus();
        console.log('System status request successful');
      } catch (statusError) {
        console.warn('Failed to request system status, continuing with alerts:', statusError);
        // Don't fail completely, just continue with loading alerts
      }

      // Load active alerts (this is an HTTP call, not SignalR)
      console.log('Loading active alerts...');
      const alerts = await api.getActiveAlerts();
      console.log('Active alerts loaded:', alerts.length);
      
      setState(prev => ({
        ...prev,
        alerts: alerts,
        loading: false,
        lastUpdated: new Date(),
      }));

    } catch (err) {
      console.error('Failed to load system health:', err);
      setState(prev => ({
        ...prev,
        error: err instanceof Error ? err.message : 'Failed to load system health',
        loading: false,
      }));
    }
  }, [requestSystemStatus]);

  // Update metrics when health data changes from SignalR
  useEffect(() => {
    if (health) {
      setState(prev => ({
        ...prev,
        metrics: {
          timestamp: health.Timestamp as string,
          cameraConnected: health.CameraConnected,
          arduinoConnected: health.ArduinoConnected,
          cnnServiceHealthy: health.CnnServiceHealthy,
          expertSystemHealthy: health.ExpertSystemHealthy,
          avgProcessingTimeMs: health.AvgProcessingTimeMs,
          totalItemsProcessed: health.TotalItemsProcessed,
          accuracyRate: health.AccuracyRate,
          classificationCounts: health.ClassificationCounts,
          systemUptime: health.SystemUptime,
          memoryUsageMB: health.MemoryUsageMB,
          cpuUsagePercent: health.CpuUsagePercent || 0,
        },
        loading: false,
      }));
    }
  }, [health]);

  // Handle new alerts from SignalR
  useEffect(() => {
    if (latestAlert) {
      const newAlert: SystemAlertExtended = {
        ...latestAlert,
        id: Date.now(), // Temporary ID for new alerts
        severity: latestAlert.level || 'info',
        component: latestAlert.component || latestAlert.source,
        isResolved: false,
      };

      setState(prev => ({
        ...prev,
        alerts: [newAlert, ...prev.alerts.slice(0, 9)], // Keep latest 10
      }));
    }
  }, [latestAlert]);

  // Load data when connection is established
  useEffect(() => {
    if (isConnected) {
      // Add a small delay to ensure connections are fully ready
      const timer = setTimeout(() => {
        console.log('Connection established, loading system health data...');
        loadSystemHealth();
      }, 1000);

      return () => clearTimeout(timer);
    }
  }, [isConnected, loadSystemHealth]);

  // Refresh system health data
  const refresh = useCallback(async () => {
    await loadSystemHealth();
  }, [loadSystemHealth]);

  // Resolve an alert
  const resolveAlert = useCallback(async (alertId: number, resolvedBy: string = 'Dashboard User') => {
    try {
      await api.resolveAlert(alertId, resolvedBy);
      setState(prev => ({
        ...prev,
        alerts: prev.alerts.filter(alert => alert.id !== alertId),
      }));
      return true;
    } catch (err) {
      console.error('Failed to resolve alert:', err);
      setState(prev => ({
        ...prev,
        error: 'Failed to resolve alert',
      }));
      return false;
    }
  }, []);

  // Get system health summary
  const getHealthSummary = useCallback(() => {
    if (!state.metrics) {
      return {
        overallHealthy: false,
        healthyComponents: 0,
        warningComponents: 0,
        errorComponents: 0,
        totalComponents: 0,
      };
    }

    const components = [
      { name: 'CNN Service', healthy: state.metrics.cnnServiceHealthy },
      { name: 'Expert System', healthy: state.metrics.expertSystemHealthy },
      { name: 'Camera', healthy: state.metrics.cameraConnected },
      { name: 'Arduino', healthy: state.metrics.arduinoConnected },
      { name: 'Network', healthy: isConnected },
      { name: 'Memory', healthy: state.metrics.memoryUsageMB < 8000 }, // 8GB threshold
    ];

    const healthyComponents = components.filter(c => c.healthy).length;
    const errorComponents = components.filter(c => !c.healthy).length;
    const warningComponents = 0; // Could add logic for warning states

    return {
      overallHealthy: errorComponents === 0,
      healthyComponents,
      warningComponents,
      errorComponents,
      totalComponents: components.length,
    };
  }, [state.metrics, isConnected]);

  return {
    // State
    metrics: state.metrics,
    alerts: state.alerts,
    loading: state.loading,
    error: state.error || signalRError,
    lastUpdated: state.lastUpdated,
    isConnected,
    
    // Computed values
    healthSummary: getHealthSummary(),
    
    // Actions
    refresh,
    resolveAlert,
  };
};



FILE: frontend/src/index.css
------------------------------------------------------------
Size: 366 B
Encoding: ascii
------------------------------------------------------------
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



FILE: frontend/src/index.tsx
------------------------------------------------------------
Size: 594 B
Encoding: ascii
------------------------------------------------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<App />);


// root.render(
//   <React.StrictMode>
//     <App />
//   </React.StrictMode>
// );

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();



FILE: frontend/src/react-app-env.d.ts
------------------------------------------------------------
Size: 40 B
Encoding: ascii
------------------------------------------------------------
/// <reference types="react-scripts" />



FILE: frontend/src/reportWebVitals.ts
------------------------------------------------------------
Size: 425 B
Encoding: ascii
------------------------------------------------------------
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;



FILE: frontend/src/services/api.ts
------------------------------------------------------------
Size: 4.4 KB
Encoding: ascii
------------------------------------------------------------
import axios from 'axios';
import { ClassificationResult, DashboardStats, SystemStatus, ManualOverrideRequest } from '../types';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5099';

// Create axios instance with default configuration
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for logging
apiClient.interceptors.request.use(
  (config) => {
    console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    console.error('API Request Error:', error);
    return Promise.reject(error);
  }
);

// Add response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    console.error('API Response Error:', error.response?.data || error.message);
    if (error.response?.status === 401) {
      // Handle unauthorized access
      console.warn('Unauthorized access detected');
    }
    return Promise.reject(error);
  }
);

export const api = {
  // Classification endpoints
  getRecentClassifications: async (page = 1, pageSize = 50, filterBy?: string): Promise<{
    items: ClassificationResult[];
    totalCount: number;
    totalPages: number;
  }> => {
    const params = new URLSearchParams({
      page: page.toString(),
      pageSize: pageSize.toString(),
    });
    
    if (filterBy) {
      params.append('filterBy', filterBy);
    }
    
    const response = await apiClient.get(`/api/classification/recent?${params}`);
    return response.data;
  },

  getClassificationById: async (id: number): Promise<ClassificationResult> => {
    const response = await apiClient.get(`/api/classification/${id}`);
    return response.data;
  },

  applyManualOverride: async (request: ManualOverrideRequest): Promise<void> => {
    await apiClient.post('/api/classification/override', request);
  },

  exportClassifications: async (fromDate?: Date, toDate?: Date): Promise<Blob> => {
    const params = new URLSearchParams();
    
    if (fromDate) {
      params.append('fromDate', fromDate.toISOString());
    }
    
    if (toDate) {
      params.append('toDate', toDate.toISOString());
    }
    
    const response = await apiClient.get(`/api/classification/export?${params}`, {
      responseType: 'blob',
    });
    
    return response.data;
  },

  // Dashboard endpoints
  getDashboardStats: async (): Promise<DashboardStats> => {
    const response = await apiClient.get('/api/dashboard/stats');
    return response.data;
  },

  getSystemStatus: async (): Promise<SystemStatus> => {
    const response = await apiClient.get('/api/dashboard/status');
    return response.data;
  },

  getPerformanceMetrics: async (hours = 24): Promise<any> => {
    const response = await apiClient.get(`/api/dashboard/performance?hours=${hours}`);
    return response.data;
  },

  // System Health endpoints - NEW
  getSystemHealth: async (): Promise<any> => {
    const response = await apiClient.get('/api/system/health');
    return response.data;
  },

  getActiveAlerts: async (): Promise<any[]> => {
    const response = await apiClient.get('/api/system/alerts');
    return response.data;
  },

  getSystemMetrics: async (fromDate?: Date): Promise<any> => {
    const params = new URLSearchParams();
    
    if (fromDate) {
      params.append('fromDate', fromDate.toISOString());
    }
    
    const response = await apiClient.get(`/api/system/metrics?${params}`);
    return response.data;
  },

  resolveAlert: async (alertId: number, resolvedBy: string): Promise<void> => {
    await apiClient.post(`/api/system/alerts/${alertId}/resolve`, {
      resolvedBy: resolvedBy
    });
  },

  // Health endpoints
  getHealthCheck: async (): Promise<any> => {
    const response = await apiClient.get('/health');
    return response.data;
  },

  getDetailedHealthCheck: async (): Promise<any> => {
    const response = await apiClient.get('/api/health/detailed');
    return response.data;
  },

  // Statistics
  getStatistics: async (fromDate?: Date, toDate?: Date): Promise<any> => {
    const params = new URLSearchParams();
    
    if (fromDate) {
      params.append('fromDate', fromDate.toISOString());
    }
    
    if (toDate) {
      params.append('toDate', toDate.toISOString());
    }
    
    const response = await apiClient.get(`/api/classification/statistics?${params}`);
    return response.data;
  },
};

export default api;



FILE: frontend/src/services/signalr.ts
------------------------------------------------------------
Size: 15.6 KB
Encoding: ascii
------------------------------------------------------------
import * as signalR from '@microsoft/signalr';
import { 
  ClassificationResult, 
  ClassificationTriggeredMessage,
  SystemAlert,
  DashboardUpdate 
} from '../types';

class SignalRService {
  private classificationConnection: signalR.HubConnection | null = null;
  private dashboardConnection: signalR.HubConnection | null = null;
  private connectionCallbacks: Array<(connected: boolean, hubName: string) => void> = [];
  private classificationCallbacks: Array<(result: ClassificationResult) => void> = [];
  private triggerCallbacks: Array<(data: ClassificationTriggeredMessage) => void> = [];
  private alertCallbacks: Array<(alert: SystemAlert) => void> = [];
  private dashboardCallbacks: Array<(update: DashboardUpdate) => void> = [];

  private readonly baseUrl = process.env.REACT_APP_API_URL || 'http://localhost:5099';
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private connectionTimeout = 15000; // Increased timeout
  private isConnecting = false; // Prevent multiple connection attempts

  // Classification Hub Connection with better state management
  async startClassificationHub(): Promise<void> {
    if (this.classificationConnection?.state === signalR.HubConnectionState.Connected) {
      console.log('Classification hub already connected');
      return;
    }

    if (this.isConnecting) {
      console.log('Classification hub connection already in progress');
      return;
    }

    this.isConnecting = true;

    try {
      // Clean up any existing connection
      if (this.classificationConnection) {
        await this.cleanupConnection(this.classificationConnection);
        this.classificationConnection = null;
      }

      // Create connection with improved configuration
      this.classificationConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${this.baseUrl}/hubs/classification`, {
          transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling,
          skipNegotiation: false,
          timeout: this.connectionTimeout,
          headers: {
            'Access-Control-Allow-Origin': '*',
          },
          // Add access token if needed
          // accessTokenFactory: () => this.getAccessToken()
        })
        .withAutomaticReconnect([0, 1000, 5000, 15000, 30000])
        .withHubProtocol(new signalR.JsonHubProtocol())
        .configureLogging(signalR.LogLevel.Information)
        .build();

      // Setup event handlers before starting connection
      this.setupClassificationEventHandlers();

      // Start connection
      await this.classificationConnection.start();

      console.log('Classification hub connected successfully');
      this.connectionCallbacks.forEach(callback => callback(true, 'classification'));
      this.reconnectAttempts = 0;
      
      // Join the classification group with retry logic
      await this.joinClassificationGroupWithRetry();
      
    } catch (error) {
      console.error('Failed to connect to classification hub:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'classification'));
      
      // Cleanup failed connection
      if (this.classificationConnection) {
        await this.cleanupConnection(this.classificationConnection);
        this.classificationConnection = null;
      }
      
      throw error;
    } finally {
      this.isConnecting = false;
    }
  }

  // Dashboard Hub Connection with improved error handling  
  async startDashboardHub(): Promise<void> {
    if (this.dashboardConnection?.state === signalR.HubConnectionState.Connected) {
      console.log('Dashboard hub already connected');
      return;
    }

    try {
      // Clean up any existing connection
      if (this.dashboardConnection) {
        await this.cleanupConnection(this.dashboardConnection);
        this.dashboardConnection = null;
      }

      this.dashboardConnection = new signalR.HubConnectionBuilder()
        .withUrl(`${this.baseUrl}/hubs/dashboard`, {
          transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling,
          skipNegotiation: false,
          timeout: this.connectionTimeout,
          headers: {
            'Access-Control-Allow-Origin': '*',
          },
        })
        .withAutomaticReconnect([0, 1000, 5000, 15000, 30000])
        .withHubProtocol(new signalR.JsonHubProtocol())
        .configureLogging(signalR.LogLevel.Information)
        .build();

      // Setup event handlers before starting connection
      this.setupDashboardEventHandlers();

      // Start connection
      await this.dashboardConnection.start();

      console.log('Dashboard hub connected successfully');
      this.connectionCallbacks.forEach(callback => callback(true, 'dashboard'));
      
      // Join the dashboard group with retry logic
      await this.joinDashboardGroupWithRetry();
      
    } catch (error) {
      console.error('Failed to connect to dashboard hub:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'dashboard'));
      
      // Cleanup failed connection
      if (this.dashboardConnection) {
        await this.cleanupConnection(this.dashboardConnection);
        this.dashboardConnection = null;
      }
      
      throw error;
    }
  }

  // Helper method to properly cleanup connections
  private async cleanupConnection(connection: signalR.HubConnection): Promise<void> {
    try {
      if (connection.state === signalR.HubConnectionState.Connected || 
          connection.state === signalR.HubConnectionState.Connecting ||
          connection.state === signalR.HubConnectionState.Reconnecting) {
        await connection.stop();
      }
    } catch (error) {
      console.warn('Error cleaning up connection:', error);
    }
  }

  // Improved event handler setup for classification hub
  private setupClassificationEventHandlers(): void {
    if (!this.classificationConnection) return;

    // Remove any existing handlers to prevent duplicates
    this.classificationConnection.off('ClassificationResult');
    this.classificationConnection.off('ClassificationTriggered');
    this.classificationConnection.off('SystemAlert');
    this.classificationConnection.off('Connected');
    this.classificationConnection.off('JoinedClassificationGroup');

    // Event handlers for classification hub
    this.classificationConnection.on('ClassificationResult', (result: ClassificationResult) => {
      console.log('Received classification result:', result);
      this.classificationCallbacks.forEach(callback => callback(result));
    });

    this.classificationConnection.on('ClassificationTriggered', (data: ClassificationTriggeredMessage) => {
      console.log('Classification triggered:', data);
      this.triggerCallbacks.forEach(callback => callback(data));
    });

    this.classificationConnection.on('SystemAlert', (alert: SystemAlert) => {
      console.log('System alert:', alert);
      this.alertCallbacks.forEach(callback => callback(alert));
    });

    this.classificationConnection.on('Connected', (data: any) => {
      console.log('Classification hub connected:', data);
    });

    this.classificationConnection.on('JoinedClassificationGroup', (data: any) => {
      console.log('Joined classification group:', data);
    });

    // Connection state handlers with better error handling
    this.classificationConnection.onclose((error) => {
      console.log('Classification hub connection closed:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'classification'));
    });

    this.classificationConnection.onreconnecting((error) => {
      console.log('Classification hub reconnecting:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'classification'));
    });

    this.classificationConnection.onreconnected((connectionId) => {
      console.log('Classification hub reconnected:', connectionId);
      this.connectionCallbacks.forEach(callback => callback(true, 'classification'));
      // Re-join group after reconnection
      this.joinClassificationGroupWithRetry();
    });
  }

  // Improved event handler setup for dashboard hub
  private setupDashboardEventHandlers(): void {
    if (!this.dashboardConnection) return;

    // Remove any existing handlers to prevent duplicates
    this.dashboardConnection.off('DashboardUpdate');
    this.dashboardConnection.off('SystemStatusUpdate');
    this.dashboardConnection.off('StatsUpdate');
    this.dashboardConnection.off('Connected');
    this.dashboardConnection.off('JoinedDashboardGroup');

    // Event handlers for dashboard hub
    this.dashboardConnection.on('DashboardUpdate', (update: DashboardUpdate) => {
      console.log('Dashboard update received:', update);
      this.dashboardCallbacks.forEach(callback => callback(update));
    });

    this.dashboardConnection.on('SystemStatusUpdate', (status: any) => {
      console.log('System status update:', status);
      this.dashboardCallbacks.forEach(callback => 
        callback({
          type: 'status',
          data: status,
          timestamp: new Date().toISOString(),
        })
      );
    });

    this.dashboardConnection.on('StatsUpdate', (stats: any) => {
      console.log('Stats update:', stats);
      this.dashboardCallbacks.forEach(callback => 
        callback({
          type: 'stats',
          data: stats,
          timestamp: new Date().toISOString(),
        })
      );
    });

    this.dashboardConnection.on('Connected', (data: any) => {
      console.log('Dashboard hub connected:', data);
    });

    this.dashboardConnection.on('JoinedDashboardGroup', (data: any) => {
      console.log('Joined dashboard group:', data);
    });

    // Connection state handlers
    this.dashboardConnection.onclose((error) => {
      console.log('Dashboard hub connection closed:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'dashboard'));
    });

    this.dashboardConnection.onreconnecting((error) => {
      console.log('Dashboard hub reconnecting:', error);
      this.connectionCallbacks.forEach(callback => callback(false, 'dashboard'));
    });

    this.dashboardConnection.onreconnected((connectionId) => {
      console.log('Dashboard hub reconnected:', connectionId);
      this.connectionCallbacks.forEach(callback => callback(true, 'dashboard'));
      // Re-join group after reconnection
      this.joinDashboardGroupWithRetry();
    });
  }

  // Helper methods for joining groups with retry logic
  private async joinClassificationGroupWithRetry(maxRetries = 3): Promise<void> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        if (this.classificationConnection?.state === signalR.HubConnectionState.Connected) {
          await this.classificationConnection.invoke('JoinClassificationGroup');
          console.log('Successfully joined classification group');
          return;
        } else {
          throw new Error('Connection not ready');
        }
      } catch (error) {
        console.error(`Failed to join classification group (attempt ${attempt}/${maxRetries}):`, error);
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
        }
      }
    }
    console.error('Failed to join classification group after all attempts');
  }

  private async joinDashboardGroupWithRetry(maxRetries = 3): Promise<void> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        if (this.dashboardConnection?.state === signalR.HubConnectionState.Connected) {
          await this.dashboardConnection.invoke('JoinDashboardGroup');
          console.log('Successfully joined dashboard group');
          return;
        } else {
          throw new Error('Connection not ready');
        }
      } catch (error) {
        console.error(`Failed to join dashboard group (attempt ${attempt}/${maxRetries}):`, error);
        if (attempt < maxRetries) {
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
        }
      }
    }
    console.error('Failed to join dashboard group after all attempts');
  }

  // Public methods to request data with connection state validation
  async requestSystemStatus(): Promise<void> {
    if (this.dashboardConnection?.state !== signalR.HubConnectionState.Connected) {
      throw new Error('Dashboard hub not connected');
    }

    try {
      await this.dashboardConnection.invoke('RequestSystemStatus');
      console.log('System status requested successfully');
    } catch (error) {
      console.error('Failed to request system status:', error);
      throw error;
    }
  }

  async requestStats(fromDate?: Date, toDate?: Date): Promise<void> {
    if (this.dashboardConnection?.state !== signalR.HubConnectionState.Connected) {
      throw new Error('Dashboard hub not connected');
    }

    try {
      await this.dashboardConnection.invoke('RequestStats', fromDate, toDate);
      console.log('Stats requested successfully');
    } catch (error) {
      console.error('Failed to request stats:', error);
      throw error;
    }
  }

  // Stop both connections with proper cleanup
  async stopConnections(): Promise<void> {
    const promises: Promise<void>[] = [];

    if (this.classificationConnection) {
      promises.push(this.cleanupConnection(this.classificationConnection));
    }

    if (this.dashboardConnection) {
      promises.push(this.cleanupConnection(this.dashboardConnection));
    }

    try {
      await Promise.allSettled(promises);
    } catch (error) {
      console.error('Error stopping connections:', error);
    } finally {
      this.classificationConnection = null;
      this.dashboardConnection = null;
      console.log('All SignalR connections stopped');
    }
  }

  // Event subscribers
  onClassificationResultReceived(callback: (result: ClassificationResult) => void): void {
    this.classificationCallbacks.push(callback);
  }

  onClassificationTriggeredReceived(callback: (data: ClassificationTriggeredMessage) => void): void {
    this.triggerCallbacks.push(callback);
  }

  onSystemAlertReceived(callback: (alert: SystemAlert) => void): void {
    this.alertCallbacks.push(callback);
  }

  onDashboardUpdateReceived(callback: (update: DashboardUpdate) => void): void {
    this.dashboardCallbacks.push(callback);
  }

  onConnectionStateChange(callback: (connected: boolean, hubName: string) => void): void {
    this.connectionCallbacks.push(callback);
  }

  // Send methods
  async sendManualOverride(classificationId: number, newClassification: string, reason: string): Promise<void> {
    if (!this.classificationConnection || this.classificationConnection.state !== signalR.HubConnectionState.Connected) {
      throw new Error('Classification hub not connected');
    }

    await this.classificationConnection.invoke('SendManualOverride', {
      classificationId,
      newClassification,
      reason,
      timestamp: new Date().toISOString(),
    });
  }

  // Connection status getters with improved reliability
  get classificationConnected(): boolean {
    return this.classificationConnection?.state === signalR.HubConnectionState.Connected;
  }

  get dashboardConnected(): boolean {
    return this.dashboardConnection?.state === signalR.HubConnectionState.Connected;
  }

  get isConnected(): boolean {
    return this.classificationConnected && this.dashboardConnected;
  }

  // Connection health check method
  async checkConnectionHealth(): Promise<{ classification: boolean; dashboard: boolean }> {
    const classificationHealthy = this.classificationConnected;
    const dashboardHealthy = this.dashboardConnected;

    return {
      classification: classificationHealthy,
      dashboard: dashboardHealthy
    };
  }
}

// Singleton instance
const signalRService = new SignalRService();
export default signalRService;



FILE: frontend/src/setupTests.ts
------------------------------------------------------------
Size: 241 B
Encoding: ascii
------------------------------------------------------------
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';



FILE: frontend/src/types/index.ts
------------------------------------------------------------
Size: 7.5 KB
Encoding: ascii
------------------------------------------------------------
// Classification related types - Unified interface for all uses
export interface ClassificationResult {
  id: number;
  timestamp: string | Date;
  finalClassification: string;
  finalConfidence: number;
  disposalLocation: string;
  processingTime: number;
  isOverridden: boolean;
  validationResults?: { [key: string]: any };
  overrideReason?: string;
  overriddenBy?: string;
  overrideClassification?: string;
  overrideTimestamp?: string | Date;
  
  // Additional properties from your backend model
  cnnPredictedClass?: string;
  cnnConfidence?: number;
  cnnStage?: number;
  processingTimeMs?: number;
  weightGrams?: number;
  isMetalDetected?: boolean;
  humidityPercent?: number;
  temperatureCelsius?: number;
  isMoist?: boolean;
  isTransparent?: boolean;
  isFlexible?: boolean;
  reasoning?: string;
  candidatesCount?: number;
  
  // Properties expected by ClassificationHistory component
  cnnStage1Class?: string;
  cnnStage1Confidence?: number;
  cnnStage2Class?: string;
  cnnStage2Confidence?: number;
  sensorValidation?: SensorValidationResult;
  decisionPath?: string;
  imageUrl?: string;
  overrideInfo?: ManualOverrideInfo;
}

export interface SensorValidationResult {
  weight: 'pass' | 'fail';
  metal: 'pass' | 'fail';
  humidity: 'pass' | 'fail';
  ir_spectroscopy: 'pass' | 'fail';
}

export interface ManualOverrideInfo {
  isOverridden: boolean;
  originalClassification?: string;
  reason?: string;
  overriddenBy?: string;
  overrideTimestamp?: string;
}

export interface ClassificationRequest {
  imageData?: string;
  sensorData?: SensorData;
  timestamp: string;
  triggeredBy: 'sensor' | 'manual' | 'system';
}

export interface SensorData {
  weightGrams: number;
  isMetalDetected: boolean;
  humidityPercent: number;
  temperatureCelsius: number;
  isMoist: boolean;
  isTransparent: boolean;
  isFlexible: boolean;
  irTransparency: number;
}

export interface IRSpectroscopyData {
  wavelengths: number[];
  absorption: number[];
  detectedMaterials: string[];
  confidence: number;
}

// Hub communication types
export interface ClassificationTriggeredMessage {
  triggeredBy: 'sensor' | 'manual';
  sensorData?: SensorData;
  timestamp: string;
}

export interface SystemAlert {
  level: 'info' | 'warning' | 'error';
  severity?: string;
  message: string;
  timestamp: string;
  source: string;
  component?: string;
}

export interface DashboardUpdate {
  type: 'stats' | 'status' | 'alert' | 'initial_status' | 'recent_classifications' | 'classification';
  data: any;
  timestamp: string;
  dateRange?: {
    from: Date;
    to: Date;
  };
}

// System statistics types - Using ACTUAL backend model names
export interface SystemStats {
  TotalItems: number;
  AccuracyRate: number;
  AvgProcessingTime: number;
  ClassificationBreakdown: { [key: string]: number };
  OverrideRate: number;
  ItemsToday: number;
  ItemsThisWeek: number;
  ItemsThisMonth: number;
  LastClassification: Date | string;
  HourlyBreakdown: HourlyStats[];
}

export interface HourlyStats {
  Hour: Date | string;
  Count: number;
  AvgAccuracy: number;
}

export interface DashboardStats {
  totalItemsProcessed: number;
  currentAccuracy: number;
  averageProcessingTime: number;
  systemHealth: number;
  todayStats: {
    itemsProcessed: number;
    accuracy: number;
    avgProcessingTime: number;
  };
  materialDistribution: {
    [key: string]: number;
  };
  recentPerformance: PerformanceMetric[];
  classificationTrends: ClassificationTrend[];
}

export interface PerformanceMetric {
  timestamp: string;
  accuracy: number;
  throughput: number;
  confidence: number;
  processingTime: number;
}

export interface ClassificationTrend {
  date: string;
  plastic: number;
  metal: number;
  glass: number;
  paper: number;
  organic: number;
}

// System health types - Using ACTUAL backend model names  
export interface SystemHealth {
  Timestamp: Date | string;
  CameraConnected: boolean;
  ArduinoConnected: boolean;
  CnnServiceHealthy: boolean;
  ExpertSystemHealthy: boolean;
  AvgProcessingTimeMs: number;
  TotalItemsProcessed: number;
  AccuracyRate: number;
  ClassificationCounts: { [key: string]: number };
  SystemUptime: number;
  MemoryUsageMB: number;
  CpuUsagePercent: number;
  isHealthy?: boolean; // Computed property for UI
}

// EXPORTED for api.ts
export interface SystemStatus {
  isOnline: boolean;
  lastUpdate: string;
  cameraConnected: boolean;
  arduinoConnected: boolean;
  cnnServiceHealthy: boolean;
  expertSystemHealthy: boolean;
  systemUptime: number;
  memoryUsageMB: number;
  cpuUsagePercent: number;
  alerts: SystemAlert[];
}

export interface ServiceStatus {
  name: string;
  isRunning: boolean;
  lastPing: Date | string;
  responseTime: number;
  errorCount: number;
}

// Manual override types
export interface ManualOverrideRequest {
  classificationId: number;
  newClassification: string;
  newDisposalLocation?: string;
  reason: string;
  userId?: string;
  timestamp: string;
}

// Waste classification types
export enum WasteCategory {
  METAL = 'metal',
  PLASTIC = 'plastic',
  GLASS = 'glass',
  PAPER = 'paper',
  CARDBOARD = 'cardboard',
  ORGANIC = 'organic',
  ELECTRONIC = 'electronic',
  HAZARDOUS = 'hazardous',
  UNKNOWN = 'unknown'
}

export enum PlasticType {
  PET = 'PET',
  HDPE = 'HDPE',
  PVC = 'PVC',
  LDPE = 'LDPE',
  PP = 'PP',
  PS = 'PS',
  OTHER = 'OTHER'
}

export interface WasteItem {
  id: string;
  category: WasteCategory;
  subtype?: string;
  confidence: number;
  weight?: number;
  dimensions?: {
    width: number;
    height: number;
    depth: number;
  };
  imageUrl?: string;
  detectedAt: Date;
  processedAt?: Date;
  disposalBin?: string;
}

// API response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: string[];
  timestamp: string;
}

export interface PagedResult<T> {
  items: T[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
}

// Alternative naming that might be used
export interface PaginatedResponse<T> {
  items: T[];
  totalCount: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
}

export interface ClassificationSearchCriteria {
  fromDate?: Date;
  toDate?: Date;
  classifications?: string[];
  minConfidence?: number;
  maxConfidence?: number;
  decisionPath?: string;
  hasOverride?: boolean;
  limit?: number;
  // Backend might expect PascalCase
  FromDate?: Date;
  ToDate?: Date;
  Limit?: number;
}

// Configuration types
export interface SystemConfiguration {
  confidenceThreshold: number;
  processingTimeout: number;
  enableManualOverride: boolean;
  autoSort: boolean;
  cameraSettings: CameraSettings;
  sensorSettings: SensorSettings;
}

export interface CameraSettings {
  resolution: {
    width: number;
    height: number;
  };
  fps: number;
  brightness: number;
  contrast: number;
  exposure: number;
}

export interface SensorSettings {
  weightSensitivity: number;
  metalDetectorSensitivity: number;
  humiditySensitivity: number;
  temperatureRange: {
    min: number;
    max: number;
  };
}

// UI state types
export interface ConnectionState {
  classification: boolean;
  dashboard: boolean;
  isConnecting: boolean;
  lastConnectionTime?: Date;
  reconnectAttempts: number;
}

export interface LoadingState {
  isLoading: boolean;
  operation?: string;
  progress?: number;
}

export interface ErrorState {
  hasError: boolean;
  message?: string;
  code?: string;
  details?: any;
}

// Chart data types
export interface ChartDataPoint {
  label: string;
  value: number;
  timestamp?: Date;
  category?: string;
}

export interface TimeSeriesData {
  timestamp: Date;
  [metric: string]: number | Date;
}



FILE: frontend/tsconfig.json
------------------------------------------------------------
Size: 535 B
Encoding: ascii
------------------------------------------------------------
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}



FILE: garbage_classification.py
------------------------------------------------------------
Size: 13.6 KB
Encoding: ascii
------------------------------------------------------------
# -*- coding: utf-8 -*-
"""Garbage_Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M6U3t5X153ZXJncpR2lOdzchKqN1ALRF

# **This is fine-tuning the model with *Aggresive* data augmentation and with unfreeze the last block of the resnet50**
"""

import warnings
warnings.filterwarnings('ignore')

import os
import seaborn as sns
from PIL import Image

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from tensorflow.keras.applications import ResNet50
from keras.models import Model
from keras.layers import Input, Activation, Add, Dense, Conv2D, GlobalAveragePooling2D, MaxPooling2D, Dropout
from tensorflow.keras.applications.resnet50 import preprocess_input

from tensorflow.keras.optimizers import Adam
from keras.callbacks import ReduceLROnPlateau, EarlyStopping
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix



# from sklearn.utils.class_weight import compute_class_weight

# from matplotlib.colors import LinearSegmentedColormap

from keras.layers import BatchNormalization, Dropout

from tensorflow.keras.applications.resnet50 import preprocess_input

from keras.utils import plot_model

"""# Mounting preparing"""

from google.colab import drive
drive.mount('/content/drive')

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!pip install kaggle

drive_path = '/content/drive/MyDrive/AI_Trash_Sorter/datasets'
os.makedirs(drive_path, exist_ok=True)

# Commented out IPython magic to ensure Python compatibility.
# %cd {drive_path}

!kaggle datasets download -d farzadnekouei/trash-type-image-dataset

!unzip -q /content/drive/MyDrive/AI_Trash_Sorter/datasets/trash-type-image-dataset.zip

"""**Data Checking**


"""

# Define the path where our dataset is stored
dataset_path = '/content/drive/MyDrive/AI_Trash_Sorter/datasets/TrashType_Image_Dataset'

# Retrieve the names of all folders (representing trash types) within the dataset directory
garbage_types = os.listdir(dataset_path)

# Set to store unique image dimensions for the entire dataset
all_dimensions_set = set()

# Iterate over each trash type (folder) to process images
for garbage_type in garbage_types:
    folder_path = os.path.join(dataset_path, garbage_type)

    # Verify that the current item is a directory
    if os.path.isdir(folder_path):
        image_files = [f for f in os.listdir(folder_path) if f.endswith(('jpg', 'jpeg'))]

        # Display the count of images in the current folder
        num_images = len(image_files)
        print(f"{garbage_type} folder contains {num_images} images.")

        # Loop over each image to check its dimensions
        for image_file in image_files:
            image_path = os.path.join(folder_path, image_file)
            with Image.open(image_path) as img:
                # Extract the width, height, and channels (color depth) of the image and add to the dimensions set
                width, height = img.size
                channels = len(img.getbands())
                all_dimensions_set.add((width, height, channels))

# Determine if all images in the entore dataset have the same dimensions
if len(all_dimensions_set) == 1:
    width, height, channel = all_dimensions_set.pop()
    print(f"\nAll images in the dataset have the same dimensions: {width}x{height} with {channels} color channels.")
else:
    print("\nThe images in the dataset have different dimensions or color channels.")

for garbage_type in garbage_types:
    folder_path = os.path.join(dataset_path, garbage_type)

    if os.path.isdir(folder_path):
        image_files = [f for f in os.listdir(folder_path) if f.endswith(('jpg', 'jpeg'))]

        image_files = image_files[:7]

        # Set up subplots
        fig, axs = plt.subplots(1, 7, figsize=(15, 2))

        for i, image_file in enumerate(image_files):
            image_path = os.path.join(folder_path, image_file)
            with Image.open(image_path) as img:
                axs[i].imshow(img)
                axs[i].axis('off')

        plt.tight_layout()
        fig.suptitle(garbage_type, fontsize=20, y=1.03)
        plt.show()

# Initialize an empty list to store image file paths and their respective labels
data = []

# Loop through each garbage type and collect its images' file paths
for garbage_type in garbage_types:
    for file in os.listdir(os.path.join(dataset_path, garbage_type)):
        # Append the image file path and its trash type (as a label) to the data list
        data.append((os.path.join(dataset_path, garbage_type, file), garbage_type))

# Convert the collected data into a DataFrame
df = pd.DataFrame(data, columns=['filepath', 'label'])

# Display the first few entries of the DataFrame
df.tail()

train_df, val_df = train_test_split(df, test_size=0.2, random_state=42, stratify=df['label'])

# Print the number of images in each set
print(f"Number of images in the training set: {len(train_df)}")
print(f"Number of images in the validation set: {len(val_df)}")

# 1. Class distribution in the entire dataset
overall_distribution = df['label'].value_counts(normalize=True) * 100

# 2. Class distribution in the training set
train_distribution = train_df['label'].value_counts(normalize=True) * 100

# 3. Class distribution in the validation set
val_distribution = val_df['label'].value_counts(normalize=True) * 100

print("Class distribution in the entire dataset:\n")
print(overall_distribution.round(2))
print('-'*40)

print("\nClass distribution in the training set:\n")
print(train_distribution.round(2))
print('-'*40)

print("\nClass distribution in the validation set:\n")
print(val_distribution.round(2))

# Slight Augmentation settings for training
train_datagen = ImageDataGenerator(
    rotation_range=60,                  # Randomly rotate the images by up to 60 degrees
    width_shift_range=0.15,             # Randomly shift images horizontally by up to 15% of the width
    height_shift_range=0.15,            # Randomly shift images vertically by up to 15% of the height
    zoom_range=0.20,                    # Randomly zoom in or out by up to 20%
    horizontal_flip=True,               # Randomly flip images horizontally
    vertical_flip=True,                 # Randomly flip images vertically
    shear_range=0.05,                   # Apply slight shear transformations
    brightness_range=[0.9, 1.1],        # Vary brightness between 90% to 110% of original
    channel_shift_range=10,             # Randomly shift channels (can change colors of images slightly but less aggressively)
    fill_mode='nearest',                 # Fill in missing pixels using the nearest filled value
    preprocessing_function=preprocess_input  # Add this line
)

# For the validation set, you might not have augmentation:
val_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)  # Add this line

# Using flow_from_dataframe to generate batches
# Generate training batches from the training dataframe
train_generator = train_datagen.flow_from_dataframe(
    dataframe=train_df,                  # DataFrame containing training data
    x_col="filepath",                    # Column with paths to image files
    y_col="label",                       # Column with image labels
    target_size=(384, 384),              # Resize all images to size of 384x384
    batch_size=32,                       # Number of images per batch
    class_mode='categorical',            # One-hot encode labels
    seed=42,                             # Seed for random number generator to ensure reproducibility
    shuffle=False                        # Data is not shuffled; order retained from DataFrame
)


# Generate validation batches from the validation dataframe
val_generator = val_datagen.flow_from_dataframe(
    dataframe=val_df,                    # DataFrame containing validation data
    x_col="filepath",                    # Column with paths to image files
    y_col="label",                       # Column with image labels
    target_size=(384, 384),              # Resize all images to size of 384x384
    batch_size=32,                       # Number of images per batch
    class_mode='categorical',            # One-hot encode labels
    seed=42,                             # Seed for random number generator to ensure reproducibility
    shuffle=False                        # Data is not shuffled; order retained from DataFrame
)

print(f"Number of batches in train_generator: {len(train_generator)}")
print(f"Number of batches in val_generator: {len(val_generator)}")

# Load the ResNet50 model with weights pre-trained on ImageNet
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(384, 384, 3))

base_model.summary()

len(base_model.layers)

for i, layer in enumerate(base_model.layers):
    if 140 <= i <= 175:
        print(i, layer.name)

# Freeze the layers up to conv4_block6_out
for layer in base_model.layers[:165]: # include the layer 142
    layer.trainable = False

# Create the new model
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dropout(0.5)(x)
x = Dense(5, activation='softmax')(x)

ft_model = Model(inputs=base_model.input, outputs=x)

# Compile the model
ft_model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])

ft_model.summary()

# A slightly more aggressive learning rate reducer
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=5, min_lr=0.00001)

# A slightly more aggressive early stopper
early_stopping = EarlyStopping(monitor='val_loss', mode='min', patience=10, restore_best_weights=True, verbose=1)

"""# Training"""

# --- 2. Define Training Parameters ---
# We'll start with a reasonable number of epochs. EarlyStopping will handle the rest.
EPOCHS = 50 # A good starting point. Can be increased if needed.


# --- 3. Train the Model ---
# This is the command that starts the training process.
# Note: We do NOT include the class_weight parameter.

history = ft_model.fit(
    train_generator,
    epochs=EPOCHS,
    validation_data=val_generator,
    callbacks=[reduce_lr, early_stopping]
)

def plot_learning_curves(history, start_epoch=5):
    """
    Plot training and validation loss and accuracy curves.

    Parameters:
    - history: Training history (output from the model's fit method).
    - start_epoch: Epoch from which to start plotting. Default is 5 (i.e., plot from epoch 6 onwards).
    """

    # Convert the history.history dict to a pandas DataFrame
    df = pd.DataFrame(history.history)

    # Plot the curves from the specified epoch onwards
    df = df.iloc[start_epoch-1:]

    # Set the style of seaborn for better visualization
    sns.set(rc={'axes.facecolor': '#f0f0fc'}, style='darkgrid')

    # Plotting the learning curves
    plt.figure(figsize=(15,6))

    # Plotting the training and validation loss
    plt.subplot(1, 2, 1)
    sns.lineplot(x=df.index, y=df['loss'], color='royalblue', label='Train Loss')
    sns.lineplot(x=df.index, y=df['val_loss'], color='orangered', linestyle='--', label='Validation Loss')
    plt.title('Loss Evolution')

    # Plotting the training and validation accuracy
    plt.subplot(1, 2, 2)
    sns.lineplot(x=df.index, y=df['accuracy'], color='royalblue', label='Train Accuracy')
    sns.lineplot(x=df.index, y=df['val_accuracy'], color='orangered', linestyle='--', label='Validation Accuracy')
    plt.title('Accuracy Evolution')

    plt.show()

plot_learning_curves(history)

# --- Step 1: Get Final Loss and Accuracy ---
# This provides the single best summary of your model's performance.

print("--- Final Model Evaluation ---")
final_loss, final_accuracy = ft_model.evaluate(val_generator)
print(f"Final Validation Loss: {final_loss:.4f}")
print(f"Final Validation Accuracy: {final_accuracy:.4f}")


# --- Step 2: Get Predictions and True Labels ---
# We need these to build the detailed reports.

# Ensure the generator is at the beginning
val_generator.reset()

# Get the model's predictions
# The 'predict' function returns probabilities for each class
y_pred_probs = ft_model.predict(val_generator)

# Convert probabilities to a single predicted class index
# np.argmax finds the index (0, 1, 2, etc.) with the highest probability
y_pred = np.argmax(y_pred_probs, axis=1)

# Get the true class indices
y_true = val_generator.classes

# Get the names of the classes
class_names = list(val_generator.class_indices.keys())


# --- Step 3: Print the Classification Report ---
# This report gives a detailed breakdown of performance for each class.

print("\n--- Classification Report ---")
print(classification_report(y_true, y_pred, target_names=class_names))


# --- Step 4: Display the Confusion Matrix ---
# This matrix gives a visual breakdown of the model's mistakes.

print("\n--- Confusion Matrix ---")
confusion_mtx = confusion_matrix(y_true, y_pred)

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(confusion_mtx,
            annot=True,      # Show the numbers in the cells
            fmt='d',         # Format the numbers as integers
            cmap='Blues',    # Use a blue color scheme
            xticklabels=class_names,
            yticklabels=class_names)

plt.ylabel('Actual (True) Label')
plt.xlabel('Predicted Label')
plt.title('Confusion Matrix')
plt.show()

model_save_path = '/content/drive/MyDrive/AI_Trash_Sorter/trash_classifier_v3_93_accuracy_4mp.h5'

ft_model.save(model_save_path)

print(f"Model successfully saved to: {model_save_path}")

model_save_path_keras = '/content/drive/MyDrive/AI_Trash_Sorter/trash_classifier_v3_93_accuracy_4mp.keras'

ft_model.save(model_save_path_keras)

print(f"Model successfully saved to: {model_save_path_keras}")




FILE: models/garbage_classification.py
------------------------------------------------------------
Size: 13.6 KB
Encoding: ascii
------------------------------------------------------------
# -*- coding: utf-8 -*-
"""Garbage_Classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M6U3t5X153ZXJncpR2lOdzchKqN1ALRF

# **This is fine-tuning the model with *Aggresive* data augmentation and with unfreeze the last block of the resnet50**
"""

import warnings
warnings.filterwarnings('ignore')

import os
import seaborn as sns
from PIL import Image

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from tensorflow.keras.applications import ResNet50
from keras.models import Model
from keras.layers import Input, Activation, Add, Dense, Conv2D, GlobalAveragePooling2D, MaxPooling2D, Dropout
from tensorflow.keras.applications.resnet50 import preprocess_input

from tensorflow.keras.optimizers import Adam
from keras.callbacks import ReduceLROnPlateau, EarlyStopping
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix



# from sklearn.utils.class_weight import compute_class_weight

# from matplotlib.colors import LinearSegmentedColormap

from keras.layers import BatchNormalization, Dropout

from tensorflow.keras.applications.resnet50 import preprocess_input

from keras.utils import plot_model

"""# Mounting preparing"""

from google.colab import drive
drive.mount('/content/drive')

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!pip install kaggle

drive_path = '/content/drive/MyDrive/AI_Trash_Sorter/datasets'
os.makedirs(drive_path, exist_ok=True)

# Commented out IPython magic to ensure Python compatibility.
# %cd {drive_path}

!kaggle datasets download -d farzadnekouei/trash-type-image-dataset

!unzip -q /content/drive/MyDrive/AI_Trash_Sorter/datasets/trash-type-image-dataset.zip

"""**Data Checking**


"""

# Define the path where our dataset is stored
dataset_path = '/content/drive/MyDrive/AI_Trash_Sorter/datasets/TrashType_Image_Dataset'

# Retrieve the names of all folders (representing trash types) within the dataset directory
garbage_types = os.listdir(dataset_path)

# Set to store unique image dimensions for the entire dataset
all_dimensions_set = set()

# Iterate over each trash type (folder) to process images
for garbage_type in garbage_types:
    folder_path = os.path.join(dataset_path, garbage_type)

    # Verify that the current item is a directory
    if os.path.isdir(folder_path):
        image_files = [f for f in os.listdir(folder_path) if f.endswith(('jpg', 'jpeg'))]

        # Display the count of images in the current folder
        num_images = len(image_files)
        print(f"{garbage_type} folder contains {num_images} images.")

        # Loop over each image to check its dimensions
        for image_file in image_files:
            image_path = os.path.join(folder_path, image_file)
            with Image.open(image_path) as img:
                # Extract the width, height, and channels (color depth) of the image and add to the dimensions set
                width, height = img.size
                channels = len(img.getbands())
                all_dimensions_set.add((width, height, channels))

# Determine if all images in the entore dataset have the same dimensions
if len(all_dimensions_set) == 1:
    width, height, channel = all_dimensions_set.pop()
    print(f"\nAll images in the dataset have the same dimensions: {width}x{height} with {channels} color channels.")
else:
    print("\nThe images in the dataset have different dimensions or color channels.")

for garbage_type in garbage_types:
    folder_path = os.path.join(dataset_path, garbage_type)

    if os.path.isdir(folder_path):
        image_files = [f for f in os.listdir(folder_path) if f.endswith(('jpg', 'jpeg'))]

        image_files = image_files[:7]

        # Set up subplots
        fig, axs = plt.subplots(1, 7, figsize=(15, 2))

        for i, image_file in enumerate(image_files):
            image_path = os.path.join(folder_path, image_file)
            with Image.open(image_path) as img:
                axs[i].imshow(img)
                axs[i].axis('off')

        plt.tight_layout()
        fig.suptitle(garbage_type, fontsize=20, y=1.03)
        plt.show()

# Initialize an empty list to store image file paths and their respective labels
data = []

# Loop through each garbage type and collect its images' file paths
for garbage_type in garbage_types:
    for file in os.listdir(os.path.join(dataset_path, garbage_type)):
        # Append the image file path and its trash type (as a label) to the data list
        data.append((os.path.join(dataset_path, garbage_type, file), garbage_type))

# Convert the collected data into a DataFrame
df = pd.DataFrame(data, columns=['filepath', 'label'])

# Display the first few entries of the DataFrame
df.tail()

train_df, val_df = train_test_split(df, test_size=0.2, random_state=42, stratify=df['label'])

# Print the number of images in each set
print(f"Number of images in the training set: {len(train_df)}")
print(f"Number of images in the validation set: {len(val_df)}")

# 1. Class distribution in the entire dataset
overall_distribution = df['label'].value_counts(normalize=True) * 100

# 2. Class distribution in the training set
train_distribution = train_df['label'].value_counts(normalize=True) * 100

# 3. Class distribution in the validation set
val_distribution = val_df['label'].value_counts(normalize=True) * 100

print("Class distribution in the entire dataset:\n")
print(overall_distribution.round(2))
print('-'*40)

print("\nClass distribution in the training set:\n")
print(train_distribution.round(2))
print('-'*40)

print("\nClass distribution in the validation set:\n")
print(val_distribution.round(2))

# Slight Augmentation settings for training
train_datagen = ImageDataGenerator(
    rotation_range=60,                  # Randomly rotate the images by up to 60 degrees
    width_shift_range=0.15,             # Randomly shift images horizontally by up to 15% of the width
    height_shift_range=0.15,            # Randomly shift images vertically by up to 15% of the height
    zoom_range=0.20,                    # Randomly zoom in or out by up to 20%
    horizontal_flip=True,               # Randomly flip images horizontally
    vertical_flip=True,                 # Randomly flip images vertically
    shear_range=0.05,                   # Apply slight shear transformations
    brightness_range=[0.9, 1.1],        # Vary brightness between 90% to 110% of original
    channel_shift_range=10,             # Randomly shift channels (can change colors of images slightly but less aggressively)
    fill_mode='nearest',                 # Fill in missing pixels using the nearest filled value
    preprocessing_function=preprocess_input  # Add this line
)

# For the validation set, you might not have augmentation:
val_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)  # Add this line

# Using flow_from_dataframe to generate batches
# Generate training batches from the training dataframe
train_generator = train_datagen.flow_from_dataframe(
    dataframe=train_df,                  # DataFrame containing training data
    x_col="filepath",                    # Column with paths to image files
    y_col="label",                       # Column with image labels
    target_size=(384, 384),              # Resize all images to size of 384x384
    batch_size=32,                       # Number of images per batch
    class_mode='categorical',            # One-hot encode labels
    seed=42,                             # Seed for random number generator to ensure reproducibility
    shuffle=False                        # Data is not shuffled; order retained from DataFrame
)


# Generate validation batches from the validation dataframe
val_generator = val_datagen.flow_from_dataframe(
    dataframe=val_df,                    # DataFrame containing validation data
    x_col="filepath",                    # Column with paths to image files
    y_col="label",                       # Column with image labels
    target_size=(384, 384),              # Resize all images to size of 384x384
    batch_size=32,                       # Number of images per batch
    class_mode='categorical',            # One-hot encode labels
    seed=42,                             # Seed for random number generator to ensure reproducibility
    shuffle=False                        # Data is not shuffled; order retained from DataFrame
)

print(f"Number of batches in train_generator: {len(train_generator)}")
print(f"Number of batches in val_generator: {len(val_generator)}")

# Load the ResNet50 model with weights pre-trained on ImageNet
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(384, 384, 3))

base_model.summary()

len(base_model.layers)

for i, layer in enumerate(base_model.layers):
    if 140 <= i <= 175:
        print(i, layer.name)

# Freeze the layers up to conv4_block6_out
for layer in base_model.layers[:165]: # include the layer 142
    layer.trainable = False

# Create the new model
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dropout(0.5)(x)
x = Dense(5, activation='softmax')(x)

ft_model = Model(inputs=base_model.input, outputs=x)

# Compile the model
ft_model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])

ft_model.summary()

# A slightly more aggressive learning rate reducer
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=5, min_lr=0.00001)

# A slightly more aggressive early stopper
early_stopping = EarlyStopping(monitor='val_loss', mode='min', patience=10, restore_best_weights=True, verbose=1)

"""# Training"""

# --- 2. Define Training Parameters ---
# We'll start with a reasonable number of epochs. EarlyStopping will handle the rest.
EPOCHS = 50 # A good starting point. Can be increased if needed.


# --- 3. Train the Model ---
# This is the command that starts the training process.
# Note: We do NOT include the class_weight parameter.

history = ft_model.fit(
    train_generator,
    epochs=EPOCHS,
    validation_data=val_generator,
    callbacks=[reduce_lr, early_stopping]
)

def plot_learning_curves(history, start_epoch=5):
    """
    Plot training and validation loss and accuracy curves.

    Parameters:
    - history: Training history (output from the model's fit method).
    - start_epoch: Epoch from which to start plotting. Default is 5 (i.e., plot from epoch 6 onwards).
    """

    # Convert the history.history dict to a pandas DataFrame
    df = pd.DataFrame(history.history)

    # Plot the curves from the specified epoch onwards
    df = df.iloc[start_epoch-1:]

    # Set the style of seaborn for better visualization
    sns.set(rc={'axes.facecolor': '#f0f0fc'}, style='darkgrid')

    # Plotting the learning curves
    plt.figure(figsize=(15,6))

    # Plotting the training and validation loss
    plt.subplot(1, 2, 1)
    sns.lineplot(x=df.index, y=df['loss'], color='royalblue', label='Train Loss')
    sns.lineplot(x=df.index, y=df['val_loss'], color='orangered', linestyle='--', label='Validation Loss')
    plt.title('Loss Evolution')

    # Plotting the training and validation accuracy
    plt.subplot(1, 2, 2)
    sns.lineplot(x=df.index, y=df['accuracy'], color='royalblue', label='Train Accuracy')
    sns.lineplot(x=df.index, y=df['val_accuracy'], color='orangered', linestyle='--', label='Validation Accuracy')
    plt.title('Accuracy Evolution')

    plt.show()

plot_learning_curves(history)

# --- Step 1: Get Final Loss and Accuracy ---
# This provides the single best summary of your model's performance.

print("--- Final Model Evaluation ---")
final_loss, final_accuracy = ft_model.evaluate(val_generator)
print(f"Final Validation Loss: {final_loss:.4f}")
print(f"Final Validation Accuracy: {final_accuracy:.4f}")


# --- Step 2: Get Predictions and True Labels ---
# We need these to build the detailed reports.

# Ensure the generator is at the beginning
val_generator.reset()

# Get the model's predictions
# The 'predict' function returns probabilities for each class
y_pred_probs = ft_model.predict(val_generator)

# Convert probabilities to a single predicted class index
# np.argmax finds the index (0, 1, 2, etc.) with the highest probability
y_pred = np.argmax(y_pred_probs, axis=1)

# Get the true class indices
y_true = val_generator.classes

# Get the names of the classes
class_names = list(val_generator.class_indices.keys())


# --- Step 3: Print the Classification Report ---
# This report gives a detailed breakdown of performance for each class.

print("\n--- Classification Report ---")
print(classification_report(y_true, y_pred, target_names=class_names))


# --- Step 4: Display the Confusion Matrix ---
# This matrix gives a visual breakdown of the model's mistakes.

print("\n--- Confusion Matrix ---")
confusion_mtx = confusion_matrix(y_true, y_pred)

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(confusion_mtx,
            annot=True,      # Show the numbers in the cells
            fmt='d',         # Format the numbers as integers
            cmap='Blues',    # Use a blue color scheme
            xticklabels=class_names,
            yticklabels=class_names)

plt.ylabel('Actual (True) Label')
plt.xlabel('Predicted Label')
plt.title('Confusion Matrix')
plt.show()

model_save_path = '/content/drive/MyDrive/AI_Trash_Sorter/trash_classifier_v3_93_accuracy_4mp.h5'

ft_model.save(model_save_path)

print(f"Model successfully saved to: {model_save_path}")

model_save_path_keras = '/content/drive/MyDrive/AI_Trash_Sorter/trash_classifier_v3_93_accuracy_4mp.keras'

ft_model.save(model_save_path_keras)

print(f"Model successfully saved to: {model_save_path_keras}")




FILE: python-services/connection_test.py
------------------------------------------------------------
Size: 8.4 KB
Encoding: utf-8
------------------------------------------------------------
"""
Simple Connection Test for SignalR
Tests the updated hub client without importing
"""

import asyncio
import aiohttp
import logging
import sys
from pathlib import Path

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger("SimpleConnectionTest")

async def test_backend_endpoints():
    """Test backend endpoints"""
    backend_url = "http://localhost:5099"
    
    logger.info(f"🔍 Testing backend endpoints at {backend_url}...")
    
    tests = [
        ("Swagger", "/swagger/index.html", 200),
        ("API Root", "/api", 404),  # Expected 404 - no root API endpoint
        ("Classification Hub Negotiate", "/hubs/classification/negotiate?negotiateVersion=1", 200),
        ("Dashboard Hub Negotiate", "/hubs/dashboard/negotiate?negotiateVersion=1", 200),
    ]
    
    results = {}
    
    try:
        async with aiohttp.ClientSession() as session:
            for test_name, endpoint, expected_status in tests:
                try:
                    method = "POST" if "negotiate" in endpoint else "GET"
                    headers = {'Content-Type': 'application/json'} if method == "POST" else {}
                    
                    async with session.request(method, f"{backend_url}{endpoint}", 
                                             headers=headers,
                                             timeout=aiohttp.ClientTimeout(total=5)) as response:
                        
                        status = response.status
                        results[test_name] = status == expected_status
                        
                        if status == expected_status:
                            logger.info(f"✅ {test_name}: {status} (expected {expected_status})")
                        else:
                            logger.warning(f"⚠️  {test_name}: {status} (expected {expected_status})")
                            
                        if "negotiate" in endpoint and status == 200:
                            negotiate_response = await response.json()
                            conn_id = negotiate_response.get('connectionId', 'N/A')[:8]
                            logger.info(f"   → Connection ID: {conn_id}...")
                        
                except Exception as e:
                    logger.error(f"❌ {test_name} failed: {e}")
                    results[test_name] = False
                    
    except Exception as e:
        logger.error(f"❌ Session creation failed: {e}")
        return False
    
    all_passed = all(results.values())
    logger.info(f"📊 Backend tests: {sum(results.values())}/{len(results)} passed")
    return all_passed

async def test_direct_hub_connection():
    """Test direct hub connection using basic websocket"""
    import websockets
    import json
    
    logger.info("🔍 Testing direct SignalR hub connection...")
    
    try:
        # Step 1: Negotiate
        async with aiohttp.ClientSession() as session:
            negotiate_url = "http://localhost:5099/hubs/classification/negotiate?negotiateVersion=1"
            async with session.post(negotiate_url, 
                                  headers={'Content-Type': 'application/json'}) as response:
                if response.status != 200:
                    logger.error(f"❌ Negotiation failed: {response.status}")
                    return False
                
                negotiate_response = await response.json()
                connection_token = negotiate_response.get('connectionToken')
                
                if not connection_token:
                    logger.error("❌ No connection token received")
                    return False
                
                logger.info("✅ Negotiation successful")
        
        # Step 2: WebSocket connection
        ws_url = f"ws://localhost:5099/hubs/classification?id={connection_token}"
        
        async with websockets.connect(ws_url, ping_interval=20, ping_timeout=10) as websocket:
            logger.info("✅ WebSocket connected")
            
            # Step 3: Send handshake
            handshake = {"protocol": "json", "version": 1}
            await websocket.send(json.dumps(handshake) + "\x1e")
            
            # Wait for handshake response
            response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
            
            if response.strip('\x1e') == "":
                logger.info("✅ Handshake completed")
            else:
                logger.warning(f"⚠️  Unexpected handshake response: {response}")
            
            # Step 4: Send test message
            test_message = {
                "type": 1,
                "invocationId": "1",
                "target": "TestMethod", 
                "arguments": ['{"test": "data"}']
            }
            
            await websocket.send(json.dumps(test_message) + "\x1e")
            logger.info("✅ Test message sent")
            
            # Wait a bit for any response
            try:
                response = await asyncio.wait_for(websocket.recv(), timeout=2.0)
                logger.info(f"📨 Received response: {response}")
            except asyncio.TimeoutError:
                logger.info("📭 No immediate response (expected)")
            
            logger.info("✅ Direct hub connection test successful")
            return True
            
    except Exception as e:
        logger.error(f"❌ Direct hub connection failed: {e}")
        return False

async def test_import_services():
    """Test if we can import the services with updated hub client"""
    logger.info("🔍 Testing service imports...")
    
    try:
        # Add services path
        services_path = Path(__file__).parent / "services"
        sys.path.insert(0, str(services_path))
        
        # Try to import the hub client
        from hub_client import SignalRHubClient
        logger.info("✅ Hub client imported successfully")
        
        # Create a test instance
        test_client = SignalRHubClient("http://localhost:5099/hubs/classification", "TestClient")
        logger.info("✅ Hub client instance created")
        
        # Test if it has the new methods
        has_negotiate = hasattr(test_client, 'negotiate_connection')
        has_handshake = hasattr(test_client, 'send_handshake')
        has_websocket = hasattr(test_client, 'establish_websocket_connection')
        
        if has_negotiate and has_handshake and has_websocket:
            logger.info("✅ Hub client has new SignalR protocol methods")
            return True
        else:
            logger.error("❌ Hub client missing new protocol methods - needs to be updated")
            return False
            
    except ImportError as e:
        logger.error(f"❌ Cannot import hub client: {e}")
        return False
    except Exception as e:
        logger.error(f"❌ Hub client test failed: {e}")
        return False

async def main():
    """Run all connection tests"""
    logger.info("🚀 Starting Simple SignalR Connection Tests")
    logger.info("=" * 60)
    
    tests = [
        ("Backend Endpoints", test_backend_endpoints),
        ("Service Import", test_import_services),
        ("Direct Hub Connection", test_direct_hub_connection),
    ]
    
    all_passed = True
    
    for test_name, test_func in tests:
        logger.info(f"\n📋 Running {test_name}...")
        try:
            result = await test_func()
            if not result:
                all_passed = False
        except Exception as e:
            logger.error(f"❌ {test_name} raised exception: {e}")
            all_passed = False
    
    logger.info("\n" + "=" * 60)
    if all_passed:
        logger.info("🎉 ALL TESTS PASSED!")
        logger.info("✅ Backend is ready for SignalR connections")
        logger.info("🚀 You can now run: python orchestrated_main_service.py")
    else:
        logger.error("❌ Some tests failed.")
        logger.error("📋 Action items:")
        logger.error("   1. Replace python-services/services/hub_client.py with updated version")
        logger.error("   2. Ensure backend is running: cd backend && dotnet run")
        logger.error("   3. Check firewall settings")
    
    logger.info("=" * 60)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Test interrupted by user")
    except Exception as e:
        logger.error(f"Test script failed: {e}")



FILE: python-services/main.py
------------------------------------------------------------
Size: 397 B
Encoding: ascii
------------------------------------------------------------
import sys
from pathlib import Path

src_path = Path(__file__).parent / "src"
sys.path.insert(0, str(src_path))

from smart_bin.interfaces.cli import CLIInterface

def main():
    """Main entry point"""
    try:
        cli = CLIInterface()
        cli.run()
    except Exception as e:
        print(f"Failed to start application: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()




FILE: python-services/orchestrated_main_service.py
------------------------------------------------------------
Size: 31.6 KB
Encoding: utf-8
------------------------------------------------------------
# """
# Main Orchestrated Service Integration
# Coordinates CNN, Arduino, and Expert System with Backend
# """
# 
# import asyncio
# import logging
# import sys
# import os
# from pathlib import Path
# import signal
# 
# # Add src to path
# src_path = Path(__file__).parent / "src"
# sys.path.insert(0, str(src_path))
# 
# # Import the enhanced services
# from services.cnn_service import CNNService
# from services.arduino_service import EnhancedArduinoService
# 
# # Setup comprehensive logging
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
#     handlers=[
#         logging.FileHandler('../logs/orchestrated_services.log'),
#         logging.StreamHandler(sys.stdout)
#     ]
# )
# 
# logger = logging.getLogger("OrchestratedServices")
# 
# class SmartRecyclingBinOrchestrator:
#     """Main orchestrator that coordinates all services"""
#     
#     def __init__(self):
#         self.logger = logging.getLogger("Orchestrator")
#         self.services = {}
#         self.is_running = False
#         
#         # Configuration from environment
#         self.config = {
#             'model_path': os.getenv('MODEL_PATH', '../models/trash_classifier_v3_93_accuracy_4mp.keras'),
#             'arduino_port': os.getenv('ARDUINO_PORT', '/dev/ttyUSB0'),
#             'arduino_baudrate': int(os.getenv('ARDUINO_BAUDRATE', '9600')),
#             'backend_hub_url': os.getenv('BACKEND_URL', 'http://localhost:5099/hubs/classification'),
#             'camera_index': int(os.getenv('CAMERA_INDEX', '0'))
#         }
#         
#     async def start_services(self):
#         """Start and coordinate all services"""
#         self.logger.info("🚀 Starting Smart Recycling Bin Orchestrated Services...")
#         self.logger.info("=" * 80)
#         
#         try:
#             # Log configuration
#             self.logger.info("📋 Configuration:")
#             for key, value in self.config.items():
#                 self.logger.info(f"   {key}: {value}")
#             self.logger.info("=" * 80)
#             
#             # Check prerequisites
#             if not await self.check_prerequisites():
#                 self.logger.error("❌ Prerequisites check failed")
#                 return False
#             
#             # Initialize services
#             await self.initialize_services()
#             
#             # Setup service integration
#             await self.setup_service_integration()
#             
#             # Start all services
#             await self.start_all_services()
#             
#             self.is_running = True
#             self.logger.info("✅ All services started successfully!")
#             self.logger.info("🎯 Smart Recycling Bin is operational and ready for items")
#             self.logger.info("=" * 80)
#             
#             return True
#             
#         except Exception as e:
#             self.logger.error(f"💥 Failed to start services: {e}")
#             return False
# 
#     async def check_prerequisites(self) -> bool:
#         """Check if all prerequisites are met"""
#         self.logger.info("🔍 Checking prerequisites...")
#         
#         # Check if model file exists
#         if not os.path.exists(self.config['model_path']):
#             self.logger.error(f"❌ Model file not found: {self.config['model_path']}")
#             self.logger.error("📋 Please add your trained model to the models/ directory")
#             return False
#         
#         # Check if backend is accessible (optional warning)
#         try:
#             import aiohttp
#             async with aiohttp.ClientSession() as session:
#                 async with session.get(f"http://localhost:5099/health", timeout=5) as response:
#                     if response.status == 200:
#                         self.logger.info("✅ Backend health check passed")
#                     else:
#                         self.logger.warning("⚠️  Backend may not be fully ready")
#         except Exception as e:
#             self.logger.warning(f"⚠️  Backend connection check failed: {e}")
#             self.logger.info("🏢 Make sure the C# backend is running: cd backend && dotnet run")
#         
#         # Check camera access
#         try:
#             import cv2
#             camera = cv2.VideoCapture(self.config['camera_index'])
#             if camera.isOpened():
#                 self.logger.info("✅ Camera access verified")
#                 camera.release()
#             else:
#                 self.logger.warning(f"⚠️  Camera {self.config['camera_index']} not accessible - will use mock data")
#         except Exception as e:
#             self.logger.warning(f"⚠️  Camera check failed: {e}")
#         
#         # Check Arduino port
#         try:
#             import serial
#             ser = serial.Serial(self.config['arduino_port'], self.config['arduino_baudrate'], timeout=1)
#             self.logger.info(f"✅ Arduino port {self.config['arduino_port']} accessible")
#             ser.close()
#         except Exception as e:
#             self.logger.warning(f"⚠️  Arduino port {self.config['arduino_port']} not accessible - will use mock data")
#         
#         self.logger.info("✅ Prerequisites check completed")
#         return True
# 
#     async def initialize_services(self):
#         """Initialize all services"""
#         self.logger.info("🔧 Initializing services...")
#         
#         # Initialize CNN Service
#         self.services['cnn'] = CNNService(
#             self.config['model_path'],
#             self.config['backend_hub_url']
#         )
#         self.logger.info("✅ CNN Service initialized")
#         
#         # Initialize Arduino Service
#         self.services['arduino'] = EnhancedArduinoService(
#             self.config['arduino_port'],
#             self.config['arduino_baudrate'],
#             self.config['backend_hub_url']
#         )
#         self.logger.info("✅ Arduino Service initialized")
#         
#     async def setup_service_integration(self):
#         """Setup integration between services"""
#         self.logger.info("🔗 Setting up service integration...")
#         
#         # Integrate Arduino with CNN service
#         self.services['arduino'].set_cnn_service(self.services['cnn'])
#         self.services['cnn'].set_arduino_service(self.services['arduino'])
#         
#         # Set up communication callbacks
#         self.services['arduino'].set_classification_callback(self.handle_classification_trigger)
#         
#         self.logger.info("✅ Service integration complete")
# 
#     async def handle_classification_trigger(self, trigger_data: dict):
#         """Handle classification trigger from Arduino service"""
#         try:
#             self.logger.info(f"🎯 Classification triggered: {trigger_data['detection_id']}")
#             
#             # This is called when Arduino detects an item and CNN service is not directly integrated
#             # Could be used for additional coordination logic
#             
#             # Example: Add custom pre-processing or validation here
#             
#         except Exception as e:
#             self.logger.error(f"Error handling classification trigger: {e}")
# 
#     async def start_all_services(self):
#         """Start all services concurrently"""
#         self.logger.info("▶️  Starting all services...")
#         
#         # Create service tasks
#         tasks = [
#             asyncio.create_task(self.services['cnn'].start_service(), name="CNN-Service"),
#             asyncio.create_task(self.services['arduino'].start_service(), name="Arduino-Service")
#         ]
#         
#         # Add monitoring task
#         tasks.append(asyncio.create_task(self.monitor_services(), name="Service-Monitor"))
#         
#         # Store tasks for cleanup
#         self.service_tasks = tasks
#         
#         self.logger.info("✅ All service tasks created")
# 
#     async def monitor_services(self):
#         """Monitor service health and status"""
#         self.logger.info("👁️  Service monitor started")
#         
#         while self.is_running:
#             try:
#                 await asyncio.sleep(60)  # Check every minute
#                 
#                 # Log service status
#                 self.logger.info("📊 Service Status Report:")
#                 
#                 # CNN Service status
#                 cnn_status = {
#                     'model_loaded': self.services['cnn'].model is not None,
#                     'camera_connected': self.services['cnn'].camera is not None,
#                     'hub_connected': self.services['cnn'].hub_client.is_connected,
#                     'processing': self.services['cnn'].is_processing
#                 }
#                 self.logger.info(f"   🧠 CNN Service: {cnn_status}")
#                 
#                 # Arduino Service status
#                 arduino_status = {
#                     'arduino_connected': self.services['arduino'].is_connected,
#                     'hub_connected': self.services['arduino'].hub_client.is_connected,
#                     'processing_state': self.services['arduino'].processing_state,
#                     'current_item': self.services['arduino'].current_item_id
#                 }
#                 self.logger.info(f"   🔧 Arduino Service: {arduino_status}")
#                 
#                 # Check for any failed connections and attempt recovery
#                 if not self.services['cnn'].hub_client.is_connected:
#                     self.logger.warning("⚠️  CNN Service hub disconnected, attempting reconnect...")
#                     await self.services['cnn'].hub_client.ensure_connection()
#                 
#                 if not self.services['arduino'].hub_client.is_connected:
#                     self.logger.warning("⚠️  Arduino Service hub disconnected, attempting reconnect...")
#                     await self.services['arduino'].hub_client.ensure_connection()
#                     
#             except Exception as e:
#                 self.logger.error(f"Error in service monitor: {e}")
# 
#     async def run_services(self):
#         """Run all services until interrupted"""
#         try:
#             if not await self.start_services():
#                 return
#                 
#             # Wait for all service tasks to complete (they run indefinitely)
#             await asyncio.gather(*self.service_tasks)
#             
#         except KeyboardInterrupt:
#             self.logger.info("🛑 Shutdown signal received...")
#         except Exception as e:
#             self.logger.error(f"💥 Unexpected error in service execution: {e}")
#         finally:
#             await self.cleanup_services()
# 
#     async def cleanup_services(self):
#         """Cleanup all services"""
#         self.logger.info("🧹 Cleaning up services...")
#         self.is_running = False
#         
#         # Cancel all running tasks
#         if hasattr(self, 'service_tasks'):
#             for task in self.service_tasks:
#                 if not task.done():
#                     task.cancel()
#             
#             # Wait for tasks to complete cancellation
#             await asyncio.gather(*self.service_tasks, return_exceptions=True)
#         
#         # Cleanup individual services
#         cleanup_tasks = []
#         
#         if 'cnn' in self.services:
#             cleanup_tasks.append(self.services['cnn'].cleanup())
#             
#         if 'arduino' in self.services:
#             cleanup_tasks.append(self.services['arduino'].cleanup())
#         
#         if cleanup_tasks:
#             await asyncio.gather(*cleanup_tasks, return_exceptions=True)
#         
#         self.logger.info("✅ Service cleanup complete")
#         self.logger.info("👋 Smart Recycling Bin services stopped")
# 
#     def setup_signal_handlers(self):
#         """Setup signal handlers for graceful shutdown"""
#         def signal_handler(signum, frame):
#             self.logger.info(f"Received signal {signum}")
#             # Create a new event loop task for cleanup
#             loop = asyncio.get_event_loop()
#             loop.create_task(self.cleanup_services())
#             
#         signal.signal(signal.SIGINT, signal_handler)
#         signal.signal(signal.SIGTERM, signal_handler)
# 
# 
# async def main():
#     """Main entry point for orchestrated services"""
#     orchestrator = SmartRecyclingBinOrchestrator()
#     orchestrator.setup_signal_handlers()
#     
#     logger.info("🎯 Smart Recycling Bin - Orchestrated Services Starting...")
#     logger.info("💡 This integrates your Expert System with CNN and Arduino services")
#     logger.info("🏢 Make sure the C# backend is running: cd backend && dotnet run")
#     logger.info("⚛️  Frontend dashboard available at: http://localhost:3000")
#     logger.info("=" * 80)
#     
#     try:
#         await orchestrator.run_services()
#     except Exception as e:
#         logger.error(f"💥 Failed to run services: {e}")
#         sys.exit(1)
# 
# 
# def run_orchestrated_services():
#     """Entry point for running orchestrated services"""
#     try:
#         asyncio.run(main())
#     except KeyboardInterrupt:
#         logger.info("👋 Orchestrated services stopped by user")
#     except Exception as e:
#         logger.error(f"💥 Orchestrated services failed: {e}")
#         sys.exit(1)
# 
# 
# if __name__ == "__main__":
#     run_orchestrated_services()
# 

"""
Enhanced Main Orchestrated Service Integration
Coordinates CNN, Arduino, and Expert System with Backend
Now includes HTTP health endpoints for backend monitoring
"""

import asyncio
import logging
import sys
import os
from pathlib import Path
import signal
from aiohttp import web, ClientSession
import json
from datetime import datetime
import threading
import time

# Add src to path
src_path = Path(__file__).parent / "src"
sys.path.insert(0, str(src_path))

# Import the enhanced services
from services.cnn_service import CNNService
from services.arduino_service import EnhancedArduinoService

# Setup comprehensive logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('../logs/orchestrated_services.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger("OrchestratedServices")

class HealthService:
    """HTTP Health Service for backend monitoring"""
    
    def __init__(self, orchestrator):
        self.orchestrator = orchestrator
        self.start_time = datetime.utcnow()
        
    async def health_check(self, request):
        """Main health check endpoint"""
        try:
            # Get service health status
            cnn_healthy = (
                hasattr(self.orchestrator.services, 'cnn') and 
                self.orchestrator.services.get('cnn') is not None and
                getattr(self.orchestrator.services.get('cnn'), 'model', None) is not None
            )
            
            arduino_healthy = (
                hasattr(self.orchestrator.services, 'arduino') and 
                self.orchestrator.services.get('arduino') is not None
            )
            
            # Calculate uptime
            uptime_seconds = (datetime.utcnow() - self.start_time).total_seconds()
            
            health_data = {
                "status": "healthy" if (cnn_healthy and arduino_healthy) else "degraded",
                "timestamp": datetime.utcnow().isoformat(),
                "services": {
                    "cnn_service": {
                        "healthy": cnn_healthy,
                        "model_loaded": cnn_healthy,
                        "last_check": datetime.utcnow().isoformat()
                    },
                    "arduino_service": {
                        "healthy": arduino_healthy,
                        "connected": arduino_healthy,
                        "last_check": datetime.utcnow().isoformat()
                    }
                },
                "metrics": {
                    "uptime_seconds": uptime_seconds,
                    "uptime_minutes": uptime_seconds / 60,
                    "is_processing": getattr(self.orchestrator, 'is_running', False)
                },
                "version": "1.0.0"
            }
            
            return web.json_response(health_data, status=200)
            
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return web.json_response({
                "status": "unhealthy",
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }, status=503)
    
    async def cnn_health(self, request):
        """CNN-specific health check"""
        try:
            cnn_service = self.orchestrator.services.get('cnn')
            if not cnn_service:
                return web.json_response({"status": "service_not_found"}, status=503)
            
            health_data = {
                "status": "healthy" if cnn_service.model is not None else "unhealthy",
                "model_loaded": cnn_service.model is not None,
                "camera_available": getattr(cnn_service, 'camera', None) is not None,
                "hub_connected": getattr(cnn_service.hub_client, 'is_connected', False),
                "processing": getattr(cnn_service, 'is_processing', False),
                "timestamp": datetime.utcnow().isoformat()
            }
            
            return web.json_response(health_data, status=200)
            
        except Exception as e:
            return web.json_response({
                "status": "error",
                "error": str(e)
            }, status=503)
    
    async def arduino_health(self, request):
        """Arduino-specific health check"""
        try:
            arduino_service = self.orchestrator.services.get('arduino')
            if not arduino_service:
                return web.json_response({"status": "service_not_found"}, status=503)
            
            health_data = {
                "status": "healthy" if getattr(arduino_service, 'is_connected', False) else "unhealthy",
                "arduino_connected": getattr(arduino_service, 'is_connected', False),
                "hub_connected": getattr(arduino_service.hub_client, 'is_connected', False),
                "port": getattr(arduino_service, 'port', 'unknown'),
                "baudrate": getattr(arduino_service, 'baudrate', 'unknown'),
                "timestamp": datetime.utcnow().isoformat()
            }
            
            return web.json_response(health_data, status=200)
            
        except Exception as e:
            return web.json_response({
                "status": "error",
                "error": str(e)
            }, status=503)

class SmartRecyclingBinOrchestrator:
    """Main orchestrator that coordinates all services"""
    
    def __init__(self):
        self.logger = logging.getLogger("Orchestrator")
        self.services = {}
        self.is_running = False
        self.health_service = HealthService(self)
        
        # Configuration from environment
        self.config = {
            'model_path': os.getenv('MODEL_PATH', '../models/trash_classifier_v3_93_accuracy_4mp.keras'),
            'arduino_port': os.getenv('ARDUINO_PORT', '/dev/ttyUSB0'),
            'arduino_baudrate': int(os.getenv('ARDUINO_BAUDRATE', '9600')),
            'backend_hub_url': os.getenv('BACKEND_URL', 'http://localhost:5099/hubs/classification'),
            'camera_index': int(os.getenv('CAMERA_INDEX', '0')),
            'health_port_cnn': int(os.getenv('CNN_HEALTH_PORT', '8001')),
            'health_port_arduino': int(os.getenv('ARDUINO_HEALTH_PORT', '8002'))
        }
    
    async def setup_health_servers(self):
        """Setup HTTP health check servers"""
        self.logger.info("🏥 Setting up health check servers...")
        
        # CNN Service Health Server (port 8001)
        cnn_app = web.Application()
        cnn_app.router.add_get('/health', self.health_service.health_check)
        cnn_app.router.add_get('/status', self.health_service.cnn_health)
        
        # Arduino Service Health Server (port 8002) 
        arduino_app = web.Application()
        arduino_app.router.add_get('/health', self.health_service.health_check)
        arduino_app.router.add_get('/status', self.health_service.arduino_health)
        
        # Start health servers
        cnn_runner = web.AppRunner(cnn_app)
        arduino_runner = web.AppRunner(arduino_app)
        
        await cnn_runner.setup()
        await arduino_runner.setup()
        
        cnn_site = web.TCPSite(cnn_runner, 'localhost', self.config['health_port_cnn'])
        arduino_site = web.TCPSite(arduino_runner, 'localhost', self.config['health_port_arduino'])
        
        await cnn_site.start()
        await arduino_site.start()
        
        self.logger.info(f"✅ CNN Health Server: http://localhost:{self.config['health_port_cnn']}/health")
        self.logger.info(f"✅ Arduino Health Server: http://localhost:{self.config['health_port_arduino']}/health")
        
        # Store runners for cleanup
        self.health_runners = [cnn_runner, arduino_runner]
        
    async def start_services(self):
        """Start and coordinate all services"""
        self.logger.info("🚀 Starting Smart Recycling Bin Orchestrated Services...")
        self.logger.info("=" * 80)
        
        try:
            # Log configuration
            self.logger.info("📋 Configuration:")
            for key, value in self.config.items():
                self.logger.info(f"   {key}: {value}")
            self.logger.info("=" * 80)
            
            # Setup health servers FIRST
            await self.setup_health_servers()
            
            # Check prerequisites
            if not await self.check_prerequisites():
                self.logger.error("❌ Prerequisites check failed")
                return False
            
            # Initialize services
            await self.initialize_services()
            
            # Setup service integration
            await self.setup_service_integration()
            
            # Start all services
            await self.start_all_services()
            
            self.is_running = True
            self.logger.info("✅ All services started successfully!")
            self.logger.info("🎯 Smart Recycling Bin is operational and ready for items")
            self.logger.info("=" * 80)
            
            return True
            
        except Exception as e:
            self.logger.error(f"💥 Failed to start services: {e}")
            return False

    async def check_prerequisites(self) -> bool:
        """Check if all prerequisites are met"""
        self.logger.info("🔍 Checking prerequisites...")
        
        # Check if model file exists
        if not os.path.exists(self.config['model_path']):
            self.logger.error(f"❌ Model file not found: {self.config['model_path']}")
            self.logger.error("📋 Please add your trained model to the models/ directory")
            return False
        
        # Check if backend is accessible (optional warning)
        try:
            import aiohttp
            async with aiohttp.ClientSession() as session:
                async with session.get(f"http://localhost:5099/health", timeout=5) as response:
                    if response.status == 200:
                        self.logger.info("✅ Backend health check passed")
                    else:
                        self.logger.warning("⚠️  Backend may not be fully ready")
        except Exception as e:
            self.logger.warning(f"⚠️  Backend connection check failed: {e}")
            self.logger.info("🏢 Make sure the C# backend is running: cd backend && dotnet run")
        
        # Check camera access
        try:
            import cv2
            camera = cv2.VideoCapture(self.config['camera_index'])
            if camera.isOpened():
                self.logger.info("✅ Camera access verified")
                camera.release()
            else:
                self.logger.warning(f"⚠️  Camera {self.config['camera_index']} not accessible - will use mock data")
        except Exception as e:
            self.logger.warning(f"⚠️  Camera check failed: {e}")
        
        # Check Arduino port
        try:
            import serial
            ser = serial.Serial(self.config['arduino_port'], self.config['arduino_baudrate'], timeout=1)
            self.logger.info(f"✅ Arduino port {self.config['arduino_port']} accessible")
            ser.close()
        except Exception as e:
            self.logger.warning(f"⚠️  Arduino port {self.config['arduino_port']} not accessible - will use mock data")
        
        self.logger.info("✅ Prerequisites check completed")
        return True

    async def initialize_services(self):
        """Initialize all services"""
        self.logger.info("🔧 Initializing services...")
        
        # Initialize CNN Service
        self.services['cnn'] = CNNService(
            self.config['model_path'],
            self.config['backend_hub_url']
        )
        self.logger.info("✅ CNN Service initialized")
        
        # Initialize Arduino Service
        self.services['arduino'] = EnhancedArduinoService(
            self.config['arduino_port'],
            self.config['arduino_baudrate'],
            self.config['backend_hub_url']
        )
        self.logger.info("✅ Arduino Service initialized")
        
    async def setup_service_integration(self):
        """Setup integration between services"""
        self.logger.info("🔗 Setting up service integration...")
        
        # Integrate Arduino with CNN service
        self.services['arduino'].set_cnn_service(self.services['cnn'])
        self.services['cnn'].set_arduino_service(self.services['arduino'])
        
        # Set up communication callbacks
        self.services['arduino'].set_classification_callback(self.handle_classification_trigger)
        
        self.logger.info("✅ Service integration complete")

    async def handle_classification_trigger(self, trigger_data: dict):
        """Handle classification trigger from Arduino service"""
        try:
            self.logger.info(f"🎯 Classification triggered: {trigger_data['detection_id']}")
            
            # This is called when Arduino detects an item and CNN service is not directly integrated
            # Could be used for additional coordination logic
            
            # Example: Add custom pre-processing or validation here
            
        except Exception as e:
            self.logger.error(f"Error handling classification trigger: {e}")

    async def start_all_services(self):
        """Start all services concurrently"""
        self.logger.info("▶️  Starting all services...")
        
        # Create service tasks
        tasks = [
            asyncio.create_task(self.services['cnn'].start_service(), name="CNN-Service"),
            asyncio.create_task(self.services['arduino'].start_service(), name="Arduino-Service")
        ]
        
        # Add monitoring task
        tasks.append(asyncio.create_task(self.monitor_services(), name="Service-Monitor"))
        
        # Store tasks for cleanup
        self.service_tasks = tasks
        
        self.logger.info("✅ All service tasks created")

    async def monitor_services(self):
        """Monitor service health and status"""
        self.logger.info("👁️  Service monitor started")
        
        while self.is_running:
            try:
                await asyncio.sleep(60)  # Check every minute
                
                # Log service status
                self.logger.info("📊 Service Status Report:")
                
                # CNN Service status
                cnn_status = {
                    'model_loaded': self.services['cnn'].model is not None,
                    'camera_connected': self.services['cnn'].camera is not None,
                    'hub_connected': self.services['cnn'].hub_client.is_connected,
                    'processing': self.services['cnn'].is_processing
                }
                self.logger.info(f"   🧠 CNN Service: {cnn_status}")
                
                # Arduino Service status
                arduino_status = {
                    'arduino_connected': self.services['arduino'].is_connected,
                    'hub_connected': self.services['arduino'].hub_client.is_connected,
                    'processing_state': self.services['arduino'].processing_state,
                    'current_item': self.services['arduino'].current_item_id
                }
                self.logger.info(f"   🔧 Arduino Service: {arduino_status}")
                
                # Check for any failed connections and attempt recovery
                if not self.services['cnn'].hub_client.is_connected:
                    self.logger.warning("⚠️  CNN Service hub disconnected, attempting reconnect...")
                    await self.services['cnn'].hub_client.ensure_connection()
                
                if not self.services['arduino'].hub_client.is_connected:
                    self.logger.warning("⚠️  Arduino Service hub disconnected, attempting reconnect...")
                    await self.services['arduino'].hub_client.ensure_connection()
                    
            except Exception as e:
                self.logger.error(f"Error in service monitor: {e}")

    async def run_services(self):
        """Run all services until interrupted"""
        try:
            if not await self.start_services():
                return
                
            # Wait for all service tasks to complete (they run indefinitely)
            await asyncio.gather(*self.service_tasks)
            
        except KeyboardInterrupt:
            self.logger.info("🛑 Shutdown signal received...")
        except Exception as e:
            self.logger.error(f"💥 Unexpected error in service execution: {e}")
        finally:
            await self.cleanup_services()

    async def cleanup_services(self):
        """Cleanup all services"""
        self.logger.info("🧹 Cleaning up services...")
        self.is_running = False
        
        # Cancel all running tasks
        if hasattr(self, 'service_tasks'):
            for task in self.service_tasks:
                if not task.done():
                    task.cancel()
            
            # Wait for tasks to complete cancellation
            await asyncio.gather(*self.service_tasks, return_exceptions=True)
        
        # Cleanup health servers
        if hasattr(self, 'health_runners'):
            for runner in self.health_runners:
                await runner.cleanup()
        
        # Cleanup services
        if 'cnn' in self.services:
            await self.services['cnn'].cleanup()
        if 'arduino' in self.services:
            await self.services['arduino'].cleanup()
            
        self.logger.info("✅ Services cleanup completed")

async def main():
    """Main entry point"""
    orchestrator = SmartRecyclingBinOrchestrator()
    
    # Setup signal handlers for graceful shutdown
    def signal_handler(signum, frame):
        logger.info(f"🛑 Received signal {signum}, initiating graceful shutdown...")
        
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    try:
        await orchestrator.run_services()
    except Exception as e:
        logger.error(f"💥 Critical error: {e}")
    finally:
        logger.info("🏁 Smart Recycling Bin services stopped")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("🛑 Application interrupted by user")
    except Exception as e:
        logger.error(f"💥 Application failed: {e}")
        sys.exit(1)




FILE: python-services/pytest.ini
------------------------------------------------------------
Size: 441 B
Encoding: ascii
------------------------------------------------------------
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --disable-warnings
    --cov=src/smart_bin
    --cov-report=html
    --cov-report=term-missing
    --cov-report=xml
    --capture=no
log_cli = true
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(name)s: %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S



FILE: python-services/requirements.txt
------------------------------------------------------------
Size: 16 B
Encoding: ascii
------------------------------------------------------------
experta>=1.9.4




FILE: python-services/requirements_integrated.txt
------------------------------------------------------------
Size: 141 B
Encoding: ascii
------------------------------------------------------------
experta>=1.9.4
tensorflow>=2.12.0
opencv-python>=4.7.0
numpy>=1.24.0
aiohttp>=3.8.0
websockets>=11.0
pyserial>=3.5
python-json-logger>=2.0.7



FILE: python-services/services/arduino_service.py
------------------------------------------------------------
Size: 19.7 KB
Encoding: Windows-1252
------------------------------------------------------------
"""
Updated Arduino Service with Enhanced Integration
Coordinates with CNN service for full pipeline processing
"""

import asyncio
import serial
import json
import logging
from datetime import datetime
from typing import Dict, Optional, List, Callable

from .hub_client import SignalRHubClient

class EnhancedArduinoService:
    """Enhanced Arduino Service with CNN service coordination"""
    
    def __init__(self, port: str = '/dev/ttyUSB0', baudrate: int = 9600, 
                 backend_hub_url: str = "http://localhost:5099/hubs/classification"):
        self.port = port
        self.baudrate = baudrate
        self.serial_connection = None
        self.is_connected = False
        self.hub_client = SignalRHubClient(backend_hub_url, "ClassificationHub")
        self.logger = logging.getLogger("EnhancedArduinoService")
        
        # Calibration values
        self.weight_offset = 0.0
        self.last_weight = 0.0
        self.item_detection_threshold = 5.0  # grams
        
        # CNN service integration
        self.cnn_service = None  # Will be injected
        self.classification_callback = None
        
        # State management
        self.current_item_id = None
        self.processing_state = "idle"  # idle, detecting, processing, waiting_removal
        
    async def start_service(self):
        """Start the enhanced Arduino service"""
        self.logger.info("ðŸš€ Starting Enhanced Arduino Service...")
        
        try:
            # Connect to SignalR hub
            if not await self.hub_client.connect():
                self.logger.error("Failed to connect to backend hub")
                return
                
            # Join classification group
            await self.hub_client.send_message("JoinClassificationGroup", "")
                
            # Connect to Arduino
            if not await self.connect_arduino():
                self.logger.warning("Failed to connect to Arduino, running in simulation mode")
                
            # Start monitoring workers
            await asyncio.gather(
                self.sensor_monitoring_worker(),
                self.state_management_worker(),
                self.heartbeat_worker()
            )
            
        except Exception as e:
            self.logger.error(f"Failed to start enhanced Arduino service: {e}")
            raise
    
    async def connect_arduino(self) -> bool:
        """Connect to Arduino"""
        try:
            self.logger.info(f"Connecting to Arduino on {self.port} at {self.baudrate} baud...")
            
            self.serial_connection = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                timeout=2
            )
            
            # Wait for Arduino to initialize
            await asyncio.sleep(3)
            
            # Test connection by reading initial sensor state
            test_reading = await self.read_sensors()
            if test_reading:
                self.is_connected = True
                self.logger.info(f"âœ… Connected to Arduino on {self.port}")
                
                # Calibrate sensors
                await self.calibrate_sensors()
                return True
                
        except serial.SerialException as e:
            self.logger.error(f"Serial connection failed: {e}")
        except Exception as e:
            self.logger.error(f"Failed to connect to Arduino: {e}")
            
        self.is_connected = False
        return False
    
    async def sensor_monitoring_worker(self):
        """Worker that continuously monitors sensors"""
        self.logger.info("ðŸ”„ Sensor monitoring worker started")
        
        while True:
            try:
                # Ensure hub connection
                await self.hub_client.ensure_connection()
                
                # Read sensor data
                sensor_data = await self.read_sensors()
                
                if sensor_data:
                    await self.process_sensor_reading(sensor_data)
                
                # Monitor at 2Hz (500ms intervals)
                await asyncio.sleep(0.5)
                
            except KeyboardInterrupt:
                self.logger.info("ðŸ›‘ Shutting down Arduino service...")
                break
            except Exception as e:
                self.logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(1)

    async def process_sensor_reading(self, sensor_data: Dict):
        """Process sensor reading and manage item detection state"""
        current_weight = sensor_data["weight_grams"]
        
        if self.processing_state == "idle":
            # Check for new item detection
            if self.detect_item_placement(current_weight):
                await self.handle_item_detected(sensor_data)
                
        elif self.processing_state == "processing":
            # Item is being processed, continue monitoring
            pass
            
        elif self.processing_state == "waiting_removal":
            # Check for item removal
            if self.detect_item_removal(current_weight):
                await self.handle_item_removed()
        
        self.last_weight = current_weight

    async def handle_item_detected(self, sensor_data: Dict):
        """Handle new item detection"""
        self.processing_state = "processing"
        self.current_item_id = f"item_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        
        self.logger.info(f"ðŸ“¦ Item detected: {self.current_item_id}")
        self.logger.info(f"   Weight: {sensor_data['weight_grams']:.1f}g")
        self.logger.info(f"   Metal: {sensor_data['is_metal']}")
        self.logger.info(f"   Moist: {sensor_data['is_moist']}")
        
        # Send item detection alert to backend
        detection_alert = {
            "type": "item_detected",
            "item_id": self.current_item_id,
            "sensor_data": sensor_data,
            "timestamp": datetime.now().isoformat()
        }
        
        await self.hub_client.send_message("NotifyItemDetection", json.dumps(detection_alert))
        
        # If CNN service is integrated, trigger full classification
        if self.cnn_service:
            try:
                await self.trigger_full_classification(sensor_data)
            except Exception as e:
                self.logger.error(f"Failed to trigger CNN classification: {e}")
                self.processing_state = "waiting_removal"
        else:
            # Fallback: send sensor-only classification
            await self.send_sensor_only_classification(sensor_data)
            self.processing_state = "waiting_removal"

    async def trigger_full_classification(self, sensor_data: Dict):
        """Trigger full classification pipeline through CNN service"""
        try:
            classification_request = {
                "detection_id": self.current_item_id,
                "timestamp": datetime.now().isoformat(),
                "trigger_source": "arduino_sensor",
                "sensor_data": sensor_data,
                "request_full_pipeline": True
            }
            
            # If we have a direct reference to CNN service, call it
            if hasattr(self.cnn_service, 'process_complete_pipeline'):
                result = await self.cnn_service.process_complete_pipeline(classification_request)
                if result:
                    self.logger.info(f"âœ… Full pipeline completed: {result['expert_system_result']['final_classification']}")
            
            # If we have a callback, use it
            elif self.classification_callback:
                await self.classification_callback(classification_request)
            
            self.processing_state = "waiting_removal"
            
        except Exception as e:
            self.logger.error(f"Error triggering full classification: {e}")
            self.processing_state = "waiting_removal"

    async def send_sensor_only_classification(self, sensor_data: Dict):
        """Send sensor-only classification when CNN is not available"""
        try:
            # Basic sensor-based classification
            classification = self.classify_by_sensors(sensor_data)
            
            sensor_result = {
                "detection_id": self.current_item_id,
                "timestamp": datetime.now().isoformat(),
                "processing_time_ms": 50,  # Sensor processing is fast
                
                "sensor_data": sensor_data,
                
                "expert_system_result": {
                    "final_classification": classification["material"],
                    "confidence": classification["confidence"],
                    "disposal_location": classification["disposal_location"],
                    "reasoning": "Sensor-only classification (CNN unavailable)",
                    "processing_stage": "sensor_fallback"
                },
                
                "processing_metadata": {
                    "pipeline_version": "sensor_only_v1.0",
                    "processing_node": "arduino_service",
                    "fallback_used": True,
                    "cnn_available": False
                }
            }
            
            await self.hub_client.send_message("SendClassificationResult", json.dumps(sensor_result))
            self.logger.info(f"âœ… Sensor-only classification sent: {classification['material']}")
            
        except Exception as e:
            self.logger.error(f"Error sending sensor-only classification: {e}")

    def classify_by_sensors(self, sensor_data: Dict) -> Dict:
        """Basic sensor-only classification logic"""
        weight = sensor_data.get("weight_grams", 0)
        is_metal = sensor_data.get("is_metal", False)
        is_moist = sensor_data.get("is_moist", False)
        humidity = sensor_data.get("humidity_percent", 0)
        
        # Simple rule-based classification
        if is_metal:
            return {
                "material": "metal",
                "confidence": 0.95,
                "disposal_location": "Metal recycling bin"
            }
        elif is_moist or humidity > 60:
            return {
                "material": "organic",
                "confidence": 0.80,
                "disposal_location": "Organic waste bin"
            }
        elif weight > 100:  # Heavy items likely glass or thick plastic
            return {
                "material": "glass",
                "confidence": 0.60,
                "disposal_location": "Glass recycling bin"
            }
        elif weight < 20:  # Light items likely paper or plastic bags
            return {
                "material": "paper",
                "confidence": 0.50,
                "disposal_location": "Paper recycling bin"
            }
        else:
            return {
                "material": "plastic",
                "confidence": 0.40,
                "disposal_location": "Plastic recycling bin"
            }

    async def handle_item_removed(self):
        """Handle item removal detection"""
        self.logger.info(f"âœ… Item removed: {self.current_item_id}")
        
        # Send removal notification
        removal_alert = {
            "type": "item_removed", 
            "item_id": self.current_item_id,
            "timestamp": datetime.now().isoformat()
        }
        
        await self.hub_client.send_message("ItemRemoved", json.dumps(removal_alert))
        
        # Reset state
        self.current_item_id = None
        self.processing_state = "idle"

    async def state_management_worker(self):
        """Worker that manages processing state and timeouts"""
        while True:
            try:
                await asyncio.sleep(1)  # Check every second
                
                # Handle processing timeout
                if self.processing_state == "processing":
                    # Add timeout logic here if needed
                    pass
                
                # Handle removal timeout  
                elif self.processing_state == "waiting_removal":
                    # Could add auto-reset after timeout
                    pass
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.logger.error(f"Error in state management worker: {e}")

    async def read_sensors(self) -> Optional[Dict]:
        """Read sensor data from Arduino"""
        if not self.is_connected or not self.serial_connection:
            # Return mock data for testing
            return self.generate_mock_sensor_data()
        
        try:
            # Send read command to Arduino
            self.serial_connection.write(b'READ_SENSORS\n')
            await asyncio.sleep(0.1)  # Give Arduino time to respond
            
            # Read response
            if self.serial_connection.in_waiting > 0:
                response = self.serial_connection.readline().decode('utf-8').strip()
                
                if response:
                    # Parse JSON response from Arduino
                    sensor_data = json.loads(response)
                    return self.process_sensor_data(sensor_data)
            
            return None
            
        except json.JSONDecodeError as e:
            self.logger.error(f"Invalid JSON from Arduino: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Error reading sensors: {e}")
            return None

    def process_sensor_data(self, raw_data: Dict) -> Dict:
        """Process raw sensor data into structured format"""
        try:
            processed_data = {
                "timestamp": datetime.now().isoformat(),
                "weight_grams": max(0, float(raw_data.get('weight', 0)) - self.weight_offset),
                "is_metal": bool(raw_data.get('metal_detected', False)),
                "humidity_percent": float(raw_data.get('humidity', 0)),
                "temperature_celsius": float(raw_data.get('temperature', 20)),
                
                # Derived properties
                "is_moist": float(raw_data.get('humidity', 0)) > 60.0,
                "is_transparent": raw_data.get('ir_transparency', 0) > 0.7,
                "is_flexible": (float(raw_data.get('weight', 0)) < 50 and 
                              float(raw_data.get('humidity', 0)) < 30),
                "ir_transparency": raw_data.get('ir_transparency', 0),
                
                # Include raw data for debugging
                "raw_sensor_data": raw_data
            }
            
            return processed_data
            
        except Exception as e:
            self.logger.error(f"Error processing sensor data: {e}")
            return self.generate_mock_sensor_data()

    def generate_mock_sensor_data(self) -> Dict:
        """Generate mock sensor data for testing"""
        import random
        
        # Generate realistic mock data
        weight = random.uniform(5, 500)  # 5g to 500g
        is_metal = random.choice([True, False])
        humidity = random.uniform(20, 80)
        
        return {
            "timestamp": datetime.now().isoformat(),
            "weight_grams": weight,
            "is_metal": is_metal,
            "humidity_percent": humidity,
            "temperature_celsius": random.uniform(18, 25),
            "is_moist": humidity > 60,
            "is_transparent": random.choice([True, False]),
            "is_flexible": weight < 50,  # Light items tend to be flexible
            "ir_transparency": random.uniform(0.3, 0.9),
            "raw_sensor_data": {
                "weight": weight,
                "metal_detected": is_metal,
                "humidity": humidity,
                "temperature": random.uniform(18, 25),
                "ir_transparency": random.uniform(0.3, 0.9)
            }
        }

    def detect_item_placement(self, current_weight: float) -> bool:
        """Detect if an item has been placed on the sensor"""
        weight_change = abs(current_weight - self.last_weight)
        
        # Item detected if weight increases significantly
        if (current_weight > self.item_detection_threshold and 
            weight_change > self.item_detection_threshold):
            return True
            
        return False
    
    def detect_item_removal(self, current_weight: float) -> bool:
        """Detect if an item has been removed from the sensor"""
        return current_weight < self.item_detection_threshold

    async def calibrate_sensors(self) -> bool:
        """Calibrate Arduino sensors (zero the weight sensor)"""
        if not self.is_connected:
            self.logger.warning("Cannot calibrate - Arduino not connected")
            return False
        
        try:
            self.logger.info("ðŸ”§ Calibrating sensors...")
            
            # Read several weight samples to establish baseline
            weight_samples = []
            for _ in range(10):
                sensor_data = await self.read_sensors()
                if sensor_data:
                    weight_samples.append(sensor_data.get('weight_grams', 0))
                await asyncio.sleep(0.1)
            
            if weight_samples:
                self.weight_offset = sum(weight_samples) / len(weight_samples)
                self.logger.info(f"âœ… Weight sensor calibrated (offset: {self.weight_offset:.2f}g)")
                return True
            else:
                self.logger.error("â�Œ Calibration failed - no sensor readings")
                return False
                
        except Exception as e:
            self.logger.error(f"â�Œ Calibration error: {e}")
            return False

    async def heartbeat_worker(self):
        """Send periodic heartbeat to backend"""
        while True:
            try:
                await asyncio.sleep(30)  # Every 30 seconds
                
                heartbeat_data = {
                    "service_name": "enhanced_arduino_service",
                    "timestamp": datetime.now().isoformat(),
                    "status": "healthy",
                    "arduino_connected": self.is_connected,
                    "processing_state": self.processing_state,
                    "current_item_id": self.current_item_id,
                    "cnn_service_integrated": self.cnn_service is not None
                }
                
                await self.hub_client.send_message("SendHeartbeat", json.dumps(heartbeat_data))
                
            except Exception as e:
                self.logger.error(f"Error sending heartbeat: {e}")

    def set_cnn_service(self, cnn_service):
        """Set CNN service for full pipeline integration"""
        self.cnn_service = cnn_service
        self.logger.info("âœ… CNN service integration enabled")

    def set_classification_callback(self, callback: Callable):
        """Set callback for classification trigger"""
        self.classification_callback = callback
        self.logger.info("âœ… Classification callback set")

    async def cleanup(self):
        """Cleanup resources"""
        if self.serial_connection:
            try:
                self.serial_connection.close()
            except:
                pass
            self.is_connected = False
            
        await self.hub_client.disconnect()
        self.logger.info("ðŸ§¹ Enhanced Arduino service cleanup complete")


# Service entry point
async def start_enhanced_arduino_service():
    """Start the enhanced Arduino service"""
    port = os.getenv('ARDUINO_PORT', '/dev/ttyUSB0')
    baudrate = int(os.getenv('ARDUINO_BAUDRATE', '9600'))
    backend_url = os.getenv('BACKEND_URL', 'http://localhost:5099/hubs/classification')
    
    service = EnhancedArduinoService(port, baudrate, backend_url)
    await service.start_service()

if __name__ == "__main__":
    import os
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    asyncio.run(start_enhanced_arduino_service())



FILE: python-services/services/cnn_service.py
------------------------------------------------------------
Size: 22.3 KB
Encoding: Windows-1252
------------------------------------------------------------
"""
Enhanced CNN Service - Full Process Orchestration
Integrates Arduino sensors, CNN processing, and expert system
"""

import asyncio
import cv2
import numpy as np
import tensorflow as tf
from typing import Dict, Optional, List, Tuple
from datetime import datetime
import logging
import json
import sys
import os
from pathlib import Path

# Add src to path to import expert system
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from .hub_client import SignalRHubClient

try:
    # Import expert system components
    from smart_bin.core.knowledge_engine import SmartBinKnowledgeEngine
    from smart_bin.core.facts import WasteFact
    from smart_bin.models.waste_types import WasteCategory
except ImportError as e:
    logging.warning(f"Could not import expert system components: {e}")
    SmartBinKnowledgeEngine = None
    WasteFact = None

class CNNService:
    """Enhanced CNN Service with full process orchestration"""
    
    def __init__(self, model_path: str, backend_hub_url: str = "http://localhost:5099/hubs/classification"):
        self.model_path = model_path
        self.model = None
        self.camera = None
        self.hub_client = SignalRHubClient(backend_hub_url, "ClassificationHub")
        self.logger = logging.getLogger("EnhancedCNNService")
        
        # Model configuration
        self.classes = ['cardboard', 'glass', 'metal', 'paper', 'plastic']
        self.confidence_threshold = 0.85
        self.expert_system = SmartBinKnowledgeEngine() if SmartBinKnowledgeEngine else None
        
        # Arduino communication
        self.arduino_service = None  # Will be injected
        
        # Processing queue for items
        self.processing_queue = asyncio.Queue()
        self.is_processing = False
        
    async def start_service(self):
        """Start the enhanced CNN service with full orchestration"""
        self.logger.info("ðŸš€ Starting Enhanced CNN Service with Full Orchestration...")
        
        try:
            # Load the CNN model
            await self.load_model()
            
            # Connect to SignalR hub
            if not await self.hub_client.connect():
                self.logger.error("Failed to connect to backend hub")
                return
                
            # Join classification group
            await self.hub_client.send_message("JoinClassificationGroup", "")
            
            # Initialize camera
            await self.initialize_camera()
            
            # Start processing workers
            await asyncio.gather(
                self.item_detection_worker(),
                self.classification_worker(),
                self.heartbeat_worker()
            )
            
        except Exception as e:
            self.logger.error(f"Failed to start enhanced CNN service: {e}")
            raise

    async def load_model(self):
        """Load the TensorFlow model"""
        try:
            if not os.path.exists(self.model_path):
                raise FileNotFoundError(f"Model file not found: {self.model_path}")
            
            self.logger.info(f"Loading model from: {self.model_path}")
            self.model = tf.keras.models.load_model(self.model_path)
            self.logger.info("âœ… CNN model loaded successfully")
            
            # Log model info
            self.logger.info(f"Model input shape: {self.model.input_shape}")
            self.logger.info(f"Model output shape: {self.model.output_shape}")
            
        except Exception as e:
            self.logger.error(f"Failed to load model: {e}")
            raise
    
    async def initialize_camera(self):
        """Initialize USB camera"""
        try:
            camera_index = int(os.getenv('CAMERA_INDEX', '0'))
            self.camera = cv2.VideoCapture(camera_index)
            
            if not self.camera.isOpened():
                raise Exception(f"Cannot open camera at index {camera_index}")
            
            # Set camera properties
            self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 384)
            self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 384)
            self.camera.set(cv2.CAP_PROP_FPS, 30)
            
            self.logger.info("âœ… Camera initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize camera: {e}")
            # Continue without camera for testing
            self.camera = None

    async def item_detection_worker(self):
        """Worker that detects when items are placed for processing"""
        self.logger.info("ðŸ”� Item detection worker started")
        
        while True:
            try:
                # For demonstration, trigger every 10 seconds
                # In real implementation, this would be triggered by:
                # 1. Arduino sensor detecting item placement
                # 2. External API call
                # 3. Manual trigger from dashboard
                
                await asyncio.sleep(10)
                
                # Mock item detection - replace with actual trigger logic
                item_data = {
                    "detection_id": f"item_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    "timestamp": datetime.now().isoformat(),
                    "trigger_source": "mock_sensor",
                    "item_present": True
                }
                
                self.logger.info(f"ðŸ“¦ Item detected: {item_data['detection_id']}")
                
                # Add to processing queue
                await self.processing_queue.put(item_data)
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.logger.error(f"Error in item detection worker: {e}")
                await asyncio.sleep(1)

    async def classification_worker(self):
        """Worker that processes items through the full classification pipeline"""
        self.logger.info("ðŸ”„ Classification worker started")
        
        while True:
            try:
                # Wait for item to process
                item_data = await self.processing_queue.get()
                
                if self.is_processing:
                    self.logger.warning("Already processing an item, queuing...")
                    await self.processing_queue.put(item_data)  # Put it back
                    await asyncio.sleep(0.1)
                    continue
                
                self.is_processing = True
                
                try:
                    # Process the complete classification pipeline
                    result = await self.process_complete_pipeline(item_data)
                    
                    if result:
                        # Send result to backend
                        await self.send_classification_result(result)
                    
                finally:
                    self.is_processing = False
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.logger.error(f"Error in classification worker: {e}")
                self.is_processing = False

    async def process_complete_pipeline(self, item_data: Dict) -> Optional[Dict]:
        """Process complete classification pipeline: sensors â†’ CNN â†’ expert system"""
        try:
            start_time = datetime.now()
            detection_id = item_data["detection_id"]
            
            self.logger.info(f"ðŸ”¬ Starting complete pipeline for {detection_id}")
            
            # Step 1: Capture image
            self.logger.info("ðŸ“· Capturing image...")
            image_array = await self.capture_image()
            if image_array is None:
                self.logger.error("Failed to capture image")
                return None
            
            # Step 2: Get sensor data from Arduino
            self.logger.info("ðŸ“Š Reading sensor data...")
            sensor_data = await self.get_sensor_data()
            
            # Step 3: CNN Stage 1 processing
            self.logger.info("ðŸ§  Running CNN Stage 1 classification...")
            stage1_result = await self.run_cnn_stage1(image_array)
            
            # Step 4: CNN Stage 2 processing (if needed)
            stage2_result = None
            if stage1_result.get("predicted_class") == "plastic" and stage1_result.get("confidence", 0) > self.confidence_threshold:
                self.logger.info("ðŸ§  Running CNN Stage 2 (plastic specialization)...")
                stage2_result = await self.run_cnn_stage2(image_array)
            
            # Step 5: Expert system integration
            self.logger.info("ðŸŽ¯ Running expert system validation...")
            expert_result = await self.run_expert_system_integration(
                stage1_result, 
                stage2_result, 
                sensor_data
            )
            
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            
            # Compile complete result
            complete_result = {
                "detection_id": detection_id,
                "timestamp": item_data["timestamp"],
                "processing_time_ms": processing_time,
                
                # CNN Results
                "cnn_prediction": {
                    "stage1": stage1_result,
                    "stage2": stage2_result,
                    "total_confidence": expert_result.get("confidence", 0)
                },
                
                # Sensor Data
                "sensor_data": sensor_data,
                
                # Expert System Result  
                "expert_system_result": expert_result,
                
                # Processing Metadata
                "processing_metadata": {
                    "pipeline_version": "enhanced_v1.0",
                    "model_version": "trash_classifier_v3_93",
                    "processing_node": os.uname().nodename if hasattr(os, 'uname') else 'unknown',
                    "stages_completed": ["stage1", "stage2" if stage2_result else None, "expert_system"],
                    "fallback_used": stage1_result.get("confidence", 0) < self.confidence_threshold
                }
            }
            
            self.logger.info(f"âœ… Pipeline complete for {detection_id}: {expert_result.get('final_classification')} (confidence: {expert_result.get('confidence', 0):.2f})")
            
            return complete_result
            
        except Exception as e:
            self.logger.error(f"Error in complete pipeline: {e}")
            return None

    async def get_sensor_data(self) -> Dict:
        """Get sensor data from Arduino service or mock data"""
        try:
            if self.arduino_service:
                # Get real sensor data from Arduino service
                return await self.arduino_service.read_sensors()
            else:
                # Mock sensor data for development
                import random
                return {
                    "weight_grams": random.uniform(5, 500),
                    "is_metal": random.choice([True, False]),
                    "humidity_percent": random.uniform(20, 80),
                    "temperature_celsius": random.uniform(18, 25),
                    "is_moist": random.choice([True, False]),
                    "is_transparent": random.choice([True, False]),
                    "is_flexible": random.choice([True, False]),
                    "ir_transparency": random.uniform(0.3, 0.9),
                    "sensor_timestamp": datetime.now().isoformat()
                }
        except Exception as e:
            self.logger.error(f"Error getting sensor data: {e}")
            return {}

    async def run_cnn_stage1(self, image: np.ndarray) -> Dict:
        """Run Stage 1 CNN classification"""
        try:
            # Preprocess image
            processed_image = self.preprocess_image(image)
            
            # Run prediction
            predictions = self.model.predict(processed_image, verbose=0)
            
            # Extract results
            confidence = float(np.max(predictions))
            class_idx = int(np.argmax(predictions))
            predicted_class = self.classes[class_idx]
            
            return {
                "stage": 1,
                "predicted_class": predicted_class,
                "confidence": confidence,
                "class_probabilities": {
                    class_name: float(prob) 
                    for class_name, prob in zip(self.classes, predictions[0])
                },
                "processing_stage": "stage1_cnn",
                "requires_stage2": predicted_class == "plastic" and confidence > self.confidence_threshold
            }
            
        except Exception as e:
            self.logger.error(f"Stage 1 CNN failed: {e}")
            return {
                "stage": 1,
                "predicted_class": "unknown",
                "confidence": 0.0,
                "error": str(e)
            }

    async def run_cnn_stage2(self, image: np.ndarray) -> Dict:
        """Run Stage 2 CNN classification (plastic specialization)"""
        try:
            # In real implementation, this would use a specialized plastic model
            # For now, simulate plastic subcategorization
            plastic_types = ['PET_bottle', 'plastic_bag', 'container', 'food_packaging']
            
            # Mock plastic classification - replace with actual Stage 2 model
            import random
            predicted_plastic = random.choice(plastic_types)
            confidence = random.uniform(0.7, 0.95)
            
            return {
                "stage": 2,
                "predicted_class": predicted_plastic,
                "confidence": confidence,
                "plastic_subcategory": predicted_plastic,
                "processing_stage": "stage2_plastic_cnn"
            }
            
        except Exception as e:
            self.logger.error(f"Stage 2 CNN failed: {e}")
            return {
                "stage": 2,
                "predicted_class": "plastic_unknown",
                "confidence": 0.0,
                "error": str(e)
            }

    async def run_expert_system_integration(self, stage1_result: Dict, stage2_result: Optional[Dict], sensor_data: Dict) -> Dict:
        """Run expert system with CNN and sensor integration"""
        try:
            if not self.expert_system or not WasteFact:
                self.logger.warning("Expert system not available, using CNN results")
                return self.create_fallback_result(stage1_result, stage2_result)
            
            # Determine the CV label and confidence to use
            if stage2_result and stage2_result.get("confidence", 0) > 0.7:
                cv_label = stage2_result["predicted_class"]
                cv_confidence = stage2_result["confidence"]
            else:
                cv_label = stage1_result["predicted_class"]
                cv_confidence = stage1_result["confidence"]
            
            # Create WasteFact for expert system
            waste_fact = WasteFact(
                cv_label=cv_label,
                cv_confidence=cv_confidence,
                is_metal=sensor_data.get('is_metal', False),
                is_moist=sensor_data.get('is_moist', False),
                is_transparent=sensor_data.get('is_transparent', False),
                is_flexible=sensor_data.get('is_flexible', False),
                weight_grams=sensor_data.get('weight_grams', 0.0)
            )
            
            # Run expert system
            self.expert_system.reset_classification()
            self.expert_system.declare(waste_fact)
            self.expert_system.run()
            
            decision = self.expert_system.get_final_decision()
            
            if decision.final_classification:
                return {
                    "final_classification": decision.final_classification.category.value,
                    "confidence": decision.confidence_score,
                    "disposal_location": decision.final_classification.disposal_location,
                    "reasoning": decision.final_classification.reasoning,
                    "candidates_count": len(decision.candidates),
                    "processing_stage": "expert_system_validated",
                    "validation_results": {
                        "weight_validation": "pass" if sensor_data.get('weight_grams', 0) > 0 else "fail",
                        "metal_validation": "pass" if sensor_data.get('is_metal') == (cv_label == "metal") else "unknown",
                        "humidity_validation": "pass",  # Implement proper validation
                        "cnn_stage1_agreement": stage1_result["confidence"] > 0.5,
                        "cnn_stage2_agreement": stage2_result["confidence"] > 0.5 if stage2_result else True
                    }
                }
            else:
                return {
                    "final_classification": "unknown",
                    "confidence": 0.0,
                    "disposal_location": "Manual sorting required",
                    "reasoning": "Expert system could not determine classification",
                    "candidates_count": 0,
                    "processing_stage": "expert_system_failed"
                }
                
        except Exception as e:
            self.logger.error(f"Expert system integration failed: {e}")
            return self.create_fallback_result(stage1_result, stage2_result)

    def create_fallback_result(self, stage1_result: Dict, stage2_result: Optional[Dict]) -> Dict:
        """Create fallback result when expert system fails"""
        if stage2_result and stage2_result.get("confidence", 0) > stage1_result.get("confidence", 0):
            classification = stage2_result["predicted_class"]
            confidence = stage2_result["confidence"]
        else:
            classification = stage1_result["predicted_class"]
            confidence = stage1_result["confidence"]
        
        return {
            "final_classification": classification,
            "confidence": confidence,
            "disposal_location": self.get_disposal_location(classification),
            "reasoning": "Fallback to CNN prediction (expert system unavailable)",
            "candidates_count": 1,
            "processing_stage": "cnn_fallback"
        }

    async def capture_image(self) -> Optional[np.ndarray]:
        """Capture image from camera"""
        if not self.camera:
            # Return mock image for testing
            return np.random.randint(0, 255, (384, 384, 3), dtype=np.uint8)
        
        ret, frame = self.camera.read()
        if not ret:
            self.logger.error("Failed to capture frame from camera")
            return None
            
        return frame

    def preprocess_image(self, image: np.ndarray) -> np.ndarray:
        """Preprocess image for model inference"""
        # Resize to model input size
        image = cv2.resize(image, (384, 384))
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        
        # Normalize using ResNet50 preprocessing
        image = tf.keras.applications.resnet50.preprocess_input(image)
        image = np.expand_dims(image, axis=0)
        
        return image

    def get_disposal_location(self, classification: str) -> str:
        """Get disposal location for classification"""
        disposal_map = {
            'plastic': 'Plastic recycling bin',
            'PET_bottle': 'PET plastic recycling bin',
            'plastic_bag': 'Soft plastics collection',
            'container': 'Hard plastics bin', 
            'food_packaging': 'Mixed recycling (check contamination)',
            'metal': 'Metal recycling bin',
            'glass': 'Glass recycling bin',
            'paper': 'Paper recycling bin',
            'cardboard': 'Cardboard recycling bin',
        }
        return disposal_map.get(classification.lower(), 'General waste bin')

    async def send_classification_result(self, result: Dict):
        """Send complete classification result to backend"""
        try:
            success = await self.hub_client.send_message("SendClassificationResult", json.dumps(result))
            
            if success:
                self.logger.info(f"âœ… Complete result sent: {result['expert_system_result']['final_classification']}")
            else:
                self.logger.error("â�Œ Failed to send classification result to backend")
                
        except Exception as e:
            self.logger.error(f"Error sending classification result: {e}")

    async def heartbeat_worker(self):
        """Send periodic heartbeat to backend"""
        while True:
            try:
                await asyncio.sleep(30)  # Every 30 seconds
                
                heartbeat_data = {
                    "service_name": "enhanced_cnn_service",
                    "timestamp": datetime.now().isoformat(),
                    "status": "healthy",
                    "camera_connected": self.camera is not None and self.camera.isOpened() if self.camera else False,
                    "model_loaded": self.model is not None,
                    "expert_system_available": self.expert_system is not None,
                    "items_in_queue": self.processing_queue.qsize(),
                    "is_processing": self.is_processing
                }
                
                await self.hub_client.send_message("SendHeartbeat", json.dumps(heartbeat_data))
                
            except Exception as e:
                self.logger.error(f"Error sending heartbeat: {e}")

    def set_arduino_service(self, arduino_service):
        """Set Arduino service for sensor data integration"""
        self.arduino_service = arduino_service
        self.logger.info("âœ… Arduino service integration enabled")

    async def cleanup(self):
        """Cleanup resources"""
        if self.camera:
            self.camera.release()
        await self.hub_client.disconnect()
        self.logger.info("ðŸ§¹ Enhanced CNN service cleanup complete")


# Service entry point
async def start_enhanced_cnn_service():
    """Start the enhanced CNN service"""
    model_path = os.getenv('MODEL_PATH', '../models/trash_classifier_v3_93_accuracy_4mp.keras')
    backend_url = os.getenv('BACKEND_URL', 'http://localhost:5099/hubs/classification')
    
    service = CNNService(model_path, backend_url)
    await service.start_service()

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    asyncio.run(start_enhanced_cnn_service())



FILE: python-services/services/hub_client.py
------------------------------------------------------------
Size: 17.0 KB
Encoding: utf-8
------------------------------------------------------------
"""
Enhanced SignalR Hub Client for Python services
UPDATED: Now implements proper SignalR negotiation protocol
Handles robust connection management and message handling
"""

import asyncio
import aiohttp
import json
import logging
from typing import Dict, Any, Callable, Optional
import websockets
from datetime import datetime
import ssl
import urllib.parse
from uuid import uuid4

class SignalRHubClient:
    """Enhanced SignalR Hub client with PROPER SignalR protocol implementation"""
    
    def __init__(self, hub_url: str, hub_name: str):
        # Parse the hub URL correctly
        if '/hubs/' in hub_url:
            self.base_url = hub_url.split('/hubs/')[0]
            self.hub_path = '/hubs/' + hub_url.split('/hubs/')[1]
        else:
            self.base_url = hub_url.rstrip('/')
            self.hub_path = '/hubs/classification'
            
        self.hub_name = hub_name
        self.connection = None
        self.is_connected = False
        self.logger = logging.getLogger(f"SignalRClient-{hub_name}")
        
        # Connection management
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        self.reconnect_delay = 5  # seconds
        self.connection_timeout = 30  # seconds
        
        # SignalR protocol specific
        self.connection_token = None
        self.connection_id = None
        self.negotiate_version = 1
        
        # Message handling
        self.message_queue = asyncio.Queue()
        self.pending_messages = []
        self.message_handlers = {}
        self.invocation_id = 0
        
        # Health monitoring
        self.last_heartbeat = None
        self.heartbeat_interval = 30  # seconds
        
    async def connect(self) -> bool:
        """Connect to SignalR hub with PROPER negotiation protocol"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                self.logger.info(f"Connecting to SignalR hub: {self.base_url}{self.hub_path} (attempt {self.reconnect_attempts + 1})")
                
                # Step 1: Negotiate connection (CRITICAL for SignalR)
                if not await self.negotiate_connection():
                    self.reconnect_attempts += 1
                    await asyncio.sleep(self.reconnect_delay)
                    continue
                
                # Step 2: Establish WebSocket connection using negotiated token
                if not await self.establish_websocket_connection():
                    self.reconnect_attempts += 1
                    await asyncio.sleep(self.reconnect_delay)
                    continue
                
                # Step 3: Send SignalR handshake
                if not await self.send_handshake():
                    self.reconnect_attempts += 1
                    await asyncio.sleep(self.reconnect_delay)
                    continue
                
                self.is_connected = True
                self.reconnect_attempts = 0
                self.last_heartbeat = datetime.now()
                
                self.logger.info(f"✅ Connected to SignalR hub: {self.hub_name}")
                
                # Start message handling tasks
                asyncio.create_task(self.message_handler_worker())
                asyncio.create_task(self.connection_monitor_worker())
                
                # Send pending messages
                await self.send_pending_messages()
                
                return True
                
            except Exception as e:
                self.reconnect_attempts += 1
                self.logger.error(f"❌ Connection attempt {self.reconnect_attempts} failed: {e}")
                
                if self.reconnect_attempts >= self.max_reconnect_attempts:
                    self.logger.error(f"❌ Max reconnection attempts reached for {self.hub_name}")
                    return False
                
                await asyncio.sleep(self.reconnect_delay)
                self.reconnect_delay = min(self.reconnect_delay * 2, 60)  # Exponential backoff
        
        return False
    
    async def negotiate_connection(self) -> bool:
        """Perform SignalR negotiation to get connection info"""
        try:
            negotiate_url = f"{self.base_url}{self.hub_path}/negotiate?negotiateVersion={self.negotiate_version}"
            
            self.logger.debug(f"Negotiating connection: {negotiate_url}")
            
            async with aiohttp.ClientSession() as session:
                async with session.post(negotiate_url, 
                                      headers={'Content-Type': 'application/json'},
                                      timeout=aiohttp.ClientTimeout(total=10)) as response:
                    
                    if response.status != 200:
                        self.logger.error(f"Negotiate failed with status: {response.status}")
                        response_text = await response.text()
                        self.logger.error(f"Response: {response_text}")
                        return False
                    
                    negotiate_response = await response.json()
                    self.logger.debug(f"Negotiate response: {negotiate_response}")
                    
                    self.connection_token = negotiate_response.get('connectionToken')
                    self.connection_id = negotiate_response.get('connectionId')
                    
                    if not self.connection_token:
                        self.logger.error("No connection token received from negotiation")
                        return False
                    
                    self.logger.info(f"✅ Negotiated connection: {self.connection_id}")
                    return True
                    
        except Exception as e:
            self.logger.error(f"Negotiation failed: {e}")
            return False
    
    async def establish_websocket_connection(self) -> bool:
        """Establish WebSocket connection using negotiated info"""
        try:
            # Build WebSocket URL using connection token
            ws_url = self.base_url.replace('http://', 'ws://').replace('https://', 'wss://')
            ws_url = f"{ws_url}{self.hub_path}?id={self.connection_token}"
            
            self.logger.debug(f"Connecting to WebSocket: {ws_url}")
            
            # Configure SSL context for secure connections
            ssl_context = None
            if ws_url.startswith('wss://'):
                ssl_context = ssl.create_default_context()
                ssl_context.check_hostname = False
                ssl_context.verify_mode = ssl.CERT_NONE
            
            # Establish WebSocket connection
            self.connection = await websockets.connect(
                ws_url,
                ping_interval=20,
                ping_timeout=10,
                close_timeout=10,
                ssl=ssl_context,
                # extra_headers={
                #     'User-Agent': 'Python SignalR Client'
                # }
            )
            
            self.logger.info(f"✅ WebSocket connected: {ws_url[:50]}...")
            return True
            
        except Exception as e:
            self.logger.error(f"WebSocket connection failed: {e}")
            return False
    
    async def send_handshake(self) -> bool:
        """Send SignalR handshake message"""
        try:
            handshake_message = {
                "protocol": "json",
                "version": 1
            }
            
            # SignalR handshake format: JSON + record separator
            handshake_json = json.dumps(handshake_message) + "\x1e"
            await self.connection.send(handshake_json)
            
            self.logger.debug("Sent handshake message")
            
            # Wait for handshake response
            response = await asyncio.wait_for(self.connection.recv(), timeout=5.0)
            
            cleaned_response = response.strip('\x1e').strip()

            if cleaned_response == "" or cleaned_response == "{}":
                self.logger.info("✅ Handshake completed successfully")
                return True
            else:
                self.logger.debug(f"Handshake response: {response}")
                self.logger.info("✅ Handshake completed (non-standard response)")
                return True
                
        except Exception as e:
            self.logger.error(f"Handshake failed: {e}")
            return False
    
    async def send_message(self, method: str, data: str) -> bool:
        """Send message to SignalR hub with proper protocol format"""
        self.invocation_id += 1
        
        arguments = [] if data  == "" else [data]

        message = {
            "type": 1,  # Invocation message type
            "invocationId": str(self.invocation_id),
            "target": method,
            "arguments": arguments
        }
        
        if not self.is_connected or not self.connection:
            self.logger.warning(f"Not connected, queuing message: {method}")
            self.pending_messages.append(message)
            return False
            
        try:
            # Create SignalR message format with record separator
            message_json = json.dumps(message) + "\x1e"
            await self.connection.send(message_json)
            
            self.logger.debug(f"✅ Message sent: {method} (ID: {self.invocation_id})")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Failed to send message {method}: {e}")
            self.is_connected = False
            self.pending_messages.append(message)  # Queue for later
            
            # Trigger reconnection
            asyncio.create_task(self.reconnect())
            return False

    async def send_pending_messages(self):
        """Send all pending messages after reconnection"""
        if not self.pending_messages:
            return
        
        self.logger.info(f"Sending {len(self.pending_messages)} pending messages...")
        
        failed_messages = []
        for message in self.pending_messages:
            try:
                # Update invocation ID for retry
                self.invocation_id += 1
                message["invocationId"] = str(self.invocation_id)
                
                message_json = json.dumps(message) + "\x1e"
                await self.connection.send(message_json)
                self.logger.debug(f"✅ Pending message sent: {message['target']}")
            except Exception as e:
                self.logger.error(f"❌ Failed to send pending message: {e}")
                failed_messages.append(message)
        
        # Keep only failed messages for retry
        self.pending_messages = failed_messages
        self.logger.info(f"Pending messages processed. {len(failed_messages)} failed.")

    async def message_handler_worker(self):
        """Worker that handles incoming messages from the hub"""
        try:
            async for message in self.connection:
                try:
                    # Update heartbeat
                    self.last_heartbeat = datetime.now()
                    
                    # Parse SignalR message(s) - can contain multiple messages
                    if isinstance(message, str):
                        # Split by record separator in case multiple messages
                        messages = message.split('\x1e')
                        for msg in messages:
                            if msg.strip():  # Skip empty messages
                                try:
                                    parsed_message = json.loads(msg)
                                    await self.handle_incoming_message(parsed_message)
                                except json.JSONDecodeError:
                                    self.logger.debug(f"Non-JSON message received: {msg}")
                        
                except Exception as e:
                    self.logger.error(f"Error handling incoming message: {e}")
                    
        except websockets.exceptions.ConnectionClosed as e:
            self.logger.warning(f"Connection closed: {e}")
            self.is_connected = False
            await self.reconnect()
        except Exception as e:
            self.logger.error(f"Error in message handler worker: {e}")
            self.is_connected = False
            await self.reconnect()

    async def handle_incoming_message(self, message: Dict):
        """Handle incoming SignalR message"""
        message_type = message.get("type")
        
        if message_type == 1:  # Invocation
            method = message.get("target")
            arguments = message.get("arguments", [])
            
            if method in self.message_handlers:
                try:
                    await self.message_handlers[method](*arguments)
                except Exception as e:
                    self.logger.error(f"Error in message handler for {method}: {e}")
            else:
                self.logger.debug(f"No handler for method: {method}")
                
        elif message_type == 2:  # StreamItem
            self.logger.debug("Received stream item")
            
        elif message_type == 3:  # Completion
            invocation_id = message.get("invocationId")
            error = message.get("error")
            
            if error:
                self.logger.error(f"Invocation {invocation_id} failed: {error}")
            else:
                self.logger.debug(f"Invocation {invocation_id} completed successfully")
            
        elif message_type == 6:  # Ping
            # Respond with pong
            pong_message = {"type": 6}
            try:
                await self.connection.send(json.dumps(pong_message) + "\x1e")
                self.logger.debug("Responded to ping with pong")
            except:
                self.logger.warning("Failed to send pong response")

    def register_handler(self, method: str, handler: Callable):
        """Register a handler for incoming hub messages"""
        self.message_handlers[method] = handler
        self.logger.info(f"Registered handler for method: {method}")

    async def connection_monitor_worker(self):
        """Worker that monitors connection health"""
        while self.is_connected:
            try:
                await asyncio.sleep(self.heartbeat_interval)
                
                # Check if we haven't received any messages recently
                if self.last_heartbeat:
                    time_since_heartbeat = (datetime.now() - self.last_heartbeat).total_seconds()
                    
                    if time_since_heartbeat > self.heartbeat_interval * 2:
                        self.logger.warning("No heartbeat received, connection may be stale")
                        self.is_connected = False
                        await self.reconnect()
                        break
                
                # Send ping to keep connection alive
                ping_message = {"type": 6}  # Ping
                try:
                    await self.connection.send(json.dumps(ping_message) + "\x1e")
                    self.logger.debug("Sent heartbeat ping")
                except:
                    self.logger.warning("Failed to send heartbeat ping")
                    self.is_connected = False
                    await self.reconnect()
                    break
                    
            except Exception as e:
                self.logger.error(f"Error in connection monitor: {e}")

    async def reconnect(self):
        """Reconnect to the hub"""
        if self.is_connected:
            return  # Already connected
        
        self.logger.info("Attempting to reconnect...")
        await self.disconnect()
        await asyncio.sleep(1)  # Brief pause
        await self.connect()

    async def disconnect(self):
        """Disconnect from SignalR hub"""
        self.is_connected = False
        
        if self.connection:
            try:
                await self.connection.close()
            except:
                pass
            self.connection = None
            
        self.logger.info("Disconnected from SignalR hub")
    
    async def ensure_connection(self):
        """Ensure connection is active, reconnect if needed"""
        if not self.is_connected:
            await self.connect()

    async def join_group(self, group_name: str):
        """Join a SignalR group"""
        await self.send_message(f"Join{group_name}Group", "{}")

    async def leave_group(self, group_name: str):
        """Leave a SignalR group"""
        await self.send_message(f"Leave{group_name}Group", "{}")

    def get_connection_status(self) -> Dict:
        """Get current connection status"""
        return {
            "connected": self.is_connected,
            "base_url": self.base_url,
            "hub_path": self.hub_path,
            "hub_name": self.hub_name,
            "connection_id": self.connection_id,
            "reconnect_attempts": self.reconnect_attempts,
            "pending_messages": len(self.pending_messages),
            "last_heartbeat": self.last_heartbeat.isoformat() if self.last_heartbeat else None
        }

# Backward compatibility alias
SignalRHubClient = SignalRHubClient



FILE: python-services/setup.cfg
------------------------------------------------------------
Size: 205 B
Encoding: ascii
------------------------------------------------------------
[coverage:run]
source = src/smart_bin
omit = 
    */tests/*
    */test_*
    
[coverage:report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError



FILE: python-services/setup.py
------------------------------------------------------------
Size: 857 B
Encoding: ascii
------------------------------------------------------------
from setuptools import setup, find_packages

setup(
    name="smart-recycling-bin",
    version="1.0.0",
    description="Expert system for intelligent waste classification",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    install_requires=[
        "experta>=1.9.4",
    ],
    python_requires=">=3.7",
    entry_points={
        "console_scripts": [
            "smart-bin=smart_bin.interfaces.cli:main",
        ],
    },
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
    ],
)



FILE: python-services/src/smart_bin/__init__.py
------------------------------------------------------------
Size: 477 B
Encoding: ascii
------------------------------------------------------------
"""Smart Recycling Bin Package"""
__version__ = "1.0.0"
__author__ = "TBD"

"""Data models for the smart bin system"""

from .models.waste_types import WasteCategory, WasteClassification
from .models.sensors import SensorReading, CVReading, PhysicalSensorReading
from .models.decisions import ClassificationDecision

__all__ = [
    'WasteCategory',
    'WasteClassification', 
    'SensorReading',
    'CVReading',
    'PhysicalSensorReading',
    'ClassificationDecision'
]




FILE: python-services/src/smart_bin/core/__init__.py
------------------------------------------------------------
Size: 247 B
Encoding: ascii
------------------------------------------------------------
"""Core expert system components"""

from .knowledge_engine import SmartBinKnowledgeEngine
from .facts import WasteFact
from .resolver import DecisionResolver

__all__ = [
    'SmartBinKnowledgeEngine',
    'WasteFact', 
    'DecisionResolver'
]




FILE: python-services/src/smart_bin/core/facts.py
------------------------------------------------------------
Size: 483 B
Encoding: ascii
------------------------------------------------------------
from experta import Fact
from typing import Optional

class WasteFact(Fact):
    """Fact class for waste items with sensor data"""
    
    # Computer Vision
    cv_label: Optional[str] = None
    cv_confidence: Optional[float] = None
    
    # Physical Properties
    weight_grams: Optional[float] = None
    
    # Sensor Data
    is_metal: Optional[bool] = None
    is_moist: Optional[bool] = None
    is_transparent: Optional[bool] = None
    is_flexible: Optional[bool] = None



FILE: python-services/src/smart_bin/core/knowledge_engine.py
------------------------------------------------------------
Size: 7.0 KB
Encoding: utf-8
------------------------------------------------------------
from experta import KnowledgeEngine, Rule, P
from typing import List, Optional
from ..models.waste_types import WasteClassification, WasteCategory
from ..models.decisions import ClassificationDecision
from .facts import WasteFact
from .resolver import DecisionResolver

class SmartBinKnowledgeEngine(KnowledgeEngine):
    """Knowledge engine for waste classification"""
    
    def __init__(self):
        super().__init__()
        self.candidates: List[WasteClassification] = []
        self.resolver = DecisionResolver()
        self.manual_override: Optional[WasteClassification] = None
        self.reasoning_trace: List[str] = []
        
    def add_candidate(self, category: WasteCategory, confidence: float, 
                     reasoning: str, disposal_location: str) -> None:
        """Add a candidate classification"""
        
        classification = WasteClassification(
            category=category,
            confidence=confidence,
            reasoning=reasoning,
            disposal_location=disposal_location
        )
        
        self.candidates.append(classification)
        self.reasoning_trace.append(f"→ Candidate Classification: {category.value.upper()}")
        self.reasoning_trace.append(f"   Reason: {reasoning}")
        self.reasoning_trace.append(f"   Proposed Disposal: {disposal_location}")
        
        print(f"\n→ Candidate Classification: {category.value.upper()}")
        print(f"   Reason: {reasoning}")
        print(f"   Proposed Disposal: {disposal_location}")
        
    def get_final_decision(self) -> ClassificationDecision:
        """Get the final classification decision"""
        if self.manual_override:
            final = self.manual_override
            is_override = True
        else:
            final = self.resolver.resolve_candidates(self.candidates)
            is_override = False
            
        return ClassificationDecision(
            final_classification=final,
            candidates=self.candidates.copy(),
            reasoning_trace=self.reasoning_trace.copy(),
            is_manual_override=is_override
        )
        
    def set_manual_override(self, category: WasteCategory, disposal_location: str, 
                          reasoning: str) -> None:
        """Set manual override"""
        self.manual_override = WasteClassification(
            category=category,
            confidence=1.0,
            reasoning=f"User override: {reasoning}",
            disposal_location=disposal_location
        )
        
    def reset_classification(self) -> None:
        """Reset for new classification"""
        self.candidates.clear()
        self.manual_override = None
        self.reasoning_trace.clear()
        self.reset()

    # =========================================================================
    # ================================ RULES ==================================
    # =========================================================================
    
    @Rule(WasteFact(cv_label='battery', is_metal=True), salience=110)
    def rule_battery_metal_combined(self):
        reason = "CV detected battery and metal sensor triggered; classified as e-waste due to domain knowledge."
        self.add_candidate(WasteCategory.EWASTE, 1.0, reason, "E-waste collection point")

    @Rule(WasteFact(cv_label='paint can', is_metal=True), salience=110)
    def rule_hazardous_paint_can(self):
        reason = "CV detected paint can and metal sensor triggered; hazardous waste prioritized."
        self.add_candidate(WasteCategory.HAZARDOUS, 1.0, reason, "Hazardous waste disposal facility")

    @Rule(WasteFact(cv_label='can', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_can(self):
        reason = "Computer vision confidently identified the item as 'can'. Metal detected by shape and texture."
        self.add_candidate(WasteCategory.METAL, 0.9, reason, "Metal recycling bin")

    @Rule(WasteFact(cv_label='banana peel', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_banana_peel(self):
        reason = "Computer vision confidently identified the item as 'banana peel'. Typical organic shape and color."
        self.add_candidate(WasteCategory.ORGANIC, 0.9, reason, "Organic waste bin / Compost bin")

    @Rule(WasteFact(cv_label='apple core', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_apple_core(self):
        reason = "Computer vision confidently identified the item as 'apple core'. Typical organic shape and color."
        self.add_candidate(WasteCategory.ORGANIC, 0.9, reason, "Organic waste bin / Compost bin")

    @Rule(WasteFact(cv_label='paper', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_paper(self):
        reason = "Computer vision confidently identified the item as 'paper'. Paper-like texture confirmed."
        self.add_candidate(WasteCategory.PAPER, 0.85, reason, "Paper recycling bin")

    @Rule(WasteFact(cv_label='plastic bottle', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_plastic_bottle(self):
        reason = "Computer vision confidently identified the item as 'plastic bottle'. PET shape and transparency detected."
        self.add_candidate(WasteCategory.PLASTIC_PET, 0.85, reason, "Plastic PET recycling bin")

    @Rule(WasteFact(cv_label='glass bottle', cv_confidence=P(lambda c: c >= 0.7)), salience=100)
    def rule_glass_bottle(self):
        reason = "Computer vision confidently identified the item as 'glass bottle'. Glass texture and shape identified."
        self.add_candidate(WasteCategory.GLASS, 0.9, reason, "Glass recycling bin")

    @Rule(WasteFact(is_metal=True), salience=90)
    def rule_metal_sensor(self):
        reason = "Metal sensor triggered indicating metal presence."
        self.add_candidate(WasteCategory.METAL, 0.95, reason, "Metal recycling bin")

    @Rule(WasteFact(is_moist=True), salience=80)
    def rule_moisture_sensor(self):
        reason = "Moisture detected; item is likely organic or wet paper."
        self.add_candidate(WasteCategory.ORGANIC, 0.7, reason, "Organic waste bin / Compost bin")

    @Rule(WasteFact(weight_grams=P(lambda w: w > 500)), salience=75)
    def rule_heavy_item(self):
        reason = "Item is heavy (>500g); may be bulk organic waste or metal."
        self.add_candidate(WasteCategory.ORGANIC, 0.6, reason, "Organic waste bin / Compost bin")

    @Rule(WasteFact(is_transparent=True), salience=70)
    def rule_transparency(self):
        reason = "Item is transparent, often indicating PET plastic."
        self.add_candidate(WasteCategory.PLASTIC_PET, 0.75, reason, "Plastic PET recycling bin")

    @Rule(WasteFact(is_flexible=True), salience=65)
    def rule_flexibility(self):
        reason = "Flexible item detected, may be soft plastic or paper."
        self.add_candidate(WasteCategory.PLASTIC_SOFT, 0.6, reason, "Special soft plastics recycling bin or trash")

    @Rule(WasteFact(), salience=10)
    def fallback_rule(self):
        if not self.candidates:
            self.add_candidate(WasteCategory.UNKNOWN, 0.3, "No clear indicators found.", "Manual sorting recommended")





FILE: python-services/src/smart_bin/core/resolver.py
------------------------------------------------------------
Size: 1.2 KB
Encoding: ascii
------------------------------------------------------------
from typing import List, Optional
from ..models.waste_types import WasteClassification, WasteCategory

class DecisionResolver:
    """Decision resolution with priority-based scoring using enum values"""
    
    def __init__(self):
        self.priority_order = {
            WasteCategory.HAZARDOUS: 7,
            WasteCategory.EWASTE: 6,
            WasteCategory.GLASS: 5,
            WasteCategory.METAL: 4,
            WasteCategory.PLASTIC_PET: 3,
            WasteCategory.PLASTIC_SOFT: 2,
            WasteCategory.PAPER: 3,
            WasteCategory.ORGANIC: 4,
            WasteCategory.TEXTILE: 2,
            WasteCategory.RUBBER: 1,
            WasteCategory.COMPOSITE: 1,
            WasteCategory.UNKNOWN: 0
        }
    
    def resolve_candidates(self, candidates: List[WasteClassification]) -> Optional[WasteClassification]:
        """Resolve competing candidates using priority first, then confidence"""
        if not candidates:
            return None
            
        def sort_key(c):
            priority = self.priority_order.get(c.category, 0) 
            # Priority comes first, then confidence as tiebreaker
            return (priority, c.confidence)
            
        return max(candidates, key=sort_key)



FILE: python-services/src/smart_bin/interfaces/__init__.py
------------------------------------------------------------
Size: 107 B
Encoding: ascii
------------------------------------------------------------
"""User interfaces for the smart bin system"""

from .cli import CLIInterface

__all__ = ['CLIInterface']




FILE: python-services/src/smart_bin/interfaces/cli.py
------------------------------------------------------------
Size: 4.4 KB
Encoding: ascii
------------------------------------------------------------
from typing import Tuple
from ..core.knowledge_engine import SmartBinKnowledgeEngine
from ..core.facts import WasteFact
from ..models.waste_types import WasteCategory

class CLIInterface:
    """Command Line Interface for the smart bin"""
    
    def __init__(self):
        self.engine = SmartBinKnowledgeEngine()
        
    def get_user_input(self) -> Tuple[str, float, bool, bool, bool, bool, float]:
        """Get input from user (same as original implementation)"""
        print("Ultra Smart Recycling Bin\nPlease enter item details:")

        cv_label = input("CV label (e.g. bottle, can, paper, glass bottle, battery): ").strip().lower()
        try:
            cv_confidence = float(input("CV confidence (0.0 - 1.0): ").strip())
        except ValueError:
            cv_confidence = 0.5

        is_metal = input("Metal detected? (y/n): ").strip().lower() == 'y'
        is_moist = input("Moist? (y/n): ").strip().lower() == 'y'
        is_transparent = input("Transparent? (y/n): ").strip().lower() == 'y'
        is_flexible = input("Flexible? (y/n): ").strip().lower() == 'y'

        try:
            weight_grams = float(input("Weight (grams): ").strip())
        except ValueError:
            weight_grams = 0

        return cv_label, cv_confidence, is_metal, is_moist, is_transparent, is_flexible, weight_grams
    
    def classify_waste(self, cv_label: str, cv_confidence: float, is_metal: bool, 
                      is_moist: bool, is_transparent: bool, is_flexible: bool, 
                      weight_grams: float) -> None:
        """Classify waste item"""
        
        self.engine.reset_classification()
        
        waste_fact = WasteFact(
            cv_label=cv_label,
            cv_confidence=cv_confidence,
            is_metal=is_metal,
            is_moist=is_moist,
            is_transparent=is_transparent,
            is_flexible=is_flexible,
            weight_grams=weight_grams
        )
        
        self.engine.declare(waste_fact)
        self.engine.run()
        
        decision = self.engine.get_final_decision()
        self.display_result(decision)
        
    def display_result(self, decision) -> None:
        """Display classification result (same format as original)"""
        
        if decision.is_manual_override:
            print("\nManual override applied:")
        
        final = decision.final_classification
        if final:
            print(f"\nFinal Classification: {final.category.value.upper()}")
            print("Explanation:")
            print(final.reasoning)
            print(f"\nPlease dispose in: {final.disposal_location}")
        else:
            print("\nUnable to classify the item with confidence. Please sort manually.")
            
    def handle_manual_override(self) -> bool:
        """Handle manual override input"""
        override = input("\nWant to override the classification? (y/n): ").strip().lower()
        if override == 'y':
            new_class = input("Enter new classification: ").strip().lower()
            new_location = input("Enter new disposal location: ").strip()
            reason = input("Reason for override: ").strip()
            
            # Find matching category
            category = WasteCategory.UNKNOWN
            for cat in WasteCategory:
                if cat.value.lower() == new_class:
                    category = cat
                    break
            
            self.engine.set_manual_override(category, new_location, reason)
            decision = self.engine.get_final_decision()
            self.display_result(decision)
            return True
        return False
    
    def run(self) -> None:
        """Main CLI loop"""
        while True:
            try:
                cv_label, cv_confidence, is_metal, is_moist, is_transparent, is_flexible, weight_grams = self.get_user_input()
                
                self.classify_waste(cv_label, cv_confidence, is_metal, is_moist, is_transparent, is_flexible, weight_grams)
                
                self.handle_manual_override()
                
                continue_choice = input("\nClassify another item? (y/n): ").strip().lower()
                if continue_choice != 'y':
                    break
                    
            except KeyboardInterrupt:
                print("\nGoodbye!")
                break
            except Exception as e:
                print(f"\nError: {e}")
                print("Please try again.")





FILE: python-services/src/smart_bin/models/__init__.py
------------------------------------------------------------
Size: 0 B
Encoding: utf-8
------------------------------------------------------------



FILE: python-services/src/smart_bin/models/decisions.py
------------------------------------------------------------
Size: 497 B
Encoding: ascii
------------------------------------------------------------
from dataclasses import dataclass
from typing import List, Optional
from .waste_types import WasteClassification

@dataclass
class ClassificationDecision:
    final_classification: Optional[WasteClassification]
    candidates: List[WasteClassification]
    reasoning_trace: List[str]
    is_manual_override: bool = False
    confidence_score: float = 0.0

    def __post_init__(self):
        if self.final_classification:
            self.confidence_score = self.final_classification.confidence




FILE: python-services/src/smart_bin/models/sensors.py
------------------------------------------------------------
Size: 689 B
Encoding: ascii
------------------------------------------------------------
from dataclasses import dataclass
from typing import Optional, Any
from datetime import datetime

@dataclass
class SensorReading:
    sensor_type: str
    value: Any
    confidence: float
    timestamp: Optional[datetime] = None

@dataclass
class CVReading(SensorReading):
    label: str = ""
    cv_confidence: float = 0.0
    
    def __post_init__(self):
        self.sensor_type = "computer_vision"
        self.value = self.label
        self.confidence = self.cv_confidence

@dataclass
class PhysicalSensorReading(SensorReading):
    def __init__(self, sensor_type: str, value: Any, confidence: float = 1.0):
        super().__init__(sensor_type, value, confidence, datetime.now())




FILE: python-services/src/smart_bin/models/waste_types.py
------------------------------------------------------------
Size: 565 B
Encoding: ascii
------------------------------------------------------------
from dataclasses import dataclass
from enum import Enum

class WasteCategory(Enum):
    ORGANIC = "organic"
    PLASTIC_PET = "plastic (PET)"
    PLASTIC_SOFT = "plastic (soft)"
    GLASS = "glass"
    METAL = "metal"
    PAPER = "paper"
    TEXTILE = "textile"
    EWASTE = "e-waste"
    HAZARDOUS = "hazardous waste"
    RUBBER = "rubber"
    COMPOSITE = "composite material"
    UNKNOWN = "unknown"

@dataclass
class WasteClassification:
    category: WasteCategory
    confidence: float
    reasoning: str
    disposal_location: str
    priority_score: int = 0



FILE: requirements-integrated.txt
------------------------------------------------------------
Size: 378 B
Encoding: ascii
------------------------------------------------------------
experta>=1.9.4

# Machine learning and computer vision
tensorflow>=2.12.0
opencv-python>=4.7.0
numpy>=1.24.0

# Communication and networking
aiohttp>=3.8.0
websockets>=11.0

# Hardware communication
pyserial>=3.5

# Utilities
python-json-logger>=2.0.7

# Additional dependencies for improved functionality
pillow>=9.0.0
python-dotenv>=1.0.0
asyncio-mqtt>=0.13.0
pydantic>=2.0.0



FILE: requirements-test.txt
------------------------------------------------------------
Size: 48 B
Encoding: ascii
------------------------------------------------------------
experta>=1.9.4
pytest>=6.0.0
pytest-cov>=2.0.0




FILE: scripts/start-mvp.sh
------------------------------------------------------------
Size: 1.7 KB
Encoding: utf-8
------------------------------------------------------------
#!/bin/bash
# Start MVP services for development

echo "🚀 Starting Smart Recycling Bin MVP..."

# Function to check if port is in use
check_port() {
    if lsof -Pi :$1 -sTCP:LISTEN -t >/dev/null ; then
        echo "⚠️  Port $1 is already in use"
        return 1
    fi
    return 0
}

# Check required ports
check_port 5000 || { echo "Backend port 5000 is busy. Please stop the service using this port."; exit 1; }
check_port 3000 || { echo "Frontend port 3000 is busy. Please stop the service using this port."; exit 1; }

echo "✅ Ports are available"

# Start services in background
echo "🏢 Starting Backend..."
cd backend
dotnet run --urls="http://localhost:5000" &
BACKEND_PID=$!

# Wait for backend to start
echo "⏳ Waiting for backend to start..."
sleep 10

# Check if backend is running
if ! curl -f http://localhost:5000/health > /dev/null 2>&1; then
    echo "❌ Backend failed to start"
    kill $BACKEND_PID 2>/dev/null
    exit 1
fi

echo "✅ Backend started successfully"

# Start frontend
echo "⚛️ Starting Frontend..."
cd ../frontend
npm start &
FRONTEND_PID=$!

echo "✅ Frontend starting..."

# Create PID file for cleanup
echo "$BACKEND_PID" > ../mvp.pid
echo "$FRONTEND_PID" >> ../mvp.pid

echo ""
echo "🎉 MVP Started Successfully!"
echo "=========================="
echo "📱 Frontend Dashboard: http://localhost:3000"
echo "🏢 Backend API:        http://localhost:5000"
echo "📊 API Documentation:  http://localhost:5000/swagger"
echo ""
echo "🔄 The services are running in the background."
echo "💡 To stop all services, run: ./scripts/stop-mvp.sh"
echo ""
echo "📋 Logs:"
echo "   Backend:  Check terminal output or logs/ directory"
echo "   Frontend: Check browser developer console"



FILE: scripts/stop-mvp.sh
------------------------------------------------------------
Size: 896 B
Encoding: utf-8
------------------------------------------------------------
#!/bin/bash
# Stop MVP services

echo "🛑 Stopping Smart Recycling Bin MVP..."

if [ -f "mvp.pid" ]; then
    while IFS= read -r pid; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "🔴 Stopping process $pid"
            kill "$pid"
        fi
    done < mvp.pid
    
    # Wait a moment and force kill if necessary
    sleep 3
    
    while IFS= read -r pid; do
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            echo "💥 Force stopping process $pid"
            kill -9 "$pid"
        fi
    done < mvp.pid
    
    rm mvp.pid
    echo "✅ All services stopped"
else
    echo "⚠️  PID file not found. Attempting to kill by port..."
    
    # Kill processes on known ports
    lsof -ti:5000 | xargs kill -9 2>/dev/null || true
    lsof -ti:3000 | xargs kill -9 2>/dev/null || true
    
    echo "✅ Port cleanup completed"
fi



FILE: tree.txt
------------------------------------------------------------
Size: 5.6 KB
Encoding: utf-8
------------------------------------------------------------
.
├── backend
│   ├── appsettings.Development.json
│   ├── appsettings.json
│   ├── Controllers
│   │   ├── ClassificationController.cs
│   │   ├── DashboardController.cs
│   │   └── SystemController.cs
│   ├── Data
│   │   └── ApplicationDbContext.cs
│   ├── Hubs
│   │   ├── ClassificationHub.cs
│   │   └── DashboardHub.cs
│   ├── Middleware
│   │   ├── ErrorHandlingMiddleware.cs
│   │   └── RequestLoggingMiddleware.cs
│   ├── Models
│   │   ├── ApplicationSettings.cs
│   │   ├── ClassificationModels.cs
│   │   ├── ClassificationSearchCriteria.cs
│   │   ├── CnnStageInfo.cs
│   │   ├── DTOs
│   │   │   ├── ClassificationRequestDto.cs
│   │   │   ├── ClassificationResponseDto.cs
│   │   │   └── DashboardStatsDto.cs
│   │   ├── ErrorResponse.cs
│   │   ├── PagedResult.cs
│   │   └── ValidationResult.cs
│   ├── Program.cs
│   ├── Properties
│   │   └── launchSettings.json
│   ├── Services
│   │   ├── ClassificationService.cs
│   │   ├── IClassificationService.cs
│   │   ├── INotificationService.cs
│   │   ├── IOverrideService.cs
│   │   ├── ISystemHealthService.cs
│   │   ├── NotificationService.cs
│   │   ├── OverrideService.cs
│   │   ├── SystemHealthCheck.cs
│   │   └── SystemHealthService.cs
│   ├── SmartRecyclingBin.csproj
│   └── SmartRecyclingBin.http
├── config
│   ├── development
│   └── production
├── data
│   ├── smartbin.db-shm
│   └── smartbin.db-wal
├── docker
│   └── dockerfiles
│       ├── Dockerfile.backend
│       ├── Dockerfile.frontend
│       └── Dockerfile.python
├── docker-compose.dev.yml
├── docker-compose.yml
├── frontend
│   ├── Dockerfile.dev
│   ├── nginx.conf
│   ├── package.json
│   ├── package-lock.json
│   ├── public
│   │   ├── assets
│   │   ├── favicon.ico
│   │   ├── index.html
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   ├── README.md
│   ├── src
│   │   ├── App.css
│   │   ├── App.test.tsx
│   │   ├── App.tsx
│   │   ├── components
│   │   │   ├── Classification
│   │   │   │   └── ClassificationHistory.tsx
│   │   │   ├── Dashboard
│   │   │   │   └── Dashboard.tsx
│   │   │   ├── Layout
│   │   │   │   └── Layout.tsx
│   │   │   └── System
│   │   │       └── SystemHealth.tsx
│   │   ├── hooks
│   │   │   ├── useApi.ts
│   │   │   ├── useSignalR.ts
│   │   │   └── useSystemHealth.ts
│   │   ├── index.css
│   │   ├── index.tsx
│   │   ├── logo.svg
│   │   ├── react-app-env.d.ts
│   │   ├── reportWebVitals.ts
│   │   ├── services
│   │   │   ├── api.ts
│   │   │   └── signalr.ts
│   │   ├── setupTests.ts
│   │   ├── styles
│   │   ├── types
│   │   │   └── index.ts
│   │   └── utils
│   └── tsconfig.json
├── garbage_classification.py
├── models
│   ├── garbage_classification.py
│   └── trash_classifier_v3_93_accuracy_4mp.keras
├── python-services
│   ├── connection_test.py
│   ├── main.py
│   ├── orchestrated_main_service.py
│   ├── pytest.ini
│   ├── requirements_integrated.txt
│   ├── requirements.txt
│   ├── services
│   │   ├── arduino_service.py
│   │   ├── cnn_service.py
│   │   └── hub_client.py
│   ├── setup.cfg
│   ├── setup.py
│   ├── src
│   │   └── smart_bin
│   │       ├── core
│   │       │   ├── facts.py
│   │       │   ├── __init__.py
│   │       │   ├── knowledge_engine.py
│   │       │   └── resolver.py
│   │       ├── __init__.py
│   │       ├── interfaces
│   │       │   ├── cli.py
│   │       │   └── __init__.py
│   │       └── models
│   │           ├── decisions.py
│   │           ├── __init__.py
│   │           ├── sensors.py
│   │           └── waste_types.py
│   └── tests
│       ├── conftest.py
│       ├── test_integration.py
│       ├── test_knowledge_engine.py
│       ├── test_models.py
│       └── test_resolver.py
├── requirements-integrated.txt
├── requirements-test.txt
├── scripts
│   ├── deployment
│   ├── start-mvp.sh
│   └── stop-mvp.sh
└── tree.txt

41 directories, 106 files



================================================================================
END OF PROJECT BUNDLE
================================================================================